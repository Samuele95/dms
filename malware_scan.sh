#!/bin/bash
#
# Malware Scanner Script for Tsurugi Linux
# Scans a drive for malware using ClamAV, YARA rules, string analysis,
# file carving, entropy analysis, and bulk extraction
#
# Version 2.0 - Enhanced with robustness, performance, and feature improvements
#

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Default values
CLAMDB_DIR="/tmp/clamdb"
CHUNK_SIZE=500  # MB per chunk for scanning
YARA_RULES_BASE="/opt/Qu1cksc0pe/Systems"
OLEDUMP_RULES="/opt/oledump"
SCAN_OUTPUT_DIR="/tmp/malware_scan_$$"
YARA_CACHE_DIR="/tmp/yara_cache"
CHECKPOINT_FILE=""
VT_API_KEY=""
VT_RATE_LIMIT=4  # requests per minute for free API
MAX_PARALLEL_JOBS=4
LOG_LEVEL="INFO"  # DEBUG, INFO, WARNING, ERROR
LOG_FILE=""

# Portable tools settings
PORTABLE_MODE=false
PORTABLE_TOOLS_DIR="/tmp/malscan_portable_tools"
PORTABLE_KEEP=false  # Keep portable tools after scan

# Tool version configuration for portable downloads
YARA_VERSION="4.5.0"
CLAMAV_VERSION="1.3.1"

# Input handling - EWF/Forensic image support
INPUT_TYPE=""              # "block_device", "ewf", "raw_image"
ORIGINAL_INPUT=""          # User's original input path
ACTUAL_DEVICE=""           # Device path used for scanning (may be virtual)

# EWF-specific variables
IS_EWF_MOUNT=false         # Track if we mounted EWF
TEMP_MOUNT_POINT=""        # Mount point for virtual device
EWF_SEGMENTS=()            # Array of segment files found
EWF_TOTAL_SIZE=""          # Image size from ewfinfo
EWF_HASH_MD5=""            # Stored MD5 from EWF metadata
EWF_HASH_SHA1=""           # Stored SHA1 from EWF metadata
EWF_ACQUISITION_DATE=""    # Acquisition date from metadata
EWF_CASE_NUMBER=""         # Case number from metadata

# EWF options
VERIFY_EWF_HASH=false      # --verify-hash flag
FORCE_INPUT_FORMAT=""      # --input-format value
EWF_SUPPORT=true           # Enable EWF support
TEMP_MOUNT_BASE="/tmp"     # Base directory for temp mounts

# TUI/Display options
NO_COLOR=false             # --no-color flag
HIGH_CONTRAST=false        # --high-contrast flag
INTERACTIVE_MODE=false     # --interactive flag

# Scan mode options
SCAN_MODE="full"           # "full" or "slack"
SLACK_DEVICE=""            # Path to extracted slack space file

# Slack space settings
SLACK_EXTRACT_TIMEOUT=600  # Max seconds for extraction
SLACK_MIN_SIZE_MB=10       # Skip if slack < this size
MAX_CARVED_FILES=1000      # Limit recovered files
CARVING_TOOLS="foremost"   # Tools to use: foremost,photorec,scalpel

# Enhanced color scheme
SUCCESS_COLOR='\033[1;32m'   # Bright green
ERROR_COLOR='\033[1;31m'     # Bright red
WARNING_COLOR='\033[1;33m'   # Bright yellow
INFO_COLOR='\033[1;34m'      # Bright blue
HEADER_COLOR='\033[1;36m'    # Bright cyan
MUTED_COLOR='\033[0;90m'     # Gray for secondary info
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

# TUI symbols (Unicode)
SYMBOL_CHECK="✓"
SYMBOL_CROSS="✗"
SYMBOL_WARNING="⚠"
SYMBOL_BULLET="●"
SYMBOL_CIRCLE="○"
SPINNER_CHARS=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

# Configuration file locations
CONFIG_LOCATIONS=(
    "$HOME/.malscan.conf"
    "/etc/malscan.conf"
    "./malscan.conf"
)

# Track background processes for cleanup
declare -a BG_PIDS=()
declare -gA RESULTS
declare -gA SCAN_STATUS  # Track which scans succeeded/failed

# Statistics tracking array for detailed reporting
declare -gA STATS=(
    # ClamAV statistics
    [clamav_scanned]=0
    [clamav_infected]=0
    [clamav_signatures]=""

    # YARA statistics
    [yara_rules_checked]=0
    [yara_matches]=0
    [yara_match_details]=""

    # Strings analysis
    [strings_total]=0
    [strings_urls]=0
    [strings_executables]=0
    [strings_credentials]=0
    [strings_samples]=""

    # Entropy analysis
    [entropy_regions_scanned]=0
    [entropy_high_count]=0
    [entropy_avg]="0"
    [entropy_max]="0"
    [entropy_high_offsets]=""

    # File carving
    [carved_total]=0
    [carved_by_type]=""
    [carved_executables]=0

    # Slack space
    [slack_size_mb]=0
    [slack_data_recovered_mb]=0
    [slack_files_recovered]=0

    # Executables
    [pe_headers]=0
    [elf_headers]=0
    [pe_offsets]=""
    [elf_offsets]=""

    # Bulk extractor
    [bulk_emails]=0
    [bulk_urls]=0
    [bulk_ccn]=0
)

# Guidance recommendations array
declare -a GUIDANCE_RECOMMENDATIONS=()
declare -a GUIDANCE_NO_ACTION=()

# ==========================================
# CLEANUP AND TRAP HANDLERS
# ==========================================

cleanup() {
    local exit_code=$?

    log "DEBUG" "Cleanup triggered with exit code: $exit_code"

    # Kill any background processes
    for pid in "${BG_PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            log "DEBUG" "Killing background process: $pid"
            kill "$pid" 2>/dev/null || true
            wait "$pid" 2>/dev/null || true
        fi
    done

    # Save checkpoint if we have progress
    if [ -n "$CHECKPOINT_FILE" ] && [ "$SAVE_CHECKPOINT" = true ]; then
        save_checkpoint
    fi

    # Unmount EWF image if we mounted one
    if [ "$IS_EWF_MOUNT" = true ] && [ -d "$TEMP_MOUNT_POINT" ]; then
        log "DEBUG" "Unmounting EWF image from: $TEMP_MOUNT_POINT"
        if ! umount "$TEMP_MOUNT_POINT" 2>/dev/null; then
            fusermount -u "$TEMP_MOUNT_POINT" 2>/dev/null || {
                log "WARNING" "Could not unmount EWF image from $TEMP_MOUNT_POINT"
            }
        fi
        rmdir "$TEMP_MOUNT_POINT" 2>/dev/null || true
        IS_EWF_MOUNT=false
    fi

    # Clean up temp files unless --keep-output is set
    if [ "$KEEP_OUTPUT" != true ] && [ -d "$SCAN_OUTPUT_DIR" ]; then
        if [ "$exit_code" -ne 0 ]; then
            log "WARNING" "Scan interrupted. Temp files preserved at: $SCAN_OUTPUT_DIR"
        else
            # Only clean up on successful completion if not keeping output
            if [ "$KEEP_OUTPUT" != true ]; then
                log "DEBUG" "Cleaning up temp directory: $SCAN_OUTPUT_DIR"
            fi
        fi
    fi

    # Clean up YARA cache if it's a temp cache
    if [ -d "$YARA_CACHE_DIR" ] && [[ "$YARA_CACHE_DIR" == /tmp/* ]]; then
        log "DEBUG" "Preserving YARA cache at: $YARA_CACHE_DIR"
    fi

    # Clean up portable tools directory unless --portable-keep is set
    if [ "$PORTABLE_MODE" = true ] && [ "$PORTABLE_KEEP" != true ] && [ -d "$PORTABLE_TOOLS_DIR" ]; then
        log "DEBUG" "Cleaning up portable tools directory: $PORTABLE_TOOLS_DIR"
        rm -rf "$PORTABLE_TOOLS_DIR"
    elif [ "$PORTABLE_MODE" = true ] && [ "$PORTABLE_KEEP" = true ]; then
        log "INFO" "Portable tools preserved at: $PORTABLE_TOOLS_DIR"
    fi

    exit $exit_code
}

# Set trap handlers
trap cleanup EXIT
trap 'log "WARNING" "Received interrupt signal"; exit 130' INT
trap 'log "WARNING" "Received termination signal"; exit 143' TERM

# ==========================================
# LOGGING SYSTEM
# ==========================================

log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log level hierarchy: DEBUG < INFO < WARNING < ERROR
    local level_num=0
    local current_level_num=0

    case "$level" in
        DEBUG)   level_num=0 ;;
        INFO)    level_num=1 ;;
        WARNING) level_num=2 ;;
        ERROR)   level_num=3 ;;
    esac

    case "$LOG_LEVEL" in
        DEBUG)   current_level_num=0 ;;
        INFO)    current_level_num=1 ;;
        WARNING) current_level_num=2 ;;
        ERROR)   current_level_num=3 ;;
    esac

    # Skip if message level is below current log level
    if [ $level_num -lt $current_level_num ]; then
        return
    fi

    # Format message for console (unless quiet mode)
    if [ "$QUIET_MODE" != true ]; then
        case "$level" in
            DEBUG)   echo -e "${CYAN}[DEBUG]${NC} $message" ;;
            INFO)    echo -e "${BLUE}[*]${NC} $message" ;;
            WARNING) echo -e "${YELLOW}[!]${NC} $message" ;;
            ERROR)   echo -e "${RED}[-]${NC} $message" ;;
        esac
    fi

    # Write to log file if specified
    if [ -n "$LOG_FILE" ]; then
        echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    fi
}

print_banner() {
    if [ "$QUIET_MODE" = true ]; then
        return
    fi
    echo ""
    echo -e "${HEADER_COLOR}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                               ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██████╗ ███╗   ███╗███████╗${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██╔══██╗████╗ ████║██╔════╝${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██║  ██║██╔████╔██║███████╗${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██║  ██║██║╚██╔╝██║╚════██║${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██████╔╝██║ ╚═╝ ██║███████║${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}╚═════╝ ╚═╝     ╚═╝╚══════╝${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                               ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}             ${MUTED_COLOR}D R I V E   M A L W A R E   S C A N${NC}                ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                               ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${HEADER_COLOR}║${NC}                  ${BOLD}DMS v2.1${NC}  ${MUTED_COLOR}|${NC}  ${GREEN}EWF Support${NC}                     ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}      ${MUTED_COLOR}ClamAV + YARA + Forensic Analysis + Deep Scan${NC}           ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

print_status() {
    log "INFO" "$1"
}

print_success() {
    if [ "$QUIET_MODE" != true ]; then
        echo -e "${GREEN}[+]${NC} $1"
    fi
    [ -n "$LOG_FILE" ] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SUCCESS] $1" >> "$LOG_FILE"
}

print_warning() {
    log "WARNING" "$1"
}

print_error() {
    log "ERROR" "$1"
}

print_section() {
    if [ "$QUIET_MODE" = true ]; then
        return
    fi
    echo ""
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${YELLOW} $1${NC}"
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"
}

# ==========================================
# TUI HELPER FUNCTIONS
# ==========================================

# Get terminal width for responsive layouts
get_terminal_width() {
    local width
    width=$(tput cols 2>/dev/null || echo 80)
    echo "$width"
}

# Apply color settings based on --no-color and --high-contrast flags
apply_color_settings() {
    if [ "$NO_COLOR" = true ]; then
        RED=''
        GREEN=''
        YELLOW=''
        BLUE=''
        CYAN=''
        MAGENTA=''
        NC=''
        SUCCESS_COLOR=''
        ERROR_COLOR=''
        WARNING_COLOR=''
        INFO_COLOR=''
        HEADER_COLOR=''
        MUTED_COLOR=''
        BOLD=''
        DIM=''
        RESET=''
        # Use ASCII fallbacks for symbols
        SYMBOL_CHECK="[OK]"
        SYMBOL_CROSS="[X]"
        SYMBOL_WARNING="[!]"
        SYMBOL_BULLET="*"
        SYMBOL_CIRCLE="o"
    elif [ "$HIGH_CONTRAST" = true ]; then
        # High contrast mode - bold text only, no dim colors
        DIM=''
        MUTED_COLOR="$BOLD"
    fi
}

# Draw a box around content
draw_box() {
    local title="$1"
    local width="${2:-60}"
    local style="${3:-single}"  # single, double, rounded

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local tl tr bl br h v
    case "$style" in
        double)
            tl="╔" tr="╗" bl="╚" br="╝" h="═" v="║"
            ;;
        rounded)
            tl="╭" tr="╮" bl="╰" br="╯" h="─" v="│"
            ;;
        *)  # single
            tl="┌" tr="┐" bl="└" br="┘" h="─" v="│"
            ;;
    esac

    local inner_width=$((width - 2))
    local line=$(printf "%${inner_width}s" | tr ' ' "$h")

    echo -e "${HEADER_COLOR}${tl}${line}${tr}${NC}"
    if [ -n "$title" ]; then
        local title_len=${#title}
        local padding=$(( (inner_width - title_len) / 2 ))
        local left_pad=$(printf "%${padding}s" "")
        local right_pad_len=$((inner_width - padding - title_len))
        local right_pad=$(printf "%${right_pad_len}s" "")
        echo -e "${HEADER_COLOR}${v}${NC}${left_pad}${BOLD}${title}${NC}${right_pad}${HEADER_COLOR}${v}${NC}"
        echo -e "${HEADER_COLOR}${tl}${line}${tr}${NC}"
    fi
}

# Close a box
draw_box_end() {
    local width="${1:-60}"
    local style="${2:-single}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local bl br h
    case "$style" in
        double) bl="╚" br="╝" h="═" ;;
        rounded) bl="╰" br="╯" h="─" ;;
        *) bl="└" br="┘" h="─" ;;
    esac

    local inner_width=$((width - 2))
    local line=$(printf "%${inner_width}s" | tr ' ' "$h")
    echo -e "${HEADER_COLOR}${bl}${line}${br}${NC}"
}

# Draw box content line
draw_box_line() {
    local content="$1"
    local width="${2:-60}"
    local style="${3:-single}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local v
    case "$style" in
        double) v="║" ;;
        *) v="│" ;;
    esac

    local inner_width=$((width - 4))
    printf "${HEADER_COLOR}${v}${NC} %-${inner_width}s ${HEADER_COLOR}${v}${NC}\n" "$content"
}

# Enhanced progress bar with Unicode blocks
draw_progress_bar() {
    local current="$1"
    local total="$2"
    local description="${3:-Processing}"
    local width="${4:-30}"
    local start_time="${5:-}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local percent=$((current * 100 / total))
    local filled=$((percent * width / 100))
    local empty=$((width - filled))

    # Use Unicode blocks for smoother progress bar
    local bar=""
    for ((i=0; i<filled; i++)); do
        bar+="█"
    done
    for ((i=0; i<empty; i++)); do
        bar+="░"
    done

    # Calculate ETA if start_time provided
    local eta_str=""
    local speed_str=""
    if [ -n "$start_time" ] && [ "$current" -gt 0 ]; then
        local elapsed=$(($(date +%s) - start_time))
        if [ "$elapsed" -gt 0 ]; then
            local rate=$(echo "scale=2; $current / $elapsed" | bc 2>/dev/null || echo "0")
            if [ "$(echo "$rate > 0" | bc 2>/dev/null || echo 0)" = "1" ]; then
                local remaining=$((total - current))
                local eta_secs=$(echo "scale=0; $remaining / $rate" | bc 2>/dev/null || echo "0")
                local eta_min=$((eta_secs / 60))
                local eta_sec=$((eta_secs % 60))
                eta_str=$(printf "ETA: %02d:%02d" "$eta_min" "$eta_sec")
            fi
        fi
    fi

    # Clear line and print progress
    printf "\r\033[K${INFO_COLOR}[*]${NC} %s [${GREEN}%s${NC}] %3d%% %s" \
        "$description" "$bar" "$percent" "$eta_str"
}

# Animated spinner for indeterminate operations
draw_spinner() {
    local message="$1"
    local pid="$2"
    local spin_idx=0

    if [ "$QUIET_MODE" = true ]; then
        wait "$pid" 2>/dev/null
        return
    fi

    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${INFO_COLOR}%s${NC} %s" "${SPINNER_CHARS[$spin_idx]}" "$message"
        spin_idx=$(( (spin_idx + 1) % ${#SPINNER_CHARS[@]} ))
        sleep 0.1
    done
    printf "\r\033[K"  # Clear line when done
}

# Draw a status line with icon
draw_status_line() {
    local status="$1"  # success, error, warning, info, pending, running
    local message="$2"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local icon color
    case "$status" in
        success)  icon="$SYMBOL_CHECK" color="$SUCCESS_COLOR" ;;
        error)    icon="$SYMBOL_CROSS" color="$ERROR_COLOR" ;;
        warning)  icon="$SYMBOL_WARNING" color="$WARNING_COLOR" ;;
        info)     icon="$SYMBOL_BULLET" color="$INFO_COLOR" ;;
        pending)  icon="$SYMBOL_CIRCLE" color="$MUTED_COLOR" ;;
        running)  icon="$SYMBOL_BULLET" color="$YELLOW" ;;
        *)        icon="*" color="$NC" ;;
    esac

    echo -e "${color}${icon}${NC} $message"
}

# Draw a table header
draw_table_header() {
    local -a headers=("$@")
    local width=$(get_terminal_width)
    local col_width=$(( (width - 4) / ${#headers[@]} ))

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    # Top border
    printf "${HEADER_COLOR}┌"
    for ((i=0; i<${#headers[@]}; i++)); do
        printf "%${col_width}s" | tr ' ' '─'
        [ $i -lt $((${#headers[@]} - 1)) ] && printf "┬"
    done
    printf "┐${NC}\n"

    # Headers
    printf "${HEADER_COLOR}│${NC}"
    for header in "${headers[@]}"; do
        printf " ${BOLD}%-$((col_width-2))s${NC} ${HEADER_COLOR}│${NC}" "$header"
    done
    echo ""

    # Separator
    printf "${HEADER_COLOR}├"
    for ((i=0; i<${#headers[@]}; i++)); do
        printf "%${col_width}s" | tr ' ' '─'
        [ $i -lt $((${#headers[@]} - 1)) ] && printf "┼"
    done
    printf "┤${NC}\n"
}

# Draw a table row
draw_table_row() {
    local -a cols=("$@")
    local width=$(get_terminal_width)
    local col_width=$(( (width - 4) / ${#cols[@]} ))

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    printf "${HEADER_COLOR}│${NC}"
    for col in "${cols[@]}"; do
        printf " %-$((col_width-2))s ${HEADER_COLOR}│${NC}" "$col"
    done
    echo ""
}

# Draw table footer
draw_table_footer() {
    local num_cols="$1"
    local width=$(get_terminal_width)
    local col_width=$(( (width - 4) / num_cols ))

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    printf "${HEADER_COLOR}└"
    for ((i=0; i<num_cols; i++)); do
        printf "%${col_width}s" | tr ' ' '─'
        [ $i -lt $((num_cols - 1)) ] && printf "┴"
    done
    printf "┘${NC}\n"
}

# Draw summary dashboard at end of scan
draw_summary_dashboard() {
    local total_findings="$1"
    local duration="$2"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local width=64
    local inner=$((width - 4))

    echo ""
    echo -e "${HEADER_COLOR}╔$(printf '%*s' $((width-2)) | tr ' ' '═')╗${NC}"
    echo -e "${HEADER_COLOR}║$(printf '%*s' $(( (inner - 14) / 2 )) '')${BOLD}SCAN COMPLETE${NC}$(printf '%*s' $(( (inner - 13) / 2 )) '')${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╠$(printf '%*s' $((width-2)) | tr ' ' '═')╣${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"

    # Device info
    local display_input="${ORIGINAL_INPUT:-$DEVICE}"
    local input_type_display=""
    case "$INPUT_TYPE" in
        ewf) input_type_display=" (EWF Image)" ;;
        raw_image) input_type_display=" (Raw Image)" ;;
        block_device) input_type_display="" ;;
    esac

    printf "${HEADER_COLOR}║${NC}   Device:     %-43s ${HEADER_COLOR}║${NC}\n" "${display_input}${input_type_display}"
    printf "${HEADER_COLOR}║${NC}   Size:       %-43s ${HEADER_COLOR}║${NC}\n" "${DEVICE_SIZE_GB} GB"
    printf "${HEADER_COLOR}║${NC}   Scan Mode:  %-43s ${HEADER_COLOR}║${NC}\n" "$([ "$SCAN_MODE" = "slack" ] && echo "Slack Space Only" || echo "Full Drive")"
    printf "${HEADER_COLOR}║${NC}   Duration:   %-43s ${HEADER_COLOR}║${NC}\n" "$duration"

    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"

    # Statistics-based findings summary (no subjective labels)
    echo -e "${HEADER_COLOR}║${NC}   ┌────────────────────────────────────────────────────┐   ${HEADER_COLOR}║${NC}"

    # Build findings summary string
    local findings_summary=""
    local clamav_count="${RESULTS[clamav]:-0}"
    local yara_count=$((${RESULTS[yara_Windows]:-0} + ${RESULTS[yara_Linux]:-0}))
    local carved_exec="${STATS[carved_executables]:-0}"

    if [ "$clamav_count" != "0" ] && [ "$clamav_count" != "N/A" ]; then
        findings_summary+="${clamav_count} AV detection(s), "
    fi
    if [ "$yara_count" -gt 0 ]; then
        findings_summary+="${yara_count} YARA match(es), "
    fi
    if [ "$carved_exec" -gt 0 ]; then
        findings_summary+="${carved_exec} recovered exe(s), "
    fi

    # Remove trailing comma and space
    findings_summary="${findings_summary%, }"

    if [ -z "$findings_summary" ]; then
        findings_summary="No notable findings"
    fi

    printf "${HEADER_COLOR}║${NC}   │  FINDINGS: %-40s │   ${HEADER_COLOR}║${NC}\n" "$findings_summary"
    printf "${HEADER_COLOR}║${NC}   │  Items to review: %-33d │   ${HEADER_COLOR}║${NC}\n" "$total_findings"
    echo -e "${HEADER_COLOR}║${NC}   └────────────────────────────────────────────────────┘   ${HEADER_COLOR}║${NC}"

    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}   SCAN RESULTS:                                            ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}   ────────────────────────────────────────────────────     ${HEADER_COLOR}║${NC}"

    # Results breakdown with counts (no subjective icons)
    printf "${HEADER_COLOR}║${NC}     ClamAV ................ %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[clamav]:-0} detected"
    printf "${HEADER_COLOR}║${NC}     YARA Windows .......... %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[yara_Windows]:-0} matches"
    printf "${HEADER_COLOR}║${NC}     YARA Linux ............ %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[yara_Linux]:-0} matches"
    printf "${HEADER_COLOR}║${NC}     String Patterns ....... %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[strings]:-0} found"

    # Slack space results if applicable
    if [ "$SCAN_MODE" = "slack" ]; then
        printf "${HEADER_COLOR}║${NC}     Slack Space ........... %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[slack_size_mb]:-0} MB extracted"
        printf "${HEADER_COLOR}║${NC}     Files Recovered ....... %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[slack_files_recovered]:-0} files"
    fi

    # Deep scan results if applicable
    if [ "$DEEP_SCAN" = true ] || [ "$SCAN_MODE" = "slack" ]; then
        printf "${HEADER_COLOR}║${NC}     High Entropy Regions .. %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[entropy_high_count]:-0} regions"
        printf "${HEADER_COLOR}║${NC}     Carved Executables .... %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[carved_executables]:-${RESULTS[carved_files]:-0}} files"
    fi

    if [ "$SCAN_MODE" = "full" ] && [ "$DEEP_SCAN" = true ]; then
        local boot_status="Normal"
        [ "${RESULTS[boot_sector]:-0}" = "1" ] && boot_status="Review needed"
        printf "${HEADER_COLOR}║${NC}     Boot Sector ........... %-28s ${HEADER_COLOR}║${NC}\n" "$boot_status"
    fi

    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"
    printf "${HEADER_COLOR}║${NC}   Reports saved to: %-38s ${HEADER_COLOR}║${NC}\n" "$SCAN_OUTPUT_DIR"
    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╚$(printf '%*s' $((width-2)) | tr ' ' '═')╝${NC}"
}

# Clear the current line
clear_line() {
    printf "\r\033[K"
}

# Move cursor up N lines
move_cursor_up() {
    local n="${1:-1}"
    printf "\033[${n}A"
}

# ==========================================
# CONFIGURATION FILE SUPPORT
# ==========================================

load_config() {
    local config_file=""

    # Check for custom config file first
    if [ -n "$CUSTOM_CONFIG" ] && [ -f "$CUSTOM_CONFIG" ]; then
        config_file="$CUSTOM_CONFIG"
    else
        # Search default locations
        for loc in "${CONFIG_LOCATIONS[@]}"; do
            if [ -f "$loc" ]; then
                config_file="$loc"
                break
            fi
        done
    fi

    if [ -n "$config_file" ]; then
        log "DEBUG" "Loading configuration from: $config_file"

        # Source config file safely (only known variables)
        while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$key" ]] && continue

            # Remove leading/trailing whitespace and quotes
            key=$(echo "$key" | xargs)
            value=$(echo "$value" | xargs | sed 's/^["'"'"']//;s/["'"'"']$//')

            case "$key" in
                CLAMDB_DIR)       CLAMDB_DIR="$value" ;;
                CHUNK_SIZE)       CHUNK_SIZE="$value" ;;
                YARA_RULES_BASE)  YARA_RULES_BASE="$value" ;;
                OLEDUMP_RULES)    OLEDUMP_RULES="$value" ;;
                VT_API_KEY)       VT_API_KEY="$value" ;;
                VT_RATE_LIMIT)    VT_RATE_LIMIT="$value" ;;
                MAX_PARALLEL_JOBS) MAX_PARALLEL_JOBS="$value" ;;
                LOG_LEVEL)        LOG_LEVEL="$value" ;;
                YARA_CACHE_DIR)   YARA_CACHE_DIR="$value" ;;
                PORTABLE_TOOLS_DIR) PORTABLE_TOOLS_DIR="$value" ;;
                YARA_VERSION)     YARA_VERSION="$value" ;;
                CLAMAV_VERSION)   CLAMAV_VERSION="$value" ;;
                # EWF/Forensic image options
                EWF_SUPPORT)      EWF_SUPPORT="$value" ;;
                EWF_VERIFY_HASH)  [ "$value" = "true" ] && VERIFY_EWF_HASH=true ;;
                EWF_MOUNT_OPTIONS) EWF_MOUNT_OPTIONS="$value" ;;
                TEMP_MOUNT_BASE)  TEMP_MOUNT_BASE="$value" ;;
                # Display options
                NO_COLOR)         [ "$value" = "true" ] && NO_COLOR=true ;;
                HIGH_CONTRAST)    [ "$value" = "true" ] && HIGH_CONTRAST=true ;;
            esac
        done < "$config_file"

        print_status "Loaded configuration from: $config_file"
    fi
}

# ==========================================
# PORTABLE TOOLS SETUP
# ==========================================

detect_architecture() {
    local arch=$(uname -m)
    case "$arch" in
        x86_64|amd64)   echo "x86_64" ;;
        aarch64|arm64)  echo "aarch64" ;;
        armv7l|armhf)   echo "armv7" ;;
        i686|i386)      echo "i686" ;;
        *)              echo "$arch" ;;
    esac
}

setup_portable_environment() {
    print_section "Setting Up Portable Tools Environment"

    local arch=$(detect_architecture)
    log "DEBUG" "Detected architecture: $arch"

    # Create directory structure
    mkdir -p "$PORTABLE_TOOLS_DIR"/{bin,lib,share,python}

    # Export environment variables for portable tools
    export PATH="$PORTABLE_TOOLS_DIR/bin:$PATH"
    export LD_LIBRARY_PATH="$PORTABLE_TOOLS_DIR/lib:${LD_LIBRARY_PATH:-}"
    export PYTHONUSERBASE="$PORTABLE_TOOLS_DIR/python"

    print_status "Portable tools directory: $PORTABLE_TOOLS_DIR"
    print_status "Architecture: $arch"

    return 0
}

download_file() {
    local url="$1"
    local output="$2"
    local description="${3:-file}"

    log "DEBUG" "Downloading $description from: $url"

    if command -v curl &> /dev/null; then
        if curl -fsSL --connect-timeout 30 --max-time 300 -o "$output" "$url" 2>/dev/null; then
            return 0
        fi
    elif command -v wget &> /dev/null; then
        if wget -q --timeout=30 -O "$output" "$url" 2>/dev/null; then
            return 0
        fi
    else
        print_error "Neither curl nor wget available for downloads"
        return 1
    fi

    print_error "Failed to download: $description"
    return 1
}

install_yara_portable() {
    print_status "Installing YARA (portable)..."

    local arch=$(detect_architecture)
    local yara_dir="$PORTABLE_TOOLS_DIR/yara"
    mkdir -p "$yara_dir"

    # Try to download pre-built YARA binary
    # Using GitHub releases for VirusTotal/yara
    local yara_url=""

    case "$arch" in
        x86_64)
            # Try downloading from GitHub releases
            yara_url="https://github.com/VirusTotal/yara/releases/download/v${YARA_VERSION}/yara-${YARA_VERSION}-linux64.tar.gz"
            ;;
        *)
            print_warning "No pre-built YARA binary for $arch, attempting to build from source..."
            install_yara_from_source
            return $?
            ;;
    esac

    local tarball="$PORTABLE_TOOLS_DIR/yara.tar.gz"

    if download_file "$yara_url" "$tarball" "YARA ${YARA_VERSION}"; then
        if tar -xzf "$tarball" -C "$yara_dir" 2>/dev/null; then
            # Find and copy binaries
            find "$yara_dir" -name "yara" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
            find "$yara_dir" -name "yarac" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
            chmod +x "$PORTABLE_TOOLS_DIR/bin/yara" "$PORTABLE_TOOLS_DIR/bin/yarac" 2>/dev/null

            if [ -x "$PORTABLE_TOOLS_DIR/bin/yara" ]; then
                print_success "YARA installed successfully"
                rm -f "$tarball"
                return 0
            fi
        fi
    fi

    # Fallback: try building from source
    print_warning "Pre-built binary failed, attempting source build..."
    install_yara_from_source
}

install_yara_from_source() {
    local src_dir="$PORTABLE_TOOLS_DIR/src/yara"
    mkdir -p "$src_dir"

    local src_url="https://github.com/VirusTotal/yara/archive/refs/tags/v${YARA_VERSION}.tar.gz"
    local tarball="$PORTABLE_TOOLS_DIR/yara-src.tar.gz"

    if ! download_file "$src_url" "$tarball" "YARA source"; then
        return 1
    fi

    if ! tar -xzf "$tarball" -C "$src_dir" --strip-components=1 2>/dev/null; then
        print_error "Failed to extract YARA source"
        return 1
    fi

    # Check for build dependencies
    if ! command -v gcc &> /dev/null || ! command -v make &> /dev/null; then
        print_error "Build tools (gcc, make) required for source compilation"
        return 1
    fi

    print_status "Building YARA from source (this may take a while)..."

    cd "$src_dir" || return 1

    if [ -f "bootstrap.sh" ]; then
        ./bootstrap.sh > /dev/null 2>&1 || true
    fi

    if [ -f "configure" ]; then
        ./configure --prefix="$PORTABLE_TOOLS_DIR" --disable-shared > /dev/null 2>&1 && \
        make -j$(nproc 2>/dev/null || echo 2) > /dev/null 2>&1 && \
        make install > /dev/null 2>&1
    else
        # Try direct compilation
        gcc -O2 -o "$PORTABLE_TOOLS_DIR/bin/yara" libyara/*.c cli/yara.c \
            -Ilibyara/include -lpthread -lm 2>/dev/null || return 1
    fi

    cd - > /dev/null || true
    rm -f "$tarball"

    if [ -x "$PORTABLE_TOOLS_DIR/bin/yara" ]; then
        print_success "YARA built and installed successfully"
        return 0
    fi

    print_error "Failed to build YARA from source"
    return 1
}

install_clamav_portable() {
    print_status "Installing ClamAV (portable)..."

    local arch=$(detect_architecture)
    local clam_dir="$PORTABLE_TOOLS_DIR/clamav"
    mkdir -p "$clam_dir"

    # ClamAV provides portable builds
    local clam_url=""

    case "$arch" in
        x86_64)
            clam_url="https://www.clamav.net/downloads/production/clamav-${CLAMAV_VERSION}.linux.x86_64.tar.gz"
            ;;
        aarch64)
            clam_url="https://www.clamav.net/downloads/production/clamav-${CLAMAV_VERSION}.linux.aarch64.tar.gz"
            ;;
        *)
            print_warning "No pre-built ClamAV for $arch"
            return 1
            ;;
    esac

    local tarball="$PORTABLE_TOOLS_DIR/clamav.tar.gz"

    if download_file "$clam_url" "$tarball" "ClamAV ${CLAMAV_VERSION}"; then
        if tar -xzf "$tarball" -C "$clam_dir" --strip-components=1 2>/dev/null; then
            # Copy binaries
            cp "$clam_dir"/bin/* "$PORTABLE_TOOLS_DIR/bin/" 2>/dev/null || true
            cp -r "$clam_dir"/lib/* "$PORTABLE_TOOLS_DIR/lib/" 2>/dev/null || true

            chmod +x "$PORTABLE_TOOLS_DIR/bin/clamscan" "$PORTABLE_TOOLS_DIR/bin/freshclam" 2>/dev/null

            if [ -x "$PORTABLE_TOOLS_DIR/bin/clamscan" ]; then
                print_success "ClamAV installed successfully"
                rm -f "$tarball"

                # Update CLAMDB_DIR to portable location
                CLAMDB_DIR="$PORTABLE_TOOLS_DIR/share/clamav"
                mkdir -p "$CLAMDB_DIR"

                return 0
            fi
        fi
    fi

    print_error "Failed to install ClamAV"
    return 1
}

install_binwalk_portable() {
    print_status "Installing binwalk (portable via pip)..."

    # Check if python3 and pip are available
    if ! command -v python3 &> /dev/null; then
        print_error "Python3 required for binwalk installation"
        return 1
    fi

    local pip_cmd=""
    if command -v pip3 &> /dev/null; then
        pip_cmd="pip3"
    elif python3 -m pip --version &> /dev/null; then
        pip_cmd="python3 -m pip"
    else
        print_error "pip not available for Python package installation"
        return 1
    fi

    # Install binwalk to user directory
    if $pip_cmd install --user --target="$PORTABLE_TOOLS_DIR/python" binwalk > /dev/null 2>&1; then
        # Create wrapper script
        cat > "$PORTABLE_TOOLS_DIR/bin/binwalk" << 'WRAPPER_EOF'
#!/bin/bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
export PYTHONPATH="$SCRIPT_DIR/python:$PYTHONPATH"
exec python3 -m binwalk "$@"
WRAPPER_EOF
        chmod +x "$PORTABLE_TOOLS_DIR/bin/binwalk"

        if "$PORTABLE_TOOLS_DIR/bin/binwalk" --help > /dev/null 2>&1; then
            print_success "binwalk installed successfully"
            return 0
        fi
    fi

    print_error "Failed to install binwalk"
    return 1
}

install_strings_portable() {
    print_status "Installing strings (portable)..."

    # strings is part of binutils, usually always present
    # If missing, we can create a simple Python replacement

    cat > "$PORTABLE_TOOLS_DIR/bin/strings" << 'STRINGS_EOF'
#!/usr/bin/env python3
"""Portable strings implementation for extracting printable strings from files."""
import sys
import re

def extract_strings(filename, min_length=4):
    """Extract printable ASCII strings from a file."""
    pattern = rb'[\x20-\x7e]{' + str(min_length).encode() + rb',}'
    try:
        if filename == '-':
            data = sys.stdin.buffer.read()
        else:
            with open(filename, 'rb') as f:
                data = f.read()
        for match in re.finditer(pattern, data):
            print(match.group().decode('ascii', errors='ignore'))
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    return 0

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Extract printable strings from files')
    parser.add_argument('files', nargs='*', default=['-'], help='Files to process')
    parser.add_argument('-n', type=int, default=4, help='Minimum string length')
    args = parser.parse_args()

    for f in args.files:
        extract_strings(f, args.n)
STRINGS_EOF

    chmod +x "$PORTABLE_TOOLS_DIR/bin/strings"
    print_success "strings (Python implementation) installed"
    return 0
}

install_foremost_portable() {
    print_status "Installing foremost (portable)..."

    local arch=$(detect_architecture)

    # Try to download AppImage or static binary
    # Foremost doesn't have official portable builds, so we'll try to compile

    if ! command -v gcc &> /dev/null; then
        print_warning "gcc required for foremost compilation"
        return 1
    fi

    local src_url="https://github.com/korczis/foremost/archive/refs/heads/master.tar.gz"
    local src_dir="$PORTABLE_TOOLS_DIR/src/foremost"
    local tarball="$PORTABLE_TOOLS_DIR/foremost-src.tar.gz"

    mkdir -p "$src_dir"

    if download_file "$src_url" "$tarball" "foremost source"; then
        if tar -xzf "$tarball" -C "$src_dir" --strip-components=1 2>/dev/null; then
            cd "$src_dir" || return 1

            # Compile foremost
            if make -j$(nproc 2>/dev/null || echo 2) > /dev/null 2>&1; then
                cp foremost "$PORTABLE_TOOLS_DIR/bin/" 2>/dev/null
                cp foremost.conf "$PORTABLE_TOOLS_DIR/share/" 2>/dev/null || true
                chmod +x "$PORTABLE_TOOLS_DIR/bin/foremost"

                cd - > /dev/null || true
                rm -f "$tarball"

                if [ -x "$PORTABLE_TOOLS_DIR/bin/foremost" ]; then
                    print_success "foremost built and installed successfully"
                    return 0
                fi
            fi

            cd - > /dev/null || true
        fi
    fi

    print_warning "Could not install foremost (optional tool)"
    return 1
}

install_ssdeep_portable() {
    print_status "Installing ssdeep (portable)..."

    if ! command -v gcc &> /dev/null; then
        print_warning "gcc required for ssdeep compilation"
        return 1
    fi

    local src_url="https://github.com/ssdeep-project/ssdeep/releases/download/release-2.14.1/ssdeep-2.14.1.tar.gz"
    local src_dir="$PORTABLE_TOOLS_DIR/src/ssdeep"
    local tarball="$PORTABLE_TOOLS_DIR/ssdeep-src.tar.gz"

    mkdir -p "$src_dir"

    if download_file "$src_url" "$tarball" "ssdeep source"; then
        if tar -xzf "$tarball" -C "$src_dir" --strip-components=1 2>/dev/null; then
            cd "$src_dir" || return 1

            if ./configure --prefix="$PORTABLE_TOOLS_DIR" > /dev/null 2>&1 && \
               make -j$(nproc 2>/dev/null || echo 2) > /dev/null 2>&1 && \
               make install > /dev/null 2>&1; then

                cd - > /dev/null || true
                rm -f "$tarball"

                if [ -x "$PORTABLE_TOOLS_DIR/bin/ssdeep" ]; then
                    print_success "ssdeep built and installed successfully"
                    return 0
                fi
            fi

            cd - > /dev/null || true
        fi
    fi

    print_warning "Could not install ssdeep (optional tool)"
    return 1
}

install_exiftool_portable() {
    print_status "Installing exiftool (portable)..."

    # ExifTool is a Perl script, very portable
    local exif_url="https://exiftool.org/Image-ExifTool-12.76.tar.gz"
    local exif_dir="$PORTABLE_TOOLS_DIR/exiftool"
    local tarball="$PORTABLE_TOOLS_DIR/exiftool.tar.gz"

    mkdir -p "$exif_dir"

    if ! command -v perl &> /dev/null; then
        print_warning "Perl required for exiftool"
        return 1
    fi

    if download_file "$exif_url" "$tarball" "exiftool"; then
        if tar -xzf "$tarball" -C "$exif_dir" --strip-components=1 2>/dev/null; then
            # Create wrapper
            cat > "$PORTABLE_TOOLS_DIR/bin/exiftool" << EXIF_WRAPPER
#!/bin/bash
exec perl "$exif_dir/exiftool" "\$@"
EXIF_WRAPPER
            chmod +x "$PORTABLE_TOOLS_DIR/bin/exiftool"

            rm -f "$tarball"

            if "$PORTABLE_TOOLS_DIR/bin/exiftool" -ver > /dev/null 2>&1; then
                print_success "exiftool installed successfully"
                return 0
            fi
        fi
    fi

    print_warning "Could not install exiftool (optional tool)"
    return 1
}

install_md5deep_portable() {
    print_status "Installing md5deep/hashdeep (portable)..."

    # Create a Python-based replacement for md5deep
    cat > "$PORTABLE_TOOLS_DIR/bin/md5deep" << 'MD5DEEP_EOF'
#!/usr/bin/env python3
"""Portable md5deep implementation for recursive file hashing."""
import hashlib
import os
import sys

def hash_file(filepath):
    """Calculate MD5 hash of a file."""
    md5 = hashlib.md5()
    try:
        with open(filepath, 'rb') as f:
            for chunk in iter(lambda: f.read(8192), b''):
                md5.update(chunk)
        return md5.hexdigest()
    except (IOError, PermissionError):
        return None

def process_path(path, recursive=False):
    """Process a path, optionally recursively."""
    if os.path.isfile(path):
        h = hash_file(path)
        if h:
            print(f"{h}  {path}")
    elif os.path.isdir(path) and recursive:
        for root, dirs, files in os.walk(path):
            for name in files:
                filepath = os.path.join(root, name)
                h = hash_file(filepath)
                if h:
                    print(f"{h}  {filepath}")

if __name__ == '__main__':
    recursive = '-r' in sys.argv
    paths = [arg for arg in sys.argv[1:] if arg != '-r']
    if not paths:
        paths = ['.']
    for path in paths:
        process_path(path, recursive)
MD5DEEP_EOF

    chmod +x "$PORTABLE_TOOLS_DIR/bin/md5deep"
    print_success "md5deep (Python implementation) installed"
    return 0
}

install_bulk_extractor_portable() {
    print_status "Installing bulk_extractor (portable)..."

    local arch=$(detect_architecture)

    # bulk_extractor has complex dependencies, try pre-built
    local be_url=""

    case "$arch" in
        x86_64)
            # Try GitHub releases
            be_url="https://github.com/simsong/bulk_extractor/releases/download/v2.0.0/bulk_extractor-2.0.0-linux.tar.gz"
            ;;
        *)
            print_warning "No pre-built bulk_extractor for $arch"
            return 1
            ;;
    esac

    local tarball="$PORTABLE_TOOLS_DIR/bulk_extractor.tar.gz"
    local be_dir="$PORTABLE_TOOLS_DIR/bulk_extractor"

    mkdir -p "$be_dir"

    if download_file "$be_url" "$tarball" "bulk_extractor"; then
        if tar -xzf "$tarball" -C "$be_dir" --strip-components=1 2>/dev/null; then
            find "$be_dir" -name "bulk_extractor" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
            chmod +x "$PORTABLE_TOOLS_DIR/bin/bulk_extractor" 2>/dev/null

            rm -f "$tarball"

            if [ -x "$PORTABLE_TOOLS_DIR/bin/bulk_extractor" ]; then
                print_success "bulk_extractor installed successfully"
                return 0
            fi
        fi
    fi

    print_warning "Could not install bulk_extractor (optional tool)"
    return 1
}

setup_portable_tools() {
    local -a missing_basic=()
    local -a missing_deep=()

    # Check which basic tools are missing
    local basic_tools=("clamscan" "yara" "strings" "binwalk")
    local deep_tools=("foremost" "ssdeep" "exiftool" "md5deep" "bulk_extractor")

    for tool in "${basic_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing_basic+=("$tool")
        fi
    done

    if [ "$DEEP_SCAN" = true ]; then
        for tool in "${deep_tools[@]}"; do
            if ! command -v "$tool" &> /dev/null; then
                missing_deep+=("$tool")
            fi
        done
    fi

    # If no tools missing, return early
    if [ ${#missing_basic[@]} -eq 0 ] && [ ${#missing_deep[@]} -eq 0 ]; then
        print_success "All required tools are available system-wide"
        return 0
    fi

    print_status "Missing tools detected. Setting up portable environment..."
    print_status "Missing basic tools: ${missing_basic[*]:-none}"
    [ "$DEEP_SCAN" = true ] && print_status "Missing deep scan tools: ${missing_deep[*]:-none}"

    # Setup the environment
    setup_portable_environment

    local failed=0

    # Install missing basic tools
    for tool in "${missing_basic[@]}"; do
        case "$tool" in
            clamscan)
                install_clamav_portable || ((failed++))
                ;;
            yara)
                install_yara_portable || ((failed++))
                ;;
            strings)
                install_strings_portable || ((failed++))
                ;;
            binwalk)
                install_binwalk_portable || ((failed++))
                ;;
        esac
    done

    # Install missing deep scan tools (optional, don't fail)
    if [ "$DEEP_SCAN" = true ]; then
        for tool in "${missing_deep[@]}"; do
            case "$tool" in
                foremost)
                    install_foremost_portable || true
                    ;;
                ssdeep)
                    install_ssdeep_portable || true
                    ;;
                exiftool)
                    install_exiftool_portable || true
                    ;;
                md5deep)
                    install_md5deep_portable || true
                    ;;
                bulk_extractor)
                    install_bulk_extractor_portable || true
                    ;;
            esac
        done
    fi

    # Verify critical tools were installed
    print_section "Portable Tools Verification"

    local verified=0
    for tool in clamscan yara strings binwalk; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool: $(command -v $tool)"
            ((verified++))
        else
            print_error "$tool: NOT AVAILABLE"
        fi
    done

    if [ $verified -lt 4 ]; then
        print_error "Some required tools could not be installed"
        print_status "You may need to install them manually or check network connectivity"
        return 1
    fi

    print_success "Portable environment ready"
    return 0
}

# ==========================================
# INPUT VALIDATION AND SECURITY
# ==========================================

# Detect input type based on path format and file extension
detect_input_type() {
    local input="$1"

    # Check for forced format first
    if [ -n "$FORCE_INPUT_FORMAT" ]; then
        case "$FORCE_INPUT_FORMAT" in
            block|device) echo "block_device"; return 0 ;;
            ewf)          echo "ewf"; return 0 ;;
            raw)          echo "raw_image"; return 0 ;;
            auto)         ;; # Fall through to auto-detection
            *)
                print_error "Unknown input format: $FORCE_INPUT_FORMAT"
                return 1
                ;;
        esac
    fi

    # Auto-detect based on path format
    if [[ "$input" =~ ^/dev/ ]]; then
        echo "block_device"
        return 0
    fi

    # Check file extension for EWF formats
    # Supports: .E01-.E99, .Ex01, .L01-.L99, .Lx01
    local lower_input=$(echo "$input" | tr '[:upper:]' '[:lower:]')
    if [[ "$lower_input" =~ \.(e[0-9]{2}|ex[0-9]{2}|l[0-9]{2}|lx[0-9]{2})$ ]]; then
        echo "ewf"
        return 0
    fi

    # Check for raw image extensions
    if [[ "$lower_input" =~ \.(raw|dd|img|bin)$ ]]; then
        echo "raw_image"
        return 0
    fi

    # Try to detect by file magic if file exists
    if [ -f "$input" ]; then
        local file_type=$(file -b "$input" 2>/dev/null | head -1)
        if [[ "$file_type" =~ "EWF/Expert Witness" ]] || [[ "$file_type" =~ "EnCase" ]]; then
            echo "ewf"
            return 0
        fi
    fi

    echo "unknown"
    return 0
}

# Check if EWF tools are available
check_ewf_tools() {
    if ! command -v ewfmount &> /dev/null; then
        print_error "ewfmount not found. Please install libewf-tools:"
        print_error "  sudo apt install libewf-tools"
        return 1
    fi
    if ! command -v ewfinfo &> /dev/null; then
        print_warning "ewfinfo not found - EWF metadata extraction will be limited"
    fi
    return 0
}

# Validate EWF input file
validate_ewf_input() {
    local input="$1"

    # Check if first segment file exists
    if [ ! -f "$input" ]; then
        print_error "EWF image not found: $input"
        return 1
    fi

    # Check if readable
    if [ ! -r "$input" ]; then
        print_error "Cannot read EWF image: $input (permission denied)"
        return 1
    fi

    # Find all segments in the same directory
    local base_dir=$(dirname "$input")
    local base_name=$(basename "$input")
    # Extract base name without extension (e.g., "image" from "image.E01")
    local name_without_ext="${base_name%.[EeLl]*[0-9][0-9]}"

    # Find all segment files
    EWF_SEGMENTS=()
    while IFS= read -r -d '' segment; do
        EWF_SEGMENTS+=("$segment")
    done < <(find "$base_dir" -maxdepth 1 -name "${name_without_ext}.[EeLl]*" -print0 2>/dev/null | sort -z)

    if [ ${#EWF_SEGMENTS[@]} -eq 0 ]; then
        # Fallback: just use the provided file
        EWF_SEGMENTS=("$input")
    fi

    local segment_count=${#EWF_SEGMENTS[@]}
    if [ "$segment_count" -gt 1 ]; then
        print_status "Found $segment_count EWF segments"
        log "DEBUG" "EWF segments: ${EWF_SEGMENTS[*]}"
    fi

    return 0
}

# Extract EWF image metadata using ewfinfo
get_ewf_info() {
    local input="$1"

    if ! command -v ewfinfo &> /dev/null; then
        log "DEBUG" "ewfinfo not available, skipping metadata extraction"
        return 0
    fi

    print_status "Extracting EWF image metadata..."

    local ewf_output
    ewf_output=$(ewfinfo "$input" 2>/dev/null) || {
        print_warning "Could not extract EWF metadata"
        return 0
    }

    # Parse ewfinfo output
    EWF_TOTAL_SIZE=$(echo "$ewf_output" | grep -i "Media size:" | awk '{print $3}' | head -1)
    EWF_HASH_MD5=$(echo "$ewf_output" | grep -i "MD5 hash:" | awk '{print $3}' | head -1)
    EWF_HASH_SHA1=$(echo "$ewf_output" | grep -i "SHA1 hash:" | awk '{print $3}' | head -1)
    EWF_ACQUISITION_DATE=$(echo "$ewf_output" | grep -i "Acquisition date:" | cut -d: -f2- | xargs)
    EWF_CASE_NUMBER=$(echo "$ewf_output" | grep -i "Case number:" | cut -d: -f2- | xargs)

    # Display info in a nice box
    if [ "$QUIET_MODE" != true ]; then
        draw_box "EWF Image Information" 60 "rounded"
        [ -n "$EWF_TOTAL_SIZE" ] && draw_box_line "Size: $EWF_TOTAL_SIZE" 60
        [ -n "$EWF_HASH_MD5" ] && draw_box_line "MD5:  $EWF_HASH_MD5" 60
        [ -n "$EWF_HASH_SHA1" ] && draw_box_line "SHA1: $EWF_HASH_SHA1" 60
        [ -n "$EWF_ACQUISITION_DATE" ] && draw_box_line "Acquired: $EWF_ACQUISITION_DATE" 60
        [ -n "$EWF_CASE_NUMBER" ] && draw_box_line "Case: $EWF_CASE_NUMBER" 60
        draw_box_end 60 "rounded"
    fi

    return 0
}

# Verify EWF hash integrity
verify_ewf_hash() {
    local input="$1"

    if ! command -v ewfverify &> /dev/null; then
        print_warning "ewfverify not found - cannot verify EWF hash"
        return 0
    fi

    print_section "EWF Hash Verification"
    print_status "Verifying EWF image integrity (this may take a while)..."

    # Run ewfverify with progress
    local verify_result
    if [ "$QUIET_MODE" = true ]; then
        verify_result=$(ewfverify -q "$input" 2>&1)
    else
        verify_result=$(ewfverify "$input" 2>&1)
    fi
    local verify_status=$?

    if [ $verify_status -eq 0 ]; then
        print_success "EWF hash verification PASSED - Image integrity confirmed"
        draw_status_line "success" "Evidence integrity verified"
        return 0
    else
        print_error "EWF hash verification FAILED - Image may be corrupted!"
        print_error "$verify_result"
        draw_status_line "error" "Evidence integrity check failed"
        return 1
    fi
}

# Mount EWF image and return virtual device path
mount_ewf_image() {
    local input="$1"

    # Create unique temp mount point
    TEMP_MOUNT_POINT="${TEMP_MOUNT_BASE}/malscan_ewf_$$"

    print_status "Mounting EWF image..."
    log "DEBUG" "Mount point: $TEMP_MOUNT_POINT"

    # Create mount point directory
    if ! mkdir -p "$TEMP_MOUNT_POINT"; then
        print_error "Failed to create mount point: $TEMP_MOUNT_POINT"
        return 1
    fi

    # Mount EWF using FUSE
    local mount_output
    mount_output=$(ewfmount "$input" "$TEMP_MOUNT_POINT" 2>&1)
    local mount_status=$?

    if [ $mount_status -ne 0 ]; then
        print_error "Failed to mount EWF image:"
        print_error "$mount_output"
        rmdir "$TEMP_MOUNT_POINT" 2>/dev/null
        return 1
    fi

    # Wait briefly for mount to complete
    sleep 1

    # Find the virtual device (usually ewf1)
    if [ -f "$TEMP_MOUNT_POINT/ewf1" ]; then
        ACTUAL_DEVICE="$TEMP_MOUNT_POINT/ewf1"
    elif [ -f "$TEMP_MOUNT_POINT/ewf" ]; then
        ACTUAL_DEVICE="$TEMP_MOUNT_POINT/ewf"
    else
        # Try to find any file in mount point
        ACTUAL_DEVICE=$(find "$TEMP_MOUNT_POINT" -type f -name "ewf*" 2>/dev/null | head -1)
        if [ -z "$ACTUAL_DEVICE" ]; then
            print_error "No virtual device found after mounting EWF"
            umount "$TEMP_MOUNT_POINT" 2>/dev/null || fusermount -u "$TEMP_MOUNT_POINT" 2>/dev/null
            rmdir "$TEMP_MOUNT_POINT" 2>/dev/null
            return 1
        fi
    fi

    IS_EWF_MOUNT=true
    print_success "EWF mounted successfully"
    draw_status_line "success" "Virtual device: $ACTUAL_DEVICE"

    return 0
}

# Unmount EWF image (called during cleanup)
unmount_ewf_image() {
    if [ "$IS_EWF_MOUNT" != true ]; then
        return 0
    fi

    if [ -z "$TEMP_MOUNT_POINT" ] || [ ! -d "$TEMP_MOUNT_POINT" ]; then
        return 0
    fi

    log "DEBUG" "Unmounting EWF image from: $TEMP_MOUNT_POINT"

    # Try umount first, then fusermount as fallback
    if ! umount "$TEMP_MOUNT_POINT" 2>/dev/null; then
        fusermount -u "$TEMP_MOUNT_POINT" 2>/dev/null || {
            print_warning "Could not unmount EWF image from $TEMP_MOUNT_POINT"
            return 1
        }
    fi

    # Remove mount point directory
    rmdir "$TEMP_MOUNT_POINT" 2>/dev/null || true

    IS_EWF_MOUNT=false
    TEMP_MOUNT_POINT=""

    log "DEBUG" "EWF image unmounted successfully"
    return 0
}

# Validate block device (original logic)
validate_block_device() {
    local device="$1"

    # Validate device path format (prevent command injection)
    if [[ ! "$device" =~ ^/dev/[a-zA-Z0-9_/-]+$ ]]; then
        print_error "Invalid device path format: $device"
        print_error "Device path must match /dev/[a-zA-Z0-9_/-]+"
        return 1
    fi

    # Check if device exists
    if [ ! -e "$device" ]; then
        print_error "Device does not exist: $device"
        return 1
    fi

    # Check if it's a block device
    if [ ! -b "$device" ]; then
        print_error "$device is not a block device"
        return 1
    fi

    # Check if device is readable
    if [ ! -r "$device" ]; then
        print_error "Cannot read device: $device (permission denied)"
        return 1
    fi

    return 0
}

# Main validation function - handles all input types
validate_device() {
    local input="$1"

    # Check if input is provided
    if [ -z "$input" ]; then
        print_error "No device or image specified"
        return 1
    fi

    # Store original input for display purposes
    ORIGINAL_INPUT="$input"

    # Detect input type
    INPUT_TYPE=$(detect_input_type "$input")
    log "DEBUG" "Detected input type: $INPUT_TYPE"

    case "$INPUT_TYPE" in
        block_device)
            # Original block device validation
            if ! validate_block_device "$input"; then
                return 1
            fi
            ACTUAL_DEVICE="$input"
            ;;

        ewf)
            # EWF forensic image
            if [ "$EWF_SUPPORT" != true ]; then
                print_error "EWF support is disabled"
                return 1
            fi

            # Check for EWF tools
            if ! check_ewf_tools; then
                return 1
            fi

            # Validate EWF input
            if ! validate_ewf_input "$input"; then
                return 1
            fi

            # Get EWF metadata
            get_ewf_info "$input"

            # Verify hash if requested
            if [ "$VERIFY_EWF_HASH" = true ]; then
                if ! verify_ewf_hash "$input"; then
                    print_error "Hash verification failed. Aborting scan."
                    return 1
                fi
            fi

            # Mount EWF image
            if ! mount_ewf_image "$input"; then
                return 1
            fi
            ;;

        raw_image)
            # Raw disk image - validate file exists and is readable
            if [ ! -f "$input" ]; then
                print_error "Raw image not found: $input"
                return 1
            fi
            if [ ! -r "$input" ]; then
                print_error "Cannot read raw image: $input (permission denied)"
                return 1
            fi
            ACTUAL_DEVICE="$input"
            print_status "Using raw disk image: $input"
            ;;

        unknown)
            print_error "Unable to determine input type: $input"
            print_error "Supported types: block device (/dev/*), EWF (.E01), raw image (.raw, .dd)"
            print_status "Tip: Use --input-format to force a specific type"
            return 1
            ;;

        *)
            print_error "Unsupported input type: $INPUT_TYPE"
            return 1
            ;;
    esac

    return 0
}

check_privileges() {
    if [ "$EUID" -ne 0 ]; then
        print_warning "Not running as root. Some operations may fail."
        print_warning "Consider running with sudo for full access."
        return 1
    fi
    return 0
}

check_disk_space() {
    local required_mb="$1"
    local target_dir="${2:-/tmp}"

    # Get available space in MB
    local available_mb=$(df -m "$target_dir" 2>/dev/null | awk 'NR==2 {print $4}')

    if [ -z "$available_mb" ]; then
        print_warning "Could not determine available disk space"
        return 0  # Continue anyway
    fi

    if [ "$available_mb" -lt "$required_mb" ]; then
        print_error "Insufficient disk space in $target_dir"
        print_error "Required: ${required_mb}MB, Available: ${available_mb}MB"
        return 1
    fi

    log "DEBUG" "Disk space check passed: ${available_mb}MB available, ${required_mb}MB required"
    return 0
}

# ==========================================
# WRAPPER FOR GRACEFUL ERROR HANDLING
# ==========================================

run_scan() {
    local scan_name="$1"
    local scan_function="$2"
    shift 2

    if [ "$DRY_RUN" = true ]; then
        print_status "[DRY-RUN] Would execute: $scan_name"
        SCAN_STATUS["$scan_name"]="skipped"
        return 0
    fi

    log "DEBUG" "Starting scan: $scan_name"

    # Run the scan function and capture exit status
    if "$scan_function" "$@"; then
        SCAN_STATUS["$scan_name"]="success"
        log "DEBUG" "Scan completed successfully: $scan_name"
        return 0
    else
        local exit_code=$?
        SCAN_STATUS["$scan_name"]="failed"
        print_warning "Scan encountered errors: $scan_name (exit code: $exit_code)"
        return $exit_code
    fi
}

# ==========================================
# PROGRESS INDICATOR
# ==========================================

show_progress() {
    local current="$1"
    local total="$2"
    local start_time="$3"
    local description="${4:-Processing}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local percent=$((current * 100 / total))
    local elapsed=$(($(date +%s) - start_time))
    local eta="--:--"

    if [ $current -gt 0 ] && [ $elapsed -gt 0 ]; then
        local rate=$(echo "scale=2; $current / $elapsed" | bc 2>/dev/null || echo "0")
        if [ "$(echo "$rate > 0" | bc 2>/dev/null)" = "1" ]; then
            local remaining=$((total - current))
            local eta_secs=$(echo "scale=0; $remaining / $rate" | bc 2>/dev/null || echo "0")
            local eta_min=$((eta_secs / 60))
            local eta_sec=$((eta_secs % 60))
            eta=$(printf "%02d:%02d" $eta_min $eta_sec)
        fi
    fi

    # Create progress bar
    local bar_width=30
    local filled=$((percent * bar_width / 100))
    local empty=$((bar_width - filled))
    local bar=$(printf "%${filled}s" | tr ' ' '█')$(printf "%${empty}s" | tr ' ' '░')

    printf "\r${BLUE}[*]${NC} %s [%s] %3d%% ETA: %s" "$description" "$bar" "$percent" "$eta"
}

# ==========================================
# CHECKPOINT/RESUME CAPABILITY
# ==========================================

save_checkpoint() {
    if [ -z "$CHECKPOINT_FILE" ]; then
        CHECKPOINT_FILE="$SCAN_OUTPUT_DIR/.checkpoint"
    fi

    log "DEBUG" "Saving checkpoint to: $CHECKPOINT_FILE"

    {
        echo "# Malscan Checkpoint File"
        echo "# Generated: $(date)"
        echo "DEVICE=$DEVICE"
        echo "SCAN_OUTPUT_DIR=$SCAN_OUTPUT_DIR"
        echo "DEEP_SCAN=$DEEP_SCAN"
        echo "CURRENT_CHUNK=$CURRENT_CHUNK"
        echo "COMPLETED_SCANS=${!SCAN_STATUS[*]}"

        # Save results
        for key in "${!RESULTS[@]}"; do
            echo "RESULT_${key}=${RESULTS[$key]}"
        done

        # Save scan status
        for key in "${!SCAN_STATUS[@]}"; do
            echo "STATUS_${key}=${SCAN_STATUS[$key]}"
        done
    } > "$CHECKPOINT_FILE"
}

load_checkpoint() {
    local checkpoint_file="$1"

    if [ ! -f "$checkpoint_file" ]; then
        print_error "Checkpoint file not found: $checkpoint_file"
        return 1
    fi

    print_status "Loading checkpoint from: $checkpoint_file"

    while IFS='=' read -r key value; do
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        case "$key" in
            DEVICE)          DEVICE="$value" ;;
            SCAN_OUTPUT_DIR) SCAN_OUTPUT_DIR="$value" ;;
            DEEP_SCAN)       DEEP_SCAN="$value" ;;
            CURRENT_CHUNK)   RESUME_CHUNK="$value" ;;
            RESULT_*)        RESULTS["${key#RESULT_}"]="$value" ;;
            STATUS_*)        SCAN_STATUS["${key#STATUS_}"]="$value" ;;
        esac
    done < "$checkpoint_file"

    print_success "Checkpoint loaded. Resuming from chunk: ${RESUME_CHUNK:-0}"
    return 0
}

# ==========================================
# DYNAMIC CHUNK SIZE CALCULATION
# ==========================================

calculate_optimal_chunk_size() {
    # Get available memory in MB
    local available_mem=$(free -m 2>/dev/null | awk '/^Mem:/ {print $7}')

    if [ -z "$available_mem" ] || [ "$available_mem" -eq 0 ]; then
        log "DEBUG" "Could not determine available memory, using default chunk size"
        return
    fi

    # Use 25% of available memory, capped at 2GB
    local optimal=$((available_mem / 4))

    if [ $optimal -gt 2048 ]; then
        optimal=2048
    elif [ $optimal -lt 100 ]; then
        optimal=100  # Minimum chunk size
    fi

    CHUNK_SIZE=$optimal
    log "DEBUG" "Calculated optimal chunk size: ${CHUNK_SIZE}MB (based on ${available_mem}MB available)"
}

# ==========================================
# YARA RULE COMPILATION CACHING
# ==========================================

compile_yara_rules() {
    local rules_dir="$1"
    local category="$2"

    if ! command -v yarac &> /dev/null; then
        log "DEBUG" "yarac not available, using uncompiled rules"
        return 1
    fi

    mkdir -p "$YARA_CACHE_DIR"

    local cache_file="$YARA_CACHE_DIR/${category}.yarc"
    local rules_hash=$(find "$rules_dir" -name "*.yar*" -exec md5sum {} \; 2>/dev/null | md5sum | cut -d' ' -f1)
    local hash_file="$YARA_CACHE_DIR/${category}.hash"

    # Check if cache is valid
    if [ -f "$cache_file" ] && [ -f "$hash_file" ]; then
        local cached_hash=$(cat "$hash_file")
        if [ "$cached_hash" = "$rules_hash" ]; then
            log "DEBUG" "Using cached compiled rules for $category"
            echo "$cache_file"
            return 0
        fi
    fi

    # Compile rules
    log "DEBUG" "Compiling YARA rules for $category..."

    local rule_files=$(find "$rules_dir" -name "*.yar*" -type f 2>/dev/null)
    if [ -z "$rule_files" ]; then
        return 1
    fi

    # Create a combined rule file
    local combined_file="$YARA_CACHE_DIR/${category}_combined.yar"
    > "$combined_file"

    for rule in $rule_files; do
        cat "$rule" >> "$combined_file" 2>/dev/null || true
        echo "" >> "$combined_file"
    done

    if yarac "$combined_file" "$cache_file" 2>/dev/null; then
        echo "$rules_hash" > "$hash_file"
        log "DEBUG" "Compiled YARA rules cached for $category"
        echo "$cache_file"
        return 0
    else
        log "DEBUG" "Failed to compile rules for $category, using uncompiled"
        rm -f "$cache_file" "$hash_file"
        return 1
    fi
}

# ==========================================
# TOOL CHECKING
# ==========================================

usage() {
    cat << 'EOF'
DMS - Drive Malware Scan v2.1

Usage: malware_scan.sh <input> [options]

Arguments:
  <input>               Device or image to scan:
                        - Block device: /dev/sdb1
                        - EWF image: evidence.E01 (auto-detected)
                        - Raw image: disk.raw, disk.dd

Basic Options:
  -m, --mount           Mount the device before scanning
  -u, --update          Update ClamAV databases before scanning
  -d, --deep            Enable deep scan (file carving, entropy, bulk_extractor)
  -o, --output FILE     Output report file (default: auto-generated)
  -h, --help            Show this help message

Image Support:
  --verify-hash         Verify EWF hash before scanning (forensically sound)
  --input-format TYPE   Force input type: auto, block, ewf, raw (default: auto)

Scan Scope:
  --scan-mode MODE      Scan mode: full (entire drive) or slack (unallocated only)
  --slack               Shortcut for --scan-mode slack

Performance Options:
  -p, --parallel        Enable parallel scanning (ClamAV, YARA, binwalk, strings)
  --auto-chunk          Automatically calculate optimal chunk size based on RAM
  --quick               Quick scan mode (sample-based, faster preliminary analysis)

Feature Options:
  --virustotal          Enable VirusTotal hash lookup (requires API key)
  --rootkit             Run rootkit detection (requires mounted filesystem)
  --timeline            Generate file timeline using fls/mactime
  --resume FILE         Resume from a checkpoint file

Output Options:
  --html                Generate HTML report
  --json                Generate JSON report
  -q, --quiet           Quiet mode (minimal output)
  -v, --verbose         Verbose mode (debug output)

Display Options:
  --no-color            Disable colored output
  --high-contrast       High visibility mode (bold text only)
  -i, --interactive     Interactive menu mode

Advanced Options:
  --dry-run             Preview actions without executing scans
  --config FILE         Use custom configuration file
  --log-file FILE       Write logs to file
  --keep-output         Keep temporary output directory after scan

Portable Mode:
  --portable            Auto-download missing tools to private directory
  --portable-keep       Keep portable tools after scan completes
  --portable-dir DIR    Custom portable tools directory (default: /tmp/malscan_portable_tools)

Configuration:
  Config file searched in: ~/.malscan.conf, /etc/malscan.conf, ./malscan.conf

Examples:
  ./malware_scan.sh /dev/sdb1                      # Full drive scan
  ./malware_scan.sh /dev/sdb1 --slack              # Slack space only (unallocated)
  ./malware_scan.sh evidence.E01 --scan-mode slack # EWF image, slack space only
  ./malware_scan.sh /dev/sdb1 -m -u                # Mount + update DBs
  ./malware_scan.sh /dev/sdb1 -d                   # Deep forensic scan
  ./malware_scan.sh evidence.E01                   # EWF image (auto-detected)
  ./malware_scan.sh evidence.E01 --verify-hash     # Verify integrity first
  ./malware_scan.sh disk.raw --input-format raw    # Raw image
  ./malware_scan.sh /dev/sdb1 -p --auto-chunk      # Parallel scan with auto chunk
  ./malware_scan.sh /dev/sdb1 --quick              # Fast preliminary scan
  ./malware_scan.sh /dev/sdb1 --json --html        # Multiple report formats
  ./malware_scan.sh /dev/sdb1 --resume .checkpoint # Resume interrupted scan
  ./malware_scan.sh /dev/sdb1 --portable           # Auto-download missing tools
  ./malware_scan.sh /dev/sdb1 -i                   # Interactive mode

Supported Image Formats:
  - EWF/E01: Expert Witness Format (.E01, .E02, ... .Ex01, .L01, .Lx01)
  - RAW: Raw disk images (.raw, .dd, .img, .bin)
EOF
    exit 1
}

check_tools() {
    print_section "Checking Required Tools"

    local basic_tools=("clamscan" "yara" "strings" "dd" "binwalk")
    local deep_tools=("foremost" "bulk_extractor" "ssdeep" "exiftool" "md5deep")
    local slack_tools=("blkls" "foremost")  # Tools for slack space scanning
    local optional_tools=("yarac" "chkrootkit" "rkhunter" "fls" "mactime" "scalpel" "photorec")
    local missing=()

    echo "Basic tools:"
    for tool in "${basic_tools[@]}"; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool found"
        else
            print_error "$tool not found"
            missing+=("$tool")
        fi
    done

    if [ "$DEEP_SCAN" = true ]; then
        echo ""
        echo "Deep scan tools:"
        for tool in "${deep_tools[@]}"; do
            if command -v "$tool" &> /dev/null; then
                print_success "$tool found"
            else
                print_warning "$tool not found (optional)"
            fi
        done
    fi

    if [ "$SCAN_MODE" = "slack" ]; then
        echo ""
        echo "Slack space tools:"
        for tool in "${slack_tools[@]}"; do
            if command -v "$tool" &> /dev/null; then
                print_success "$tool found"
            else
                print_warning "$tool not found"
                if [ "$tool" = "blkls" ]; then
                    print_status "  Install with: apt install sleuthkit"
                fi
            fi
        done
    fi

    echo ""
    echo "Optional enhancement tools:"
    for tool in "${optional_tools[@]}"; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool found"
        else
            log "DEBUG" "$tool not available"
        fi
    done

    # Handle missing tools
    if [ ${#missing[@]} -gt 0 ]; then
        if [ "$PORTABLE_MODE" = true ]; then
            print_warning "Missing required tools: ${missing[*]}"
            print_status "Portable mode enabled - attempting to download missing tools..."
            echo ""

            if setup_portable_tools; then
                # Re-verify tools after portable setup
                missing=()
                for tool in "${basic_tools[@]}"; do
                    if ! command -v "$tool" &> /dev/null; then
                        missing+=("$tool")
                    fi
                done

                if [ ${#missing[@]} -gt 0 ]; then
                    print_error "Still missing required tools after portable setup: ${missing[*]}"
                    return 1
                fi

                print_success "All required tools now available via portable environment"
                return 0
            else
                print_error "Portable tools setup failed"
                return 1
            fi
        else
            print_error "Missing required tools: ${missing[*]}"
            print_status "Tip: Use --portable to auto-download missing tools"
            return 1
        fi
    fi

    return 0
}

get_device_info() {
    print_section "Device Information"

    # Validate device/image first (this sets ACTUAL_DEVICE and INPUT_TYPE)
    if ! validate_device "$DEVICE"; then
        return 1
    fi

    # Get device/image size based on input type
    case "$INPUT_TYPE" in
        block_device)
            # Standard block device - use lsblk
            DEVICE_SIZE=$(lsblk -b -d -n -o SIZE "$ACTUAL_DEVICE" 2>/dev/null || echo "0")
            FS_TYPE=$(lsblk -n -o FSTYPE "$ACTUAL_DEVICE" 2>/dev/null || echo "unknown")
            ;;

        ewf)
            # EWF image - use file size or ewfinfo
            if [ -n "$EWF_TOTAL_SIZE" ]; then
                # Parse size from ewfinfo (may be in various formats like "1.0 GB")
                local size_str="$EWF_TOTAL_SIZE"
                # Try to extract numeric value and unit
                local num=$(echo "$size_str" | grep -oP '[\d.]+' | head -1)
                local unit=$(echo "$size_str" | grep -oP '[KMGT]?B' | head -1)
                case "$unit" in
                    TB) DEVICE_SIZE=$(echo "$num * 1024 * 1024 * 1024 * 1024" | bc 2>/dev/null || echo "0") ;;
                    GB) DEVICE_SIZE=$(echo "$num * 1024 * 1024 * 1024" | bc 2>/dev/null || echo "0") ;;
                    MB) DEVICE_SIZE=$(echo "$num * 1024 * 1024" | bc 2>/dev/null || echo "0") ;;
                    KB) DEVICE_SIZE=$(echo "$num * 1024" | bc 2>/dev/null || echo "0") ;;
                    B|*) DEVICE_SIZE=$(echo "$num" | bc 2>/dev/null || echo "0") ;;
                esac
            else
                # Fall back to file size of virtual device
                DEVICE_SIZE=$(stat -c%s "$ACTUAL_DEVICE" 2>/dev/null || echo "0")
            fi
            FS_TYPE="EWF Image"
            ;;

        raw_image)
            # Raw image - use file size
            DEVICE_SIZE=$(stat -c%s "$ACTUAL_DEVICE" 2>/dev/null || echo "0")
            FS_TYPE="Raw Image"
            ;;

        *)
            DEVICE_SIZE=0
            FS_TYPE="unknown"
            ;;
    esac

    DEVICE_SIZE_GB=$(echo "scale=2; $DEVICE_SIZE / 1024 / 1024 / 1024" | bc 2>/dev/null || echo "unknown")

    # Display device information using TUI box
    if [ "$QUIET_MODE" != true ]; then
        draw_box "Input Source" 60 "double"

        local display_input="${ORIGINAL_INPUT:-$DEVICE}"
        local type_label=""
        case "$INPUT_TYPE" in
            block_device) type_label="Block Device" ;;
            ewf) type_label="EWF Forensic Image" ;;
            raw_image) type_label="Raw Disk Image" ;;
            *) type_label="Unknown" ;;
        esac

        draw_box_line "Input:      $display_input" 60 "double"
        draw_box_line "Type:       $type_label" 60 "double"
        draw_box_line "Size:       ${DEVICE_SIZE_GB} GB" 60 "double"

        if [ "$INPUT_TYPE" = "block_device" ]; then
            draw_box_line "Filesystem: $FS_TYPE" 60 "double"
        fi

        # EWF-specific metadata
        if [ "$INPUT_TYPE" = "ewf" ]; then
            [ -n "$EWF_HASH_MD5" ] && draw_box_line "MD5:        $EWF_HASH_MD5" 60 "double"
            [ ${#EWF_SEGMENTS[@]} -gt 1 ] && draw_box_line "Segments:   ${#EWF_SEGMENTS[@]} files" 60 "double"
            [ -n "$EWF_CASE_NUMBER" ] && draw_box_line "Case:       $EWF_CASE_NUMBER" 60 "double"
        fi

        draw_box_end 60 "double"
    fi

    # Calculate number of chunks needed
    DEVICE_SIZE_MB=$((DEVICE_SIZE / 1024 / 1024))
    if [ "$DEVICE_SIZE_MB" -eq 0 ]; then
        DEVICE_SIZE_MB=1  # Minimum 1MB to avoid division by zero
    fi
    NUM_CHUNKS=$(( (DEVICE_SIZE_MB + CHUNK_SIZE - 1) / CHUNK_SIZE ))

    if [ "$QUIET_MODE" != true ]; then
        echo ""
        print_status "Scan chunks: $NUM_CHUNKS (${CHUNK_SIZE}MB each)"
    fi

    # Update DEVICE to point to actual device for scanning functions
    # This makes EWF transparent to the scanning functions
    DEVICE="$ACTUAL_DEVICE"
    export DEVICE
    export SCAN_DEVICE="$DEVICE"

    return 0
}

mount_device() {
    print_section "Mounting Device"

    MOUNT_POINT=$(udisksctl mount -b "$DEVICE" 2>&1 | grep -oP "at \K/.*" || true)

    if [ -n "$MOUNT_POINT" ]; then
        print_success "Mounted at: $MOUNT_POINT"

        # Get usage info
        USED_SPACE=$(df -h "$MOUNT_POINT" | awk 'NR==2 {print $3}')
        AVAIL_SPACE=$(df -h "$MOUNT_POINT" | awk 'NR==2 {print $4}')
        echo "Used:       $USED_SPACE"
        echo "Available:  $AVAIL_SPACE"

        # List files
        FILE_COUNT=$(find "$MOUNT_POINT" -type f 2>/dev/null | wc -l)
        echo "Files:      $FILE_COUNT"
    else
        print_warning "Could not mount device (may already be mounted or permission denied)"
    fi
}

update_clamav() {
    print_section "Updating ClamAV Databases"

    mkdir -p "$CLAMDB_DIR"

    if freshclam --datadir="$CLAMDB_DIR" --log=/tmp/freshclam.log 2>&1 | tail -5; then
        print_success "ClamAV databases updated"
    else
        print_warning "Could not update ClamAV databases, using existing if available"
    fi
}

check_clamav_db() {
    if [ ! -d "$CLAMDB_DIR" ] || [ -z "$(ls -A $CLAMDB_DIR/*.cvd 2>/dev/null)" ]; then
        print_warning "ClamAV databases not found, downloading..."
        update_clamav
    fi

    # Verify databases exist
    if [ -z "$(ls -A $CLAMDB_DIR/*.cvd 2>/dev/null)" ]; then
        print_error "ClamAV databases not available"
        return 1
    fi

    # Get signature count
    SIG_COUNT=$(clamscan --database="$CLAMDB_DIR" --version 2>/dev/null | head -1 || echo "unknown")
    print_status "ClamAV: $SIG_COUNT"
    return 0
}

# ==========================================
# SCANNING FUNCTIONS
# ==========================================

scan_clamav() {
    print_section "ClamAV Scan"

    if ! check_clamav_db; then
        print_error "Skipping ClamAV scan - no databases"
        RESULTS["clamav"]="N/A"
        return 1
    fi

    CLAMAV_INFECTED=0

    print_status "Scanning device in ${CHUNK_SIZE}MB chunks..."

    local offset=${RESUME_CHUNK:-0}
    local chunk_num=$((offset / CHUNK_SIZE + 1))
    local start_time=$(date +%s)

    while [ $offset -lt $DEVICE_SIZE_MB ]; do
        CURRENT_CHUNK=$offset

        show_progress $chunk_num $NUM_CHUNKS $start_time "ClamAV scanning"

        result=$(dd if="$DEVICE" bs=1M count=$CHUNK_SIZE skip=$offset 2>/dev/null | \
                 clamscan --database="$CLAMDB_DIR" - 2>&1) || true

        infected=$(echo "$result" | grep "Infected files:" | awk '{print $3}')
        if [ "$infected" != "0" ] && [ -n "$infected" ]; then
            CLAMAV_INFECTED=$((CLAMAV_INFECTED + infected))
            echo ""
            print_error "MALWARE DETECTED in chunk $chunk_num!"
            echo "$result" | grep -E "FOUND|Infected"
        fi

        offset=$((offset + CHUNK_SIZE))
        chunk_num=$((chunk_num + 1))

        # Save checkpoint periodically
        if [ "$SAVE_CHECKPOINT" = true ] && [ $((chunk_num % 10)) -eq 0 ]; then
            save_checkpoint
        fi
    done

    echo ""
    if [ $CLAMAV_INFECTED -eq 0 ]; then
        print_success "ClamAV: CLEAN (0 infected)"
    else
        print_error "ClamAV: $CLAMAV_INFECTED INFECTED FILES FOUND"
    fi

    RESULTS["clamav"]=$CLAMAV_INFECTED
    return 0
}

scan_yara_category() {
    local category=$1
    local rules_dir=$2
    local sample_size=${3:-500}

    if [ ! -d "$rules_dir" ]; then
        print_warning "YARA rules directory not found: $rules_dir"
        return 0
    fi

    local rule_count=$(find "$rules_dir" -name "*.yar*" 2>/dev/null | wc -l)
    if [ "$rule_count" -eq 0 ]; then
        print_warning "No YARA rules found in: $rules_dir"
        return 0
    fi

    print_status "Scanning with $category rules ($rule_count rules)..."

    local matches=0
    local scanned=0

    # Try to use compiled rules
    local compiled_rules=$(compile_yara_rules "$rules_dir" "$category")

    if [ -n "$compiled_rules" ] && [ -f "$compiled_rules" ]; then
        # Use compiled rules
        result=$(dd if="$DEVICE" bs=1M count=$sample_size 2>/dev/null | yara -C "$compiled_rules" - 2>/dev/null || true)
        if [ -n "$result" ]; then
            matches=$(echo "$result" | wc -l)
            print_error "YARA MATCHES ($category):"
            echo "$result"
        fi
        scanned=$rule_count
    else
        # Fall back to individual rules
        for rule in "$rules_dir"/*.yar*; do
            if [ -f "$rule" ]; then
                scanned=$((scanned + 1))
                result=$(dd if="$DEVICE" bs=1M count=$sample_size 2>/dev/null | yara -w "$rule" - 2>/dev/null || true)

                if [ -n "$result" ]; then
                    matches=$((matches + 1))
                    print_error "YARA MATCH: $(basename "$rule")"
                    echo "$result"
                fi
            fi
        done
    fi

    if [ $matches -eq 0 ]; then
        print_success "$category: CLEAN ($scanned rules checked)"
    else
        print_error "$category: $matches MATCHES FOUND"
    fi

    RESULTS["yara_$category"]=$matches
    return 0
}

scan_yara() {
    print_section "YARA Scan"

    # Windows malware
    scan_yara_category "Windows" "$YARA_RULES_BASE/Windows/YaraRules_Windows"

    # Linux malware
    scan_yara_category "Linux" "$YARA_RULES_BASE/Linux/YaraRules_Linux"

    # Android malware
    scan_yara_category "Android" "$YARA_RULES_BASE/Android/YaraRules"

    # Document malware (oledump)
    if [ -d "$OLEDUMP_RULES" ]; then
        scan_yara_category "Documents" "$OLEDUMP_RULES"
    fi

    return 0
}

scan_binwalk() {
    print_section "Binwalk Signature Scan"

    print_status "Scanning for embedded file signatures..."

    binwalk_result=$(binwalk --signature "$DEVICE" 2>/dev/null | head -50) || true

    if [ -z "$binwalk_result" ] || [ "$(echo "$binwalk_result" | wc -l)" -le 3 ]; then
        print_success "Binwalk: No suspicious embedded files detected"
        RESULTS["binwalk"]=0
    else
        print_warning "Binwalk found embedded signatures:"
        echo "$binwalk_result"
        RESULTS["binwalk"]=1
    fi

    return 0
}

scan_strings() {
    print_section "String Analysis"

    print_status "Searching for suspicious strings..."

    # Suspicious patterns
    local patterns=(
        "http://|https://"
        "\.exe|\.dll|\.bat|\.ps1|\.vbs|\.scr"
        "cmd\.exe|powershell|wscript|cscript"
        "password|passwd|credential"
        "ransomware|decrypt|bitcoin|wallet"
        "keylog|backdoor|trojan|malware"
        "base64_decode|eval\(|exec\("
    )

    local found=0

    for pattern in "${patterns[@]}"; do
        matches=$(dd if="$DEVICE" bs=1M count=1000 2>/dev/null | strings -n 8 | grep -iE "$pattern" | head -20) || true
        if [ -n "$matches" ]; then
            found=$((found + 1))
            print_warning "Pattern '$pattern' found:"
            echo "$matches" | head -10
            echo ""
        fi
    done

    if [ $found -eq 0 ]; then
        print_success "String analysis: CLEAN"
    else
        print_warning "String analysis: $found suspicious patterns found"
    fi

    RESULTS["strings"]=$found
    return 0
}

# ==========================================
# PARALLEL SCANNING
# ==========================================

run_parallel_scans() {
    print_section "Parallel Scanning Mode"

    print_status "Running scans in parallel (max $MAX_PARALLEL_JOBS jobs)..."

    local temp_dir="$SCAN_OUTPUT_DIR/parallel_results"
    mkdir -p "$temp_dir"

    # Start scans in background
    (
        scan_clamav > "$temp_dir/clamav.log" 2>&1
        echo "clamav:${RESULTS[clamav]:-0}" > "$temp_dir/clamav.result"
    ) &
    BG_PIDS+=($!)

    (
        scan_yara > "$temp_dir/yara.log" 2>&1
        for key in "${!RESULTS[@]}"; do
            [[ "$key" == yara_* ]] && echo "$key:${RESULTS[$key]}" >> "$temp_dir/yara.result"
        done
    ) &
    BG_PIDS+=($!)

    (
        scan_binwalk > "$temp_dir/binwalk.log" 2>&1
        echo "binwalk:${RESULTS[binwalk]:-0}" > "$temp_dir/binwalk.result"
    ) &
    BG_PIDS+=($!)

    (
        scan_strings > "$temp_dir/strings.log" 2>&1
        echo "strings:${RESULTS[strings]:-0}" > "$temp_dir/strings.result"
    ) &
    BG_PIDS+=($!)

    # Wait for all background jobs
    local job_count=${#BG_PIDS[@]}
    local completed=0

    for pid in "${BG_PIDS[@]}"; do
        wait "$pid" 2>/dev/null || true
        completed=$((completed + 1))
        show_progress $completed $job_count $(date +%s) "Parallel scans"
    done

    echo ""

    # Collect results
    for result_file in "$temp_dir"/*.result; do
        if [ -f "$result_file" ]; then
            while IFS=':' read -r key value; do
                RESULTS["$key"]="$value"
            done < "$result_file"
        fi
    done

    # Show logs
    print_status "Scan logs available in: $temp_dir"

    # Clear background PIDs array
    BG_PIDS=()

    return 0
}

# ==========================================
# QUICK SCAN MODE
# ==========================================

scan_quick() {
    print_section "Quick Scan Mode"

    print_status "Performing sample-based quick scan (10 random regions)..."

    local num_samples=10
    local sample_size_mb=50
    local max_offset=$((DEVICE_SIZE_MB - sample_size_mb))
    local suspicious_count=0

    if [ $max_offset -le 0 ]; then
        max_offset=$DEVICE_SIZE_MB
        sample_size_mb=$((DEVICE_SIZE_MB / num_samples))
    fi

    for i in $(seq 1 $num_samples); do
        local offset=$((RANDOM % max_offset))

        printf "\r${BLUE}[*]${NC} Scanning sample %d/%d at offset %dMB..." "$i" "$num_samples" "$offset"

        # Quick ClamAV check
        local result=$(dd if="$DEVICE" bs=1M count=$sample_size_mb skip=$offset 2>/dev/null | \
                      clamscan --database="$CLAMDB_DIR" - 2>&1) || true

        local infected=$(echo "$result" | grep "Infected files:" | awk '{print $3}')
        if [ "$infected" != "0" ] && [ -n "$infected" ]; then
            suspicious_count=$((suspicious_count + 1))
            echo ""
            print_error "Suspicious content at offset ${offset}MB!"
        fi

        # Quick string check
        local sus_strings=$(dd if="$DEVICE" bs=1M count=$sample_size_mb skip=$offset 2>/dev/null | \
                          strings -n 8 | grep -iE "malware|trojan|backdoor|ransomware" | head -5) || true
        if [ -n "$sus_strings" ]; then
            suspicious_count=$((suspicious_count + 1))
        fi
    done

    echo ""

    if [ $suspicious_count -eq 0 ]; then
        print_success "Quick scan: No obvious threats detected"
        print_status "Recommendation: Run full scan for comprehensive analysis"
    else
        print_error "Quick scan: $suspicious_count suspicious regions found!"
        print_status "Recommendation: Run full deep scan immediately"
    fi

    RESULTS["quick_scan"]=$suspicious_count
    return 0
}

# ==========================================
# VIRUSTOTAL INTEGRATION
# ==========================================

scan_virustotal() {
    print_section "VirusTotal Hash Lookup"

    if [ -z "$VT_API_KEY" ]; then
        print_warning "VirusTotal API key not configured"
        print_status "Set VT_API_KEY in config file or environment"
        return 0
    fi

    if [ -z "$MOUNT_POINT" ] || [ ! -d "$MOUNT_POINT" ]; then
        print_warning "No mounted filesystem for VirusTotal scan"
        return 0
    fi

    print_status "Checking file hashes against VirusTotal..."

    local vt_results="$SCAN_OUTPUT_DIR/virustotal_results.txt"
    local checked=0
    local malicious=0
    local rate_limit_delay=$((60 / VT_RATE_LIMIT))

    # Get list of executable files
    local exec_files=$(find "$MOUNT_POINT" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.scr" -o -executable \) 2>/dev/null | head -20)

    for file in $exec_files; do
        if [ ! -f "$file" ]; then
            continue
        fi

        local file_hash=$(sha256sum "$file" 2>/dev/null | cut -d' ' -f1)
        if [ -z "$file_hash" ]; then
            continue
        fi

        printf "\r${BLUE}[*]${NC} Checking: %s..." "$(basename "$file")"

        # Query VirusTotal
        local vt_response=$(curl -s --request GET \
            --url "https://www.virustotal.com/api/v3/files/$file_hash" \
            --header "x-apikey: $VT_API_KEY" 2>/dev/null)

        if echo "$vt_response" | grep -q '"malicious"'; then
            local malicious_count=$(echo "$vt_response" | grep -oP '"malicious":\s*\K\d+' | head -1)
            if [ "$malicious_count" -gt 0 ]; then
                malicious=$((malicious + 1))
                echo ""
                print_error "MALICIOUS: $file ($malicious_count detections)"
                echo "$file: $malicious_count detections" >> "$vt_results"
            fi
        fi

        checked=$((checked + 1))

        # Rate limiting
        sleep $rate_limit_delay
    done

    echo ""

    if [ $malicious -eq 0 ]; then
        print_success "VirusTotal: No known malware found ($checked files checked)"
    else
        print_error "VirusTotal: $malicious MALICIOUS files detected!"
        print_status "Details saved to: $vt_results"
    fi

    RESULTS["virustotal"]=$malicious
    return 0
}

# ==========================================
# ROOTKIT DETECTION
# ==========================================

scan_rootkit() {
    print_section "Rootkit Detection"

    if [ -z "$MOUNT_POINT" ] || [ ! -d "$MOUNT_POINT" ]; then
        print_warning "Rootkit scan requires mounted filesystem"
        return 0
    fi

    local rootkit_findings=0

    # Try chkrootkit
    if command -v chkrootkit &> /dev/null; then
        print_status "Running chkrootkit..."

        local chk_result=$(chkrootkit -r "$MOUNT_POINT" 2>/dev/null | grep -i "INFECTED" || true)

        if [ -n "$chk_result" ]; then
            rootkit_findings=$((rootkit_findings + 1))
            print_error "chkrootkit found infections:"
            echo "$chk_result"
        else
            print_success "chkrootkit: No rootkits detected"
        fi
    else
        print_warning "chkrootkit not available"
    fi

    # Try rkhunter
    if command -v rkhunter &> /dev/null; then
        print_status "Running rkhunter (basic checks)..."

        local rkh_result=$(rkhunter --check --skip-keypress --rootdir "$MOUNT_POINT" \
                         --report-warnings-only 2>/dev/null | grep -i "warning" || true)

        if [ -n "$rkh_result" ]; then
            rootkit_findings=$((rootkit_findings + 1))
            print_warning "rkhunter warnings:"
            echo "$rkh_result" | head -10
        else
            print_success "rkhunter: No warnings"
        fi
    else
        print_warning "rkhunter not available"
    fi

    if [ $rootkit_findings -eq 0 ]; then
        print_success "Rootkit scan: CLEAN"
    else
        print_error "Rootkit scan: $rootkit_findings potential issues found"
    fi

    RESULTS["rootkit"]=$rootkit_findings
    return 0
}

# ==========================================
# FILE TIMELINE GENERATION
# ==========================================

generate_timeline() {
    print_section "File Timeline Generation"

    if ! command -v fls &> /dev/null || ! command -v mactime &> /dev/null; then
        print_warning "Timeline tools (fls, mactime) not available"
        return 0
    fi

    local timeline_dir="$SCAN_OUTPUT_DIR/timeline"
    mkdir -p "$timeline_dir"

    print_status "Extracting filesystem metadata with fls..."

    # Generate body file
    local body_file="$timeline_dir/filesystem.body"
    if fls -r -m "/" "$DEVICE" > "$body_file" 2>/dev/null; then
        local entry_count=$(wc -l < "$body_file")
        print_success "Extracted $entry_count filesystem entries"

        # Generate timeline
        print_status "Creating timeline with mactime..."
        local timeline_file="$timeline_dir/timeline.txt"

        if mactime -b "$body_file" > "$timeline_file" 2>/dev/null; then
            print_success "Timeline generated: $timeline_file"

            # Show recent activity
            echo ""
            print_status "Recent file activity (last 10 entries):"
            tail -10 "$timeline_file"

            RESULTS["timeline"]=1
        else
            print_warning "Failed to generate timeline"
            RESULTS["timeline"]=0
        fi
    else
        print_warning "Failed to extract filesystem metadata"
        RESULTS["timeline"]=0
    fi

    return 0
}

# ==========================================
# SLACK SPACE ANALYSIS FUNCTIONS
# ==========================================

extract_slack_space() {
    print_section "Slack Space Extraction"

    local device_to_extract="$DEVICE"
    local slack_file="$SCAN_OUTPUT_DIR/unallocated.raw"

    # Check if blkls is available
    if ! command -v blkls &>/dev/null; then
        print_error "blkls (Sleuth Kit) not found. Required for slack space extraction."
        print_status "Install with: apt install sleuthkit"
        return 1
    fi

    print_status "Extracting unallocated blocks from $device_to_extract..."
    print_status "This may take a while depending on disk size..."

    # Extract unallocated space using blkls
    # -A extracts all unallocated blocks (slack space + unallocated)
    local start_time=$(date +%s)

    if timeout "$SLACK_EXTRACT_TIMEOUT" blkls -A "$device_to_extract" > "$slack_file" 2>/dev/null; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))

        # Get size of extracted data
        local slack_size_bytes=$(stat -c%s "$slack_file" 2>/dev/null || echo 0)
        local slack_size_mb=$((slack_size_bytes / 1024 / 1024))

        STATS[slack_size_mb]=$slack_size_mb

        if [ "$slack_size_mb" -lt "$SLACK_MIN_SIZE_MB" ]; then
            print_warning "Slack space too small (${slack_size_mb}MB < ${SLACK_MIN_SIZE_MB}MB minimum)"
            rm -f "$slack_file"
            return 1
        fi

        print_success "Extracted ${slack_size_mb}MB of unallocated data in ${duration}s"
        SLACK_DEVICE="$slack_file"
        return 0
    else
        print_error "Failed to extract slack space (timeout or error)"
        rm -f "$slack_file"
        return 1
    fi
}

catalog_reconstructed_files() {
    local output_dir="$1"
    local catalog_file="$SCAN_OUTPUT_DIR/carved_catalog.txt"
    local exe_count=0
    local by_type=""

    print_status "Cataloging recovered files..."

    # Count files by type
    declare -A type_counts

    while IFS= read -r -d '' file; do
        local ext="${file##*.}"
        ext=$(echo "$ext" | tr '[:upper:]' '[:lower:]')

        # Count by extension
        type_counts["$ext"]=$((${type_counts["$ext"]:-0} + 1))

        # Count executables
        case "$ext" in
            exe|dll|sys|scr|com|msi)
                exe_count=$((exe_count + 1))
                ;;
        esac
    done < <(find "$output_dir" -type f -print0 2>/dev/null)

    # Build by_type string
    for ext in "${!type_counts[@]}"; do
        by_type+="${ext}:${type_counts[$ext]},"
    done
    by_type="${by_type%,}"  # Remove trailing comma

    # Update stats
    STATS[carved_by_type]="$by_type"
    STATS[carved_executables]=$exe_count

    # Write catalog
    {
        echo "Recovered Files Catalog"
        echo "========================"
        echo "Generated: $(date)"
        echo ""
        echo "By Type:"
        for ext in "${!type_counts[@]}"; do
            printf "  %-10s %d files\n" "$ext" "${type_counts[$ext]}"
        done | sort -t: -k2 -rn
        echo ""
        echo "Executables found: $exe_count"
    } > "$catalog_file"

    print_success "Catalog written to: $catalog_file"
}

reconstruct_deleted_files() {
    local input="$1"
    local output_dir="$SCAN_OUTPUT_DIR/reconstructed"

    print_section "File Recovery (Reconstruction)"

    mkdir -p "$output_dir/foremost"

    local total_recovered=0

    # 1. Extract with foremost (primary carver)
    if command -v foremost &>/dev/null; then
        print_status "Running foremost file carver..."
        if foremost -t all -o "$output_dir/foremost" -i "$input" 2>&1 | tail -5; then
            local foremost_count=$(find "$output_dir/foremost" -type f ! -name "audit.txt" 2>/dev/null | wc -l)
            print_success "Foremost recovered $foremost_count files"
            total_recovered=$((total_recovered + foremost_count))
        fi
    else
        print_warning "foremost not available"
    fi

    # 2. Try photorec if available (better for certain formats)
    if command -v photorec &>/dev/null && echo "$CARVING_TOOLS" | grep -q "photorec"; then
        mkdir -p "$output_dir/photorec"
        print_status "Running photorec file carver..."

        # photorec requires interactive mode normally, use testdisk's photorec with /cmd for batch
        # This is a simplified approach - photorec is tricky in batch mode
        print_warning "photorec available but requires manual operation - skipping automated recovery"
    fi

    # 3. Try scalpel if available
    if command -v scalpel &>/dev/null && echo "$CARVING_TOOLS" | grep -q "scalpel"; then
        mkdir -p "$output_dir/scalpel"
        print_status "Running scalpel file carver..."
        if scalpel -o "$output_dir/scalpel" "$input" 2>&1 | tail -5; then
            local scalpel_count=$(find "$output_dir/scalpel" -type f 2>/dev/null | wc -l)
            print_success "Scalpel recovered $scalpel_count files"
            total_recovered=$((total_recovered + scalpel_count))
        fi
    fi

    # Limit number of files if needed
    if [ $total_recovered -gt "$MAX_CARVED_FILES" ]; then
        print_warning "Recovered $total_recovered files, limiting to $MAX_CARVED_FILES for analysis"
    fi

    STATS[carved_total]=$total_recovered
    STATS[slack_files_recovered]=$total_recovered

    # Calculate recovered data size
    local recovered_size=$(du -sm "$output_dir" 2>/dev/null | cut -f1)
    STATS[slack_data_recovered_mb]=${recovered_size:-0}

    # Catalog what was found
    catalog_reconstructed_files "$output_dir"

    print_success "Total files recovered: $total_recovered"
    return 0
}

extract_slack_artifacts() {
    local input="$1"
    local artifacts_dir="$SCAN_OUTPUT_DIR/slack_artifacts"

    print_section "Slack Space Artifact Extraction"

    mkdir -p "$artifacts_dir"

    # Use bulk_extractor for structured data
    if command -v bulk_extractor &>/dev/null; then
        print_status "Running bulk_extractor on slack space..."

        timeout 600 bulk_extractor -o "$artifacts_dir" "$input" 2>&1 | tail -10 || true

        # Parse and categorize findings
        if [ -d "$artifacts_dir" ]; then
            # Email addresses
            if [ -f "$artifacts_dir/email.txt" ] && [ -s "$artifacts_dir/email.txt" ]; then
                STATS[bulk_emails]=$(wc -l < "$artifacts_dir/email.txt")
                print_status "Found ${STATS[bulk_emails]} email addresses"
            fi

            # URLs
            if [ -f "$artifacts_dir/url.txt" ] && [ -s "$artifacts_dir/url.txt" ]; then
                STATS[bulk_urls]=$(wc -l < "$artifacts_dir/url.txt")
                # Extract sample URLs
                local url_samples=$(head -5 "$artifacts_dir/url.txt" | tr '\n' '|')
                STATS[strings_samples]="${url_samples%|}"
                print_status "Found ${STATS[bulk_urls]} URLs"
            fi

            # Credit card numbers
            if [ -f "$artifacts_dir/ccn.txt" ] && [ -s "$artifacts_dir/ccn.txt" ]; then
                STATS[bulk_ccn]=$(wc -l < "$artifacts_dir/ccn.txt")
                print_warning "Found ${STATS[bulk_ccn]} potential credit card numbers"
            fi
        fi
    else
        print_warning "bulk_extractor not available, using basic extraction..."

        # Fallback: use strings for basic artifact extraction
        print_status "Extracting strings from slack space..."
        strings -a "$input" > "$artifacts_dir/all_strings.txt" 2>/dev/null

        # Extract URLs
        grep -oE 'https?://[^[:space:]]+' "$artifacts_dir/all_strings.txt" > "$artifacts_dir/urls.txt" 2>/dev/null
        STATS[strings_urls]=$(wc -l < "$artifacts_dir/urls.txt" 2>/dev/null || echo 0)

        # Extract email-like patterns
        grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' "$artifacts_dir/all_strings.txt" > "$artifacts_dir/emails.txt" 2>/dev/null
        STATS[bulk_emails]=$(wc -l < "$artifacts_dir/emails.txt" 2>/dev/null || echo 0)

        print_status "Extracted ${STATS[strings_urls]} URLs and ${STATS[bulk_emails]} emails"
    fi

    return 0
}

map_slack_entropy() {
    local input="$1"

    print_section "Slack Space Entropy Mapping"

    print_status "Analyzing entropy distribution in slack space..."

    local high_entropy_regions=0
    local total_entropy=0
    local max_entropy=0
    local regions_scanned=0
    local high_offsets=""

    python3 << SLACK_ENTROPY_EOF
import math
import sys
import os

input_file = "$input"
chunk_size_mb = 10
high_entropy_threshold = 7.5
regions = []

try:
    file_size = os.path.getsize(input_file)
    num_chunks = min(50, file_size // (chunk_size_mb * 1024 * 1024) + 1)

    print(f"Scanning {num_chunks} regions of {chunk_size_mb}MB each...")
    print("-" * 60)

    suspicious = 0
    total_entropy = 0
    max_entropy = 0
    high_offsets = []

    with open(input_file, 'rb') as f:
        for i in range(num_chunks):
            offset_mb = i * chunk_size_mb
            f.seek(offset_mb * 1024 * 1024)
            data = f.read(chunk_size_mb * 1024 * 1024)

            if len(data) == 0:
                continue

            freq = [0] * 256
            for b in data:
                freq[b] += 1

            entropy = 0
            for fr in freq:
                if fr > 0:
                    p = fr / len(data)
                    entropy -= p * math.log2(p)

            total_entropy += entropy
            if entropy > max_entropy:
                max_entropy = entropy

            status = ""
            if entropy > high_entropy_threshold:
                status = "HIGH ENTROPY"
                suspicious += 1
                high_offsets.append(f"0x{offset_mb * 1024 * 1024:X}")
                print(f"Region {offset_mb:5d}MB: Entropy={entropy:.2f}/8.0 - {status}")
            elif entropy > 6.0:
                status = "Data present"

    print("-" * 60)

    avg_entropy = total_entropy / num_chunks if num_chunks > 0 else 0

    print(f"STATS:regions={num_chunks}")
    print(f"STATS:high={suspicious}")
    print(f"STATS:avg={avg_entropy:.2f}")
    print(f"STATS:max={max_entropy:.2f}")
    print(f"STATS:offsets={','.join(high_offsets)}")

    if suspicious > 0:
        print(f"Found {suspicious} high-entropy regions (possible encryption/packed data)")
        sys.exit(1)
    else:
        print("No suspicious high-entropy regions detected")
        sys.exit(0)

except Exception as e:
    print(f"Error: {e}")
    sys.exit(2)
SLACK_ENTROPY_EOF

    local exit_code=$?

    # Parse output for stats (this is a simplified approach)
    if [ $exit_code -eq 1 ]; then
        STATS[entropy_high_count]=1
    else
        STATS[entropy_high_count]=0
    fi

    return 0
}

scan_slack_space() {
    print_section "Slack Space Analysis"

    if [ "$SCAN_MODE" != "slack" ]; then
        print_status "Scan mode is 'full', skipping dedicated slack analysis..."
        return 0
    fi

    # 1. Extract unallocated data
    if ! extract_slack_space; then
        print_error "Failed to extract slack space"
        return 1
    fi

    if [ -z "$SLACK_DEVICE" ] || [ ! -f "$SLACK_DEVICE" ]; then
        print_error "No slack space data to analyze"
        return 1
    fi

    # 2. Attempt file reconstruction with multiple tools
    reconstruct_deleted_files "$SLACK_DEVICE"

    # 3. Deep pattern extraction
    extract_slack_artifacts "$SLACK_DEVICE"

    # 4. Entropy mapping of slack regions
    map_slack_entropy "$SLACK_DEVICE"

    # 5. Scan reconstructed files for malware
    local reconstructed_dir="$SCAN_OUTPUT_DIR/reconstructed"
    if [ -d "$reconstructed_dir" ]; then
        print_section "Scanning Recovered Files"

        # ClamAV scan of recovered files
        if command -v clamscan &>/dev/null; then
            print_status "Scanning recovered files with ClamAV..."
            local clam_result=$(clamscan --database="$CLAMDB_DIR" -r "$reconstructed_dir" 2>&1) || true
            local infected=$(echo "$clam_result" | grep "Infected files:" | awk '{print $3}')

            if [ -n "$infected" ] && [ "$infected" != "0" ]; then
                print_warning "Found $infected infected files in recovered data!"
                RESULTS["carved_malware"]=$infected
                STATS[clamav_infected]=$infected
            else
                print_success "Recovered files: CLEAN"
                RESULTS["carved_malware"]=0
            fi
        fi

        # YARA scan of recovered executables
        if [ "${STATS[carved_executables]}" -gt 0 ]; then
            print_status "Scanning recovered executables with YARA..."
            # This would call the existing YARA scanning logic
        fi
    fi

    print_success "Slack space analysis complete"
    return 0
}

# ==========================================
# DEEP SCAN FUNCTIONS
# ==========================================

scan_entropy() {
    print_section "Entropy Analysis"

    print_status "Analyzing disk entropy by region (detecting encryption/packing)..."

    local high_entropy_regions=0
    local device_path="$DEVICE"

    python3 << ENTROPY_EOF
import subprocess
import math
import sys
import os

chunk_size_mb = 50
num_chunks = 20
device = os.environ.get('SCAN_DEVICE', '$device_path')

print(f"Scanning {num_chunks} regions of {chunk_size_mb}MB each...")
print("-" * 70)

suspicious = 0
for i in range(num_chunks):
    offset = i * chunk_size_mb
    try:
        proc = subprocess.Popen(
            ['dd', 'if=' + device, 'bs=1M', f'count={chunk_size_mb}', f'skip={offset}'],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        )
        data, _ = proc.communicate(timeout=60)
    except Exception as e:
        print(f"Error reading region {offset}MB: {e}")
        continue

    if len(data) == 0:
        continue

    freq = [0]*256
    for b in data:
        freq[b] += 1

    entropy = 0
    for f in freq:
        if f > 0:
            p = f / len(data)
            entropy -= p * math.log2(p)

    zero_pct = (freq[0] / len(data)) * 100

    status = ""
    if entropy > 7.5:
        status = "HIGH ENTROPY"
        suspicious += 1
    elif entropy < 0.5:
        status = "Empty"
    elif entropy > 6.0:
        status = "Data present"
    else:
        status = "Low entropy"

    if entropy > 7.5 or (entropy > 5.0 and entropy < 7.5):
        print(f"Region {offset:5d}MB: Entropy={entropy:.2f}/8.0, Zeros={zero_pct:5.1f}% - {status}")

print("-" * 70)
if suspicious > 0:
    print(f"Found {suspicious} high-entropy regions (possible encryption/compression)")
    sys.exit(1)
else:
    print("No suspicious high-entropy regions detected")
    sys.exit(0)
ENTROPY_EOF

    if [ $? -eq 1 ]; then
        RESULTS["entropy"]=1
    else
        RESULTS["entropy"]=0
    fi

    return 0
}

scan_file_carving() {
    print_section "File Carving (Deleted File Recovery)"

    local carve_dir="$SCAN_OUTPUT_DIR/carved"

    # Check disk space before carving
    local estimated_space=$((DEVICE_SIZE_MB / 10))  # Rough estimate
    if ! check_disk_space $estimated_space "/tmp"; then
        print_warning "Skipping file carving due to insufficient disk space"
        RESULTS["carved_files"]=0
        RESULTS["carved_malware"]=0
        return 0
    fi

    mkdir -p "$carve_dir"

    print_status "Running foremost to recover deleted files..."

    foremost -t all -i "$DEVICE" -o "$carve_dir" 2>&1 | tail -10 || true

    # Check results
    local carved_count=$(find "$carve_dir" -type f ! -name "audit.txt" 2>/dev/null | wc -l)

    if [ "$carved_count" -gt 0 ]; then
        print_warning "Recovered $carved_count deleted files"

        # Show file types found
        echo ""
        print_status "Recovered file types:"
        find "$carve_dir" -type f ! -name "audit.txt" -exec file {} \; 2>/dev/null | \
            cut -d: -f2 | sort | uniq -c | sort -rn | head -10

        # Scan recovered files with ClamAV
        echo ""
        print_status "Scanning recovered files with ClamAV..."
        clam_result=$(clamscan --database="$CLAMDB_DIR" -r "$carve_dir" 2>&1) || true
        infected=$(echo "$clam_result" | grep "Infected files:" | awk '{print $3}')

        if [ "$infected" != "0" ] && [ -n "$infected" ]; then
            print_error "MALWARE FOUND in recovered files!"
            echo "$clam_result" | grep -E "FOUND|Infected"
            RESULTS["carved_malware"]=$infected
        else
            print_success "Recovered files: CLEAN"
            RESULTS["carved_malware"]=0
        fi

        RESULTS["carved_files"]=$carved_count
    else
        print_success "No deleted files recovered"
        RESULTS["carved_files"]=0
        RESULTS["carved_malware"]=0
    fi

    return 0
}

scan_bulk_extractor() {
    print_section "Bulk Extractor Analysis"

    if ! command -v bulk_extractor &> /dev/null; then
        print_warning "bulk_extractor not available, skipping..."
        return 0
    fi

    local bulk_dir="$SCAN_OUTPUT_DIR/bulk_output"
    mkdir -p "$bulk_dir"

    print_status "Running bulk_extractor (this may take a while)..."

    # Run with timeout
    timeout 600 bulk_extractor -o "$bulk_dir" "$DEVICE" 2>&1 | tail -20 || true

    # Analyze results
    if [ -d "$bulk_dir" ]; then
        echo ""
        print_status "Bulk extractor findings:"

        # Check for email addresses
        if [ -f "$bulk_dir/email.txt" ] && [ -s "$bulk_dir/email.txt" ]; then
            local email_count=$(wc -l < "$bulk_dir/email.txt")
            print_warning "Found $email_count email addresses"
        fi

        # Check for URLs
        if [ -f "$bulk_dir/url.txt" ] && [ -s "$bulk_dir/url.txt" ]; then
            local url_count=$(wc -l < "$bulk_dir/url.txt")
            print_warning "Found $url_count URLs"
            echo "Sample URLs:"
            head -5 "$bulk_dir/url.txt" | sed 's/^/  /'
        fi

        # Check for credit card numbers
        if [ -f "$bulk_dir/ccn.txt" ] && [ -s "$bulk_dir/ccn.txt" ]; then
            local ccn_count=$(wc -l < "$bulk_dir/ccn.txt")
            print_error "Found $ccn_count potential credit card numbers!"
        fi

        # Check for Windows artifacts
        if [ -f "$bulk_dir/winpe.txt" ] && [ -s "$bulk_dir/winpe.txt" ]; then
            local pe_count=$(wc -l < "$bulk_dir/winpe.txt")
            print_warning "Found $pe_count Windows PE artifacts"
        fi

        # Check for JSON/config data
        if [ -f "$bulk_dir/json.txt" ] && [ -s "$bulk_dir/json.txt" ]; then
            local json_count=$(wc -l < "$bulk_dir/json.txt")
            print_warning "Found $json_count JSON fragments"
        fi

        RESULTS["bulk_extractor"]=1
    else
        print_success "No significant artifacts found"
        RESULTS["bulk_extractor"]=0
    fi

    return 0
}

scan_executables() {
    print_section "Executable Detection"

    print_status "Scanning for PE (Windows) and ELF (Linux) executables..."

    local pe_found=0
    local elf_found=0

    # Scan for PE headers (MZ)
    pe_offsets=$(dd if="$DEVICE" bs=1M 2>/dev/null | grep -boa "MZ" 2>/dev/null | head -20) || true
    if [ -n "$pe_offsets" ]; then
        pe_found=$(echo "$pe_offsets" | wc -l)
        print_warning "Found $pe_found potential PE (Windows) executables"
    fi

    # Scan for ELF headers
    elf_offsets=$(dd if="$DEVICE" bs=1M 2>/dev/null | grep -boa $'\x7fELF' 2>/dev/null | head -20) || true
    if [ -n "$elf_offsets" ]; then
        elf_found=$(echo "$elf_offsets" | wc -l)
        print_warning "Found $elf_found potential ELF (Linux) executables"
    fi

    if [ $pe_found -eq 0 ] && [ $elf_found -eq 0 ]; then
        print_success "No executables detected in raw disk"
    fi

    RESULTS["pe_executables"]=$pe_found
    RESULTS["elf_executables"]=$elf_found
    return 0
}

scan_hashes() {
    print_section "Hash Analysis"

    if ! command -v md5deep &> /dev/null; then
        print_warning "md5deep not available, skipping..."
        return 0
    fi

    if [ -n "$MOUNT_POINT" ] && [ -d "$MOUNT_POINT" ]; then
        print_status "Generating file hashes for mounted filesystem..."

        local hash_file="$SCAN_OUTPUT_DIR/file_hashes.txt"
        md5deep -r "$MOUNT_POINT" > "$hash_file" 2>/dev/null || true

        local hash_count=$(wc -l < "$hash_file" 2>/dev/null || echo 0)
        print_success "Generated $hash_count file hashes"
        print_status "Hashes saved to: $hash_file"

        RESULTS["hashes"]=$hash_count
    else
        print_warning "No mounted filesystem, skipping hash generation"
        RESULTS["hashes"]=0
    fi

    return 0
}

scan_boot_sector() {
    print_section "Boot Sector Analysis"

    print_status "Analyzing MBR/boot sector..."

    local boot_file="$SCAN_OUTPUT_DIR/boot_sector.bin"
    dd if="$DEVICE" of="$boot_file" bs=512 count=1 2>/dev/null

    # Check for known boot sector malware signatures
    local boot_hex=$(xxd -p "$boot_file" | tr -d '\n')

    # Check MBR signature
    local mbr_sig="${boot_hex: -4}"
    if [ "$mbr_sig" = "55aa" ]; then
        print_success "Valid MBR signature (55AA)"
    else
        print_warning "Non-standard MBR signature: $mbr_sig"
    fi

    # Check for suspicious patterns
    if echo "$boot_hex" | grep -qi "4d5a"; then
        print_warning "PE header found in boot sector - possible bootkit!"
        RESULTS["boot_sector"]=1
    else
        print_success "Boot sector appears normal"
        RESULTS["boot_sector"]=0
    fi

    # Show boot sector info
    file "$boot_file" 2>/dev/null
    return 0
}

# ==========================================
# REPORT GENERATION
# ==========================================

generate_report() {
    print_section "Scan Report"

    local report_file="${OUTPUT_FILE:-$SCAN_OUTPUT_DIR/scan_report_$(date +%Y%m%d_%H%M%S).txt}"

    {
        echo "═══════════════════════════════════════════════════════════════"
        echo "              TSURUGI LINUX MALWARE SCAN REPORT"
        echo "              Generated: $(date)"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "DEVICE INFORMATION"
        echo "──────────────────"
        echo "Device:     $DEVICE"
        echo "Size:       ${DEVICE_SIZE_GB} GB"
        echo "Filesystem: $FS_TYPE"
        echo "Scan Type:  $([ "$DEEP_SCAN" = true ] && echo "DEEP SCAN" || echo "STANDARD")"
        echo "Parallel:   $([ "$PARALLEL_MODE" = true ] && echo "YES" || echo "NO")"
        echo ""
        echo "SCAN RESULTS"
        echo "────────────"
        echo ""
        echo "Basic Scans:"
        echo "  ClamAV:              ${RESULTS[clamav]:-N/A} infected"
        echo "  YARA Windows:        ${RESULTS[yara_Windows]:-N/A} matches"
        echo "  YARA Linux:          ${RESULTS[yara_Linux]:-N/A} matches"
        echo "  YARA Android:        ${RESULTS[yara_Android]:-N/A} matches"
        echo "  YARA Documents:      ${RESULTS[yara_Documents]:-N/A} matches"
        echo "  Binwalk:             ${RESULTS[binwalk]:-N/A} findings"
        echo "  String Analysis:     ${RESULTS[strings]:-N/A} patterns"

        if [ "$QUICK_SCAN" = true ]; then
            echo ""
            echo "Quick Scan:"
            echo "  Suspicious regions:  ${RESULTS[quick_scan]:-0}"
        fi

        if [ "$DO_VIRUSTOTAL" = true ]; then
            echo ""
            echo "VirusTotal:"
            echo "  Malicious files:     ${RESULTS[virustotal]:-N/A}"
        fi

        if [ "$DEEP_SCAN" = true ]; then
            echo ""
            echo "Deep Scan Results:"
            echo "  Entropy Analysis:    $([ "${RESULTS[entropy]}" = "1" ] && echo "SUSPICIOUS" || echo "Normal")"
            echo "  Carved Files:        ${RESULTS[carved_files]:-0} recovered"
            echo "  Carved Malware:      ${RESULTS[carved_malware]:-0} infected"
            echo "  PE Executables:      ${RESULTS[pe_executables]:-0} found"
            echo "  ELF Executables:     ${RESULTS[elf_executables]:-0} found"
            echo "  Boot Sector:         $([ "${RESULTS[boot_sector]}" = "1" ] && echo "SUSPICIOUS" || echo "Normal")"
            echo "  Bulk Extractor:      $([ "${RESULTS[bulk_extractor]}" = "1" ] && echo "Artifacts found" || echo "Clean")"
        fi

        if [ "$DO_ROOTKIT" = true ]; then
            echo ""
            echo "Rootkit Detection:"
            echo "  Findings:            ${RESULTS[rootkit]:-0}"
        fi

        if [ "$DO_TIMELINE" = true ]; then
            echo ""
            echo "Timeline:"
            echo "  Generated:           $([ "${RESULTS[timeline]}" = "1" ] && echo "YES" || echo "NO")"
        fi

        echo ""
        echo "SCAN STATUS"
        echo "───────────"
        for scan in "${!SCAN_STATUS[@]}"; do
            echo "  $scan: ${SCAN_STATUS[$scan]}"
        done

        echo ""
        echo "═══════════════════════════════════════════════════════════════"

        # Calculate overall status
        local total_findings=0
        for key in "${!RESULTS[@]}"; do
            local val="${RESULTS[$key]}"
            if [[ "$val" =~ ^[0-9]+$ ]]; then
                total_findings=$((total_findings + val))
            fi
        done

        echo ""
        echo "OVERALL STATUS"
        echo "──────────────"
        if [ $total_findings -eq 0 ]; then
            echo "  STATUS: CLEAN"
            echo "  No malware or suspicious activity detected."
        else
            echo "  STATUS: SUSPICIOUS"
            echo "  Total findings: $total_findings"
            echo "  Manual review recommended."
        fi

        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "Scan output directory: $SCAN_OUTPUT_DIR"

    } | tee "$report_file"

    echo ""
    print_success "Report saved to: $report_file"

    # Also generate statistics report if slack mode or deep scan
    if [ "$SCAN_MODE" = "slack" ] || [ "$DEEP_SCAN" = true ]; then
        generate_statistics_report
    fi
}

generate_guidance() {
    # Generate actionable recommendations based on findings

    # Reset arrays
    GUIDANCE_RECOMMENDATIONS=()
    GUIDANCE_NO_ACTION=()

    # YARA matches - always noteworthy
    if [ "${STATS[yara_matches]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("YARA|High|${STATS[yara_matches]} rule(s) matched specific threat patterns|Extract and analyze data at matched offsets|yara_matches/")
    fi

    # ClamAV detections - critical
    if [ "${STATS[clamav_infected]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("CLAMAV|Critical|${STATS[clamav_infected]} known malware signature(s) detected|Isolate and analyze infected files immediately|clamav_results/")
    else
        GUIDANCE_NO_ACTION+=("ClamAV: No signature matches")
    fi

    # Recovered executables from slack
    if [ "${STATS[carved_executables]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("EXEC|Medium|${STATS[carved_executables]} executable(s) found in unallocated space|Submit to sandbox analysis or VirusTotal|reconstructed/")
    fi

    # High entropy regions
    if [ "${STATS[entropy_high_count]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("ENTROPY|Low-Medium|${STATS[entropy_high_count]} high-entropy region(s) detected|Extract regions and analyze file signatures|entropy_analysis/")
    fi

    # URLs found
    if [ "${STATS[bulk_urls]:-0}" -gt 0 ] || [ "${STATS[strings_urls]:-0}" -gt 0 ]; then
        local url_count=$((${STATS[bulk_urls]:-0} + ${STATS[strings_urls]:-0}))
        GUIDANCE_RECOMMENDATIONS+=("URLS|Low|${url_count} URL(s) found in slack space|Review for known malicious domains|slack_artifacts/urls.txt")
    fi

    # Credit card numbers - sensitive data
    if [ "${STATS[bulk_ccn]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("PII|Medium|${STATS[bulk_ccn]} potential credit card number(s) found|Review for data breach implications|slack_artifacts/ccn.txt")
    fi

    # Boot sector issues
    if [ "${RESULTS[boot_sector]:-0}" = "1" ]; then
        GUIDANCE_RECOMMENDATIONS+=("BOOTSEC|High|Suspicious patterns in boot sector|Analyze for bootkit/rootkit infection|boot_sector.bin")
    else
        if [ "$SCAN_MODE" = "full" ]; then
            GUIDANCE_NO_ACTION+=("Boot sector: Normal")
        else
            GUIDANCE_NO_ACTION+=("Boot sector: Not analyzed (slack mode)")
        fi
    fi

    # Recovered files
    if [ "${STATS[carved_total]:-0}" -gt 0 ]; then
        local non_exec=$((${STATS[carved_total]:-0} - ${STATS[carved_executables]:-0}))
        if [ $non_exec -gt 0 ]; then
            GUIDANCE_NO_ACTION+=("Recovered files: $non_exec non-executable files (images, docs, etc.)")
        fi
    fi
}

generate_statistics_report() {
    print_section "Statistics Report"

    local stats_file="$SCAN_OUTPUT_DIR/statistics_report_$(date +%Y%m%d_%H%M%S).txt"

    # Calculate scan duration
    local scan_end_time=$(date +%s)
    local scan_duration=$((scan_end_time - ${SCAN_START_TIME:-$scan_end_time}))
    local duration_min=$((scan_duration / 60))
    local duration_sec=$((scan_duration % 60))

    # Generate guidance first
    generate_guidance

    {
        echo "╔══════════════════════════════════════════════════════════════╗"
        echo "║                    SCAN STATISTICS                           ║"
        echo "╠══════════════════════════════════════════════════════════════╣"
        echo ""
        echo "DEVICE INFORMATION"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-14s %s\n" "Input:" "${ORIGINAL_INPUT:-$DEVICE}"

        local input_type_display="Block Device"
        case "$INPUT_TYPE" in
            ewf) input_type_display="EWF Forensic Image" ;;
            raw_image) input_type_display="Raw Disk Image" ;;
        esac
        printf "  %-14s %s\n" "Type:" "$input_type_display"
        printf "  %-14s %s GB\n" "Size:" "${DEVICE_SIZE_GB:-N/A}"
        printf "  %-14s %s\n" "Scan Mode:" "$([ "$SCAN_MODE" = "slack" ] && echo "Slack Space Only" || echo "Full Drive")"

        if [ "$SCAN_MODE" = "slack" ]; then
            local slack_pct=0
            if [ "${DEVICE_SIZE_MB:-0}" -gt 0 ]; then
                slack_pct=$(echo "scale=1; ${STATS[slack_size_mb]:-0} * 100 / ${DEVICE_SIZE_MB}" | bc 2>/dev/null || echo "0")
            fi
            printf "  %-14s %s MB (%s%% of total)\n" "Slack Size:" "${STATS[slack_size_mb]:-0}" "$slack_pct"
        fi
        printf "  %-14s %d minutes %d seconds\n" "Duration:" "$duration_min" "$duration_sec"
        echo ""

        echo "ANTIVIRUS SCAN (ClamAV)"
        echo "──────────────────────────────────────────────────────────────"
        if [ "$SCAN_MODE" = "slack" ]; then
            printf "  %-14s %s MB\n" "Data Scanned:" "${STATS[slack_data_recovered_mb]:-0}"
        else
            printf "  %-14s %s GB\n" "Data Scanned:" "${DEVICE_SIZE_GB:-N/A}"
        fi
        printf "  %-14s %s\n" "Signatures:" "${STATS[clamav_signatures]:-Standard ClamAV DB}"
        printf "  %-14s %s\n" "Detections:" "${STATS[clamav_infected]:-0}"
        echo ""

        echo "YARA RULE MATCHING"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-14s %s\n" "Rules Checked:" "${STATS[yara_rules_checked]:-N/A}"
        printf "  %-14s %s\n" "Matches:" "${STATS[yara_matches]:-0}"

        if [ "${STATS[yara_matches]:-0}" -gt 0 ] && [ -n "${STATS[yara_match_details]}" ]; then
            echo ""
            echo "  Match Details:"
            echo "${STATS[yara_match_details]}" | while IFS='|' read -r rule offset match; do
                printf "    * Rule: %s\n" "$rule"
                printf "      Offset: %s, Match: %s\n" "$offset" "$match"
            done
        fi
        echo ""

        echo "STRING ANALYSIS"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-14s %s\n" "Total Strings:" "${STATS[strings_total]:-N/A}"
        printf "  %-14s %s\n" "URLs Found:" "${STATS[strings_urls]:-${STATS[bulk_urls]:-0}}"
        printf "  %-14s %s\n" "Exec Refs:" "${STATS[strings_executables]:-0}"
        printf "  %-14s %s\n" "Cred Refs:" "${STATS[strings_credentials]:-0}"

        if [ -n "${STATS[strings_samples]}" ]; then
            echo ""
            echo "  Sample URLs (first 5):"
            echo "${STATS[strings_samples]}" | tr '|' '\n' | head -5 | while read -r url; do
                printf "    * %s\n" "$url"
            done
        fi
        echo ""

        echo "ENTROPY ANALYSIS"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-18s %s\n" "Regions Analyzed:" "${STATS[entropy_regions_scanned]:-N/A}"
        printf "  %-18s %s / 8.0\n" "Average Entropy:" "${STATS[entropy_avg]:-N/A}"
        printf "  %-18s %s / 8.0\n" "Max Entropy:" "${STATS[entropy_max]:-N/A}"
        printf "  %-18s %s regions\n" "High Entropy (>7.5):" "${STATS[entropy_high_count]:-0}"

        if [ "${STATS[entropy_high_count]:-0}" -gt 0 ] && [ -n "${STATS[entropy_high_offsets]}" ]; then
            echo ""
            echo "  High Entropy Locations:"
            echo "${STATS[entropy_high_offsets]}" | tr ',' '\n' | while read -r offset; do
                printf "    * %s\n" "$offset"
                echo "      -> May indicate: encrypted data, compressed archive"
            done
        fi
        echo ""

        if [ "$SCAN_MODE" = "slack" ] || [ "$DEEP_SCAN" = true ]; then
            echo "FILE RECOVERY (Slack Space)"
            echo "──────────────────────────────────────────────────────────────"
            printf "  %-18s %s\n" "Files Recovered:" "${STATS[slack_files_recovered]:-${STATS[carved_total]:-0}}"
            printf "  %-18s %s MB\n" "Data Recovered:" "${STATS[slack_data_recovered_mb]:-0}"

            if [ -n "${STATS[carved_by_type]}" ]; then
                echo ""
                echo "  By Type:"
                echo "${STATS[carved_by_type]}" | tr ',' '\n' | while IFS=':' read -r ext count; do
                    printf "    * %-12s %s files\n" "$ext" "$count"
                done
            fi
            echo ""
        fi

        echo "EXECUTABLE HEADERS FOUND"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-18s %s\n" "PE Headers (Win):" "${STATS[pe_headers]:-${RESULTS[pe_executables]:-0}}"
        printf "  %-18s %s\n" "ELF Headers (Linux):" "${STATS[elf_headers]:-${RESULTS[elf_executables]:-0}}"

        if [ -n "${STATS[pe_offsets]}" ]; then
            echo ""
            echo "  PE Locations (first 5):"
            printf "    %s\n" "${STATS[pe_offsets]}"
        fi
        echo ""

        echo "╠══════════════════════════════════════════════════════════════╣"
        echo "║                    ANALYSIS GUIDANCE                          ║"
        echo "╠══════════════════════════════════════════════════════════════╣"
        echo ""

        if [ ${#GUIDANCE_RECOMMENDATIONS[@]} -gt 0 ]; then
            echo "RECOMMENDED INSPECTIONS:"
            echo "──────────────────────────────────────────────────────────────"
            echo ""

            local rec_num=1
            for rec in "${GUIDANCE_RECOMMENDATIONS[@]}"; do
                IFS='|' read -r category priority reason action location <<< "$rec"
                echo "$rec_num. $category ($priority priority)"
                echo "   Reason: $reason"
                echo "   Action: $action"
                echo "   Files:  \$OUTPUT_DIR/$location"
                echo ""
                rec_num=$((rec_num + 1))
            done
        else
            echo "RECOMMENDED INSPECTIONS:"
            echo "──────────────────────────────────────────────────────────────"
            echo "  No high-priority items requiring immediate attention."
            echo ""
        fi

        if [ ${#GUIDANCE_NO_ACTION[@]} -gt 0 ]; then
            echo "NO ACTION REQUIRED:"
            echo "──────────────────────────────────────────────────────────────"
            for item in "${GUIDANCE_NO_ACTION[@]}"; do
                echo "  * $item"
            done
            echo ""
        fi

        echo "╚══════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Output directory: $SCAN_OUTPUT_DIR"

    } | tee "$stats_file"

    echo ""
    print_success "Statistics report saved to: $stats_file"
}

generate_html_report() {
    local html_file="$SCAN_OUTPUT_DIR/scan_report_$(date +%Y%m%d_%H%M%S).html"

    print_status "Generating HTML report..."

    # Calculate total findings
    local total_findings=0
    for key in "${!RESULTS[@]}"; do
        local val="${RESULTS[$key]}"
        if [[ "$val" =~ ^[0-9]+$ ]]; then
            total_findings=$((total_findings + val))
        fi
    done

    # Build findings summary
    local findings_summary=""
    local clamav_count="${RESULTS[clamav]:-0}"
    local yara_count=$((${RESULTS[yara_Windows]:-0} + ${RESULTS[yara_Linux]:-0}))
    [ "$clamav_count" != "0" ] && [ "$clamav_count" != "N/A" ] && findings_summary+="$clamav_count AV detection(s), "
    [ "$yara_count" -gt 0 ] && findings_summary+="$yara_count YARA match(es), "
    [ "${STATS[carved_executables]:-0}" -gt 0 ] && findings_summary+="${STATS[carved_executables]} recovered exe(s), "
    findings_summary="${findings_summary%, }"
    [ -z "$findings_summary" ] && findings_summary="No notable findings"

    cat > "$html_file" << HTMLEOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DMS Scan Statistics - $(date +%Y-%m-%d)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 900px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 30px; }
        h1 { color: #333; border-bottom: 3px solid #007bff; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        .summary-banner { padding: 20px; border-radius: 8px; text-align: center; margin: 20px 0; background: #e7f3ff; border: 1px solid #b8daff; }
        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background: #f8f9fa; font-weight: 600; }
        .info-box { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #007bff; }
        .guidance-box { background: #fff3cd; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #ffc107; }
        .timestamp { color: #666; font-size: 0.9em; }
        .stat-value { font-weight: bold; color: #333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>DMS - Drive Malware Scan Statistics</h1>
        <p class="timestamp">Generated: $(date)</p>

        <div class="summary-banner">
            <h2 style="margin:0;">Scan Statistics Summary</h2>
            <p style="margin:10px 0 0 0;"><strong>Findings:</strong> $findings_summary</p>
            <p><strong>Items to review:</strong> $total_findings</p>
        </div>

        <h2>Device Information</h2>
        <div class="info-box">
            <strong>Device:</strong> $DEVICE<br>
            <strong>Size:</strong> ${DEVICE_SIZE_GB} GB<br>
            <strong>Filesystem:</strong> $FS_TYPE<br>
            <strong>Scan Mode:</strong> $([ "$SCAN_MODE" = "slack" ] && echo "Slack Space Only" || echo "Full Drive")<br>
            <strong>Scan Type:</strong> $([ "$DEEP_SCAN" = true ] && echo "Deep Scan" || echo "Standard")
        </div>

        <h2>Scan Statistics</h2>
        <table>
            <tr><th>Scanner</th><th>Count</th><th>Description</th></tr>
            <tr><td>ClamAV</td><td class="stat-value">${RESULTS[clamav]:-0}</td><td>Signature detections</td></tr>
            <tr><td>YARA Windows</td><td class="stat-value">${RESULTS[yara_Windows]:-0}</td><td>Rule matches</td></tr>
            <tr><td>YARA Linux</td><td class="stat-value">${RESULTS[yara_Linux]:-0}</td><td>Rule matches</td></tr>
            <tr><td>YARA Android</td><td class="stat-value">${RESULTS[yara_Android]:-0}</td><td>Rule matches</td></tr>
            <tr><td>Binwalk</td><td class="stat-value">${RESULTS[binwalk]:-0}</td><td>Embedded files found</td></tr>
            <tr><td>String Patterns</td><td class="stat-value">${RESULTS[strings]:-0}</td><td>Notable strings</td></tr>
HTMLEOF

    if [ "$SCAN_MODE" = "slack" ]; then
        cat >> "$html_file" << HTMLEOF
            <tr><td>Slack Space</td><td class="stat-value">${STATS[slack_size_mb]:-0} MB</td><td>Unallocated data extracted</td></tr>
            <tr><td>Files Recovered</td><td class="stat-value">${STATS[slack_files_recovered]:-0}</td><td>Carved from slack space</td></tr>
            <tr><td>Executables Recovered</td><td class="stat-value">${STATS[carved_executables]:-0}</td><td>EXE/DLL files</td></tr>
HTMLEOF
    fi

    if [ "$DEEP_SCAN" = true ] || [ "$SCAN_MODE" = "slack" ]; then
        cat >> "$html_file" << HTMLEOF
            <tr><td>High Entropy Regions</td><td class="stat-value">${STATS[entropy_high_count]:-0}</td><td>Possible encrypted/packed data</td></tr>
            <tr><td>Carved Files</td><td class="stat-value">${RESULTS[carved_files]:-0}</td><td>Files recovered</td></tr>
HTMLEOF
    fi

    if [ "$SCAN_MODE" = "full" ] && [ "$DEEP_SCAN" = true ]; then
        cat >> "$html_file" << HTMLEOF
            <tr><td>Boot Sector</td><td class="stat-value">$([ "${RESULTS[boot_sector]:-0}" = "0" ] && echo "Normal" || echo "Review needed")</td><td>MBR analysis</td></tr>
HTMLEOF
    fi

    cat >> "$html_file" << HTMLEOF
        </table>

        <h2>Output Location</h2>
        <div class="info-box">
            <strong>Scan output directory:</strong> $SCAN_OUTPUT_DIR<br>
            <strong>Statistics report:</strong> statistics_report_*.txt
        </div>

        <p class="timestamp" style="text-align:center; margin-top:30px;">
            DMS - Drive Malware Scanner v2.1
        </p>
    </div>
</body>
</html>
HTMLEOF

    print_success "HTML report saved to: $html_file"
}

generate_json_report() {
    local json_file="$SCAN_OUTPUT_DIR/scan_report_$(date +%Y%m%d_%H%M%S).json"

    print_status "Generating JSON report..."

    # Calculate total findings
    local total_findings=0
    for key in "${!RESULTS[@]}"; do
        local val="${RESULTS[$key]}"
        if [[ "$val" =~ ^[0-9]+$ ]]; then
            total_findings=$((total_findings + val))
        fi
    done

    cat > "$json_file" << JSONEOF
{
    "report": {
        "version": "2.1",
        "generated": "$(date -Iseconds)",
        "tool": "DMS - Drive Malware Scanner"
    },
    "device": {
        "path": "$DEVICE",
        "size_gb": ${DEVICE_SIZE_GB:-0},
        "filesystem": "$FS_TYPE"
    },
    "scan_config": {
        "mode": "$SCAN_MODE",
        "type": "$([ "$DEEP_SCAN" = true ] && echo "deep" || echo "standard")",
        "parallel": $([ "$PARALLEL_MODE" = true ] && echo "true" || echo "false"),
        "quick": $([ "$QUICK_SCAN" = true ] && echo "true" || echo "false"),
        "chunk_size_mb": $CHUNK_SIZE
    },
    "results": {
        "clamav": ${RESULTS[clamav]:-0},
        "yara_windows": ${RESULTS[yara_Windows]:-0},
        "yara_linux": ${RESULTS[yara_Linux]:-0},
        "yara_android": ${RESULTS[yara_Android]:-0},
        "yara_documents": ${RESULTS[yara_Documents]:-0},
        "binwalk": ${RESULTS[binwalk]:-0},
        "strings": ${RESULTS[strings]:-0},
        "entropy": ${RESULTS[entropy]:-0},
        "carved_files": ${RESULTS[carved_files]:-0},
        "carved_malware": ${RESULTS[carved_malware]:-0},
        "pe_executables": ${RESULTS[pe_executables]:-0},
        "elf_executables": ${RESULTS[elf_executables]:-0},
        "boot_sector": ${RESULTS[boot_sector]:-0},
        "virustotal": ${RESULTS[virustotal]:-0},
        "rootkit": ${RESULTS[rootkit]:-0}
    },
    "statistics": {
        "clamav_scanned": ${STATS[clamav_scanned]:-0},
        "clamav_infected": ${STATS[clamav_infected]:-0},
        "yara_rules_checked": ${STATS[yara_rules_checked]:-0},
        "yara_matches": ${STATS[yara_matches]:-0},
        "strings_total": ${STATS[strings_total]:-0},
        "strings_urls": ${STATS[strings_urls]:-0},
        "entropy_regions_scanned": ${STATS[entropy_regions_scanned]:-0},
        "entropy_high_count": ${STATS[entropy_high_count]:-0},
        "carved_total": ${STATS[carved_total]:-0},
        "carved_executables": ${STATS[carved_executables]:-0},
        "slack_size_mb": ${STATS[slack_size_mb]:-0},
        "slack_files_recovered": ${STATS[slack_files_recovered]:-0},
        "slack_data_recovered_mb": ${STATS[slack_data_recovered_mb]:-0},
        "pe_headers": ${STATS[pe_headers]:-0},
        "elf_headers": ${STATS[elf_headers]:-0},
        "bulk_emails": ${STATS[bulk_emails]:-0},
        "bulk_urls": ${STATS[bulk_urls]:-0}
    },
    "summary": {
        "total_findings": $total_findings,
        "items_to_review": $total_findings
    },
    "output_directory": "$SCAN_OUTPUT_DIR"
}
JSONEOF

    print_success "JSON report saved to: $json_file"
}

# ==========================================
# INTERACTIVE MODE - Full TUI with Navigation
# ==========================================

# TUI State variables
declare -g TUI_SELECTED=0
declare -g TUI_INPUT_PATH=""
declare -g TUI_SCAN_TYPE="standard"  # quick, standard, deep
declare -g TUI_SCAN_SCOPE="full"     # full, slack
declare -g TUI_OPT_MOUNT=false
declare -g TUI_OPT_UPDATE=false
declare -g TUI_OPT_PARALLEL=false
declare -g TUI_OPT_AUTOCHUNK=false
declare -g TUI_OPT_VIRUSTOTAL=false
declare -g TUI_OPT_ROOTKIT=false
declare -g TUI_OPT_TIMELINE=false
declare -g TUI_OPT_HTML=false
declare -g TUI_OPT_JSON=false
declare -g TUI_OPT_VERIFY_HASH=false
declare -g TUI_OPT_KEEP_OUTPUT=false
declare -g TUI_DETECTED_TYPE=""

# Menu items count (added 2 for scan scope: full, slack)
TUI_MENU_ITEMS=17

# Read a single keypress (including arrow keys)
tui_read_key() {
    local key
    IFS= read -rsn1 key 2>/dev/null

    if [[ $key == $'\x1b' ]]; then
        read -rsn2 -t 0.1 key 2>/dev/null
        case "$key" in
            '[A') echo "UP" ;;
            '[B') echo "DOWN" ;;
            '[C') echo "RIGHT" ;;
            '[D') echo "LEFT" ;;
            *) echo "ESC" ;;
        esac
    elif [[ $key == "" ]]; then
        echo "ENTER"
    elif [[ $key == " " ]]; then
        echo "SPACE"
    elif [[ $key == "q" ]] || [[ $key == "Q" ]]; then
        echo "QUIT"
    elif [[ $key == "s" ]] || [[ $key == "S" ]]; then
        echo "START"
    elif [[ $key == "i" ]] || [[ $key == "I" ]]; then
        echo "INPUT"
    elif [[ $key == "1" ]]; then
        echo "1"
    elif [[ $key == "2" ]]; then
        echo "2"
    elif [[ $key == "3" ]]; then
        echo "3"
    else
        echo "$key"
    fi
}

# Get checkbox display
tui_checkbox() {
    if [ "$1" = true ]; then
        echo -e "${GREEN}[✓]${NC}"
    else
        echo -e "${MUTED_COLOR}[ ]${NC}"
    fi
}

# Get radio button display
tui_radio() {
    if [ "$1" = "$2" ]; then
        echo -e "${GREEN}(●)${NC}"
    else
        echo -e "${MUTED_COLOR}( )${NC}"
    fi
}

# Render the TUI
tui_render() {
    # Clear screen and move to top
    printf "\033[H\033[2J"

    local width=70
    local hl="${HEADER_COLOR}"
    local nc="${NC}"
    local sel_prefix=""
    local sel_suffix=""

    # Header
    echo -e "${hl}╔══════════════════════════════════════════════════════════════════════╗${nc}"
    echo -e "${hl}║${nc}               ${BOLD}DMS - DRIVE MALWARE SCAN${nc}                               ${hl}║${nc}"
    echo -e "${hl}║${nc}        ${MUTED_COLOR}Use ↑↓ to navigate, Space/Enter to toggle, S to start${nc}        ${hl}║${nc}"
    echo -e "${hl}╠══════════════════════════════════════════════════════════════════════╣${nc}"

    # Input source section
    echo -e "${hl}║${nc}  ${BOLD}INPUT SOURCE${nc}                                                        ${hl}║${nc}"
    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"

    # Item 0: Input path
    if [ $TUI_SELECTED -eq 0 ]; then
        sel_prefix="${CYAN}▶ "
    else
        sel_prefix="  "
    fi
    local path_display
    local type_display=""
    if [ -n "$TUI_INPUT_PATH" ]; then
        path_display="${TUI_INPUT_PATH}"
        [ -n "$TUI_DETECTED_TYPE" ] && type_display=" ${MUTED_COLOR}[${TUI_DETECTED_TYPE}]${nc}"
    else
        path_display="${MUTED_COLOR}(press Enter/I to set path)${nc}"
    fi
    echo -e "${hl}║${nc}${sel_prefix}Path: ${path_display}${type_display}                                        ${hl}║${nc}"

    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"
    echo -e "${hl}║${nc}  ${BOLD}SCAN TYPE${nc}                                                           ${hl}║${nc}"
    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"

    # Item 1: Quick scan
    if [ $TUI_SELECTED -eq 1 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_radio "$TUI_SCAN_TYPE" "quick") Quick Scan       ${MUTED_COLOR}Fast sample-based analysis${nc}              ${hl}║${nc}\n"

    # Item 2: Standard scan
    if [ $TUI_SELECTED -eq 2 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_radio "$TUI_SCAN_TYPE" "standard") Standard Scan    ${MUTED_COLOR}ClamAV + YARA + Strings + Binwalk${nc}       ${hl}║${nc}\n"

    # Item 3: Deep scan
    if [ $TUI_SELECTED -eq 3 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_radio "$TUI_SCAN_TYPE" "deep") Deep Scan        ${MUTED_COLOR}All scanners + entropy + carving${nc}        ${hl}║${nc}\n"

    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"
    echo -e "${hl}║${nc}  ${BOLD}SCAN SCOPE${nc}                                                          ${hl}║${nc}"
    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"

    # Item 4: Full drive
    if [ $TUI_SELECTED -eq 4 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_radio "$TUI_SCAN_SCOPE" "full") Full Drive       ${MUTED_COLOR}Scan entire device including all data${nc}   ${hl}║${nc}\n"

    # Item 5: Slack space only
    if [ $TUI_SELECTED -eq 5 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_radio "$TUI_SCAN_SCOPE" "slack") Slack Space      ${MUTED_COLOR}Scan only unallocated/deleted areas${nc}     ${hl}║${nc}\n"

    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"
    echo -e "${hl}║${nc}  ${BOLD}OPTIONS${nc}                                                             ${hl}║${nc}"
    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"

    # Item 6: Mount
    if [ $TUI_SELECTED -eq 6 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_MOUNT) Mount device before scanning                              ${hl}║${nc}\n"

    # Item 7: Update ClamAV
    if [ $TUI_SELECTED -eq 7 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_UPDATE) Update ClamAV databases                                   ${hl}║${nc}\n"

    # Item 8: Parallel
    if [ $TUI_SELECTED -eq 8 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_PARALLEL) Parallel scanning mode                                    ${hl}║${nc}\n"

    # Item 9: Auto chunk
    if [ $TUI_SELECTED -eq 9 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_AUTOCHUNK) Auto-calculate chunk size                                 ${hl}║${nc}\n"

    # Item 10: Verify hash (EWF)
    if [ $TUI_SELECTED -eq 10 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_VERIFY_HASH) Verify EWF hash before scan ${MUTED_COLOR}(forensic integrity)${nc}       ${hl}║${nc}\n"

    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"
    echo -e "${hl}║${nc}  ${BOLD}ADDITIONAL FEATURES${nc}                                                 ${hl}║${nc}"
    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"

    # Item 11: VirusTotal
    if [ $TUI_SELECTED -eq 11 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_VIRUSTOTAL) VirusTotal hash lookup ${MUTED_COLOR}(requires API key)${nc}              ${hl}║${nc}\n"

    # Item 12: Rootkit
    if [ $TUI_SELECTED -eq 12 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_ROOTKIT) Rootkit detection ${MUTED_COLOR}(requires mount)${nc}                     ${hl}║${nc}\n"

    # Item 13: Timeline
    if [ $TUI_SELECTED -eq 13 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_TIMELINE) Generate file timeline                                    ${hl}║${nc}\n"

    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"
    echo -e "${hl}║${nc}  ${BOLD}OUTPUT${nc}                                                              ${hl}║${nc}"
    echo -e "${hl}╟──────────────────────────────────────────────────────────────────────╢${nc}"

    # Item 14: HTML report
    if [ $TUI_SELECTED -eq 14 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_HTML) Generate HTML report                                     ${hl}║${nc}\n"

    # Item 15: JSON report
    if [ $TUI_SELECTED -eq 15 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_JSON) Generate JSON report                                     ${hl}║${nc}\n"

    # Item 16: Keep output
    if [ $TUI_SELECTED -eq 16 ]; then sel_prefix="${CYAN}▶ "; else sel_prefix="  "; fi
    printf "${hl}║${nc}${sel_prefix}$(tui_checkbox $TUI_OPT_KEEP_OUTPUT) Keep output directory after scan                          ${hl}║${nc}\n"

    echo -e "${hl}╠══════════════════════════════════════════════════════════════════════╣${nc}"

    # Actions
    echo -e "${hl}║${nc}                                                                      ${hl}║${nc}"
    echo -e "${hl}║${nc}      ${GREEN}[S]${nc} Start Scan    ${YELLOW}[I]${nc} Set Input Path    ${RED}[Q]${nc} Quit              ${hl}║${nc}"
    echo -e "${hl}║${nc}                                                                      ${hl}║${nc}"
    echo -e "${hl}╚══════════════════════════════════════════════════════════════════════╝${nc}"

    # Status line
    echo ""
    if [ -z "$TUI_INPUT_PATH" ]; then
        echo -e "  ${YELLOW}⚠${nc}  Please set an input path before starting the scan"
    elif [ -n "$TUI_DETECTED_TYPE" ]; then
        echo -e "  ${GREEN}✓${nc}  Ready to scan: ${BOLD}$TUI_INPUT_PATH${nc} (${TUI_DETECTED_TYPE})"
    fi
}

# Toggle the currently selected option
tui_toggle() {
    case $TUI_SELECTED in
        0)  # Input path - prompt for input
            tui_input_path
            ;;
        1) TUI_SCAN_TYPE="quick" ;;
        2) TUI_SCAN_TYPE="standard" ;;
        3) TUI_SCAN_TYPE="deep" ;;
        4) TUI_SCAN_SCOPE="full" ;;
        5) TUI_SCAN_SCOPE="slack" ;;
        6) TUI_OPT_MOUNT=$([ "$TUI_OPT_MOUNT" = true ] && echo false || echo true) ;;
        7) TUI_OPT_UPDATE=$([ "$TUI_OPT_UPDATE" = true ] && echo false || echo true) ;;
        8) TUI_OPT_PARALLEL=$([ "$TUI_OPT_PARALLEL" = true ] && echo false || echo true) ;;
        9) TUI_OPT_AUTOCHUNK=$([ "$TUI_OPT_AUTOCHUNK" = true ] && echo false || echo true) ;;
        10) TUI_OPT_VERIFY_HASH=$([ "$TUI_OPT_VERIFY_HASH" = true ] && echo false || echo true) ;;
        11) TUI_OPT_VIRUSTOTAL=$([ "$TUI_OPT_VIRUSTOTAL" = true ] && echo false || echo true) ;;
        12) TUI_OPT_ROOTKIT=$([ "$TUI_OPT_ROOTKIT" = true ] && echo false || echo true) ;;
        13) TUI_OPT_TIMELINE=$([ "$TUI_OPT_TIMELINE" = true ] && echo false || echo true) ;;
        14) TUI_OPT_HTML=$([ "$TUI_OPT_HTML" = true ] && echo false || echo true) ;;
        15) TUI_OPT_JSON=$([ "$TUI_OPT_JSON" = true ] && echo false || echo true) ;;
        16) TUI_OPT_KEEP_OUTPUT=$([ "$TUI_OPT_KEEP_OUTPUT" = true ] && echo false || echo true) ;;
    esac
}

# Input path dialog
tui_input_path() {
    # Show cursor for input
    printf "\033[?25h"
    printf "\033[H\033[2J"

    echo -e "${HEADER_COLOR}╔══════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${HEADER_COLOR}║${NC}                       ${BOLD}SET INPUT PATH${NC}                                 ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╠══════════════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}  Enter the path to a device or forensic image:                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}  ${MUTED_COLOR}Examples:${NC}                                                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}    • /dev/sdb1              ${MUTED_COLOR}(block device)${NC}                        ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}    • /evidence/disk.E01     ${MUTED_COLOR}(EWF forensic image)${NC}                  ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}    • /images/disk.raw       ${MUTED_COLOR}(raw disk image)${NC}                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╚══════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Show available block devices
    echo -e "  ${BOLD}Available block devices:${NC}"
    lsblk -d -o NAME,SIZE,TYPE,MOUNTPOINT 2>/dev/null | head -10 | while read line; do
        echo -e "    ${MUTED_COLOR}$line${NC}"
    done
    echo ""

    # Read input with line editing
    read -e -p "  Path: " -i "$TUI_INPUT_PATH" new_path

    if [ -n "$new_path" ]; then
        TUI_INPUT_PATH="$new_path"
        # Detect type
        TUI_DETECTED_TYPE=$(detect_input_type "$TUI_INPUT_PATH")

        # Auto-enable verify hash for EWF
        if [ "$TUI_DETECTED_TYPE" = "ewf" ]; then
            echo ""
            echo -e "  ${GREEN}✓${NC} Detected EWF forensic image"
            echo -e "  ${MUTED_COLOR}Tip: Enable 'Verify EWF hash' for forensic integrity${NC}"
            sleep 1
        fi
    fi

    # Hide cursor again for TUI
    printf "\033[?25l"
}

# Apply TUI selections to actual variables
tui_apply_selections() {
    DEVICE="$TUI_INPUT_PATH"

    case "$TUI_SCAN_TYPE" in
        quick) QUICK_SCAN=true ;;
        deep) DEEP_SCAN=true ;;
        standard) ;; # defaults
    esac

    # Apply scan scope
    SCAN_MODE="$TUI_SCAN_SCOPE"

    DO_MOUNT="$TUI_OPT_MOUNT"
    DO_UPDATE="$TUI_OPT_UPDATE"
    PARALLEL_MODE="$TUI_OPT_PARALLEL"
    AUTO_CHUNK="$TUI_OPT_AUTOCHUNK"
    VERIFY_EWF_HASH="$TUI_OPT_VERIFY_HASH"
    DO_VIRUSTOTAL="$TUI_OPT_VIRUSTOTAL"
    DO_ROOTKIT="$TUI_OPT_ROOTKIT"
    DO_TIMELINE="$TUI_OPT_TIMELINE"
    HTML_REPORT="$TUI_OPT_HTML"
    JSON_REPORT="$TUI_OPT_JSON"
    KEEP_OUTPUT="$TUI_OPT_KEEP_OUTPUT"
}

# Main interactive mode loop
run_interactive_mode() {
    # Hide cursor
    printf "\033[?25l"

    # Restore cursor on exit
    trap 'printf "\033[?25h"' EXIT

    # Initialize
    TUI_SELECTED=0

    while true; do
        tui_render

        local key=$(tui_read_key)

        case "$key" in
            UP)
                TUI_SELECTED=$((TUI_SELECTED - 1))
                [ $TUI_SELECTED -lt 0 ] && TUI_SELECTED=$((TUI_MENU_ITEMS - 1))
                ;;
            DOWN)
                TUI_SELECTED=$((TUI_SELECTED + 1))
                [ $TUI_SELECTED -ge $TUI_MENU_ITEMS ] && TUI_SELECTED=0
                ;;
            SPACE|ENTER)
                tui_toggle
                ;;
            INPUT|i|I)
                tui_input_path
                ;;
            START|s|S)
                if [ -z "$TUI_INPUT_PATH" ]; then
                    echo -e "\n  ${RED}Error:${NC} Please set an input path first"
                    sleep 1
                else
                    # Apply selections and start scan
                    tui_apply_selections
                    printf "\033[?25h"  # Show cursor
                    printf "\033[H\033[2J"  # Clear screen

                    # Show what was selected
                    echo ""
                    echo -e "${GREEN}${BOLD}Starting scan with selected options:${NC}"
                    echo -e "  Input:      ${BOLD}$DEVICE${NC}"
                    echo -e "  Scan type:  ${BOLD}$TUI_SCAN_TYPE${NC}"
                    [ "$DO_MOUNT" = true ] && echo -e "  ${SYMBOL_CHECK} Mount device"
                    [ "$DO_UPDATE" = true ] && echo -e "  ${SYMBOL_CHECK} Update ClamAV"
                    [ "$PARALLEL_MODE" = true ] && echo -e "  ${SYMBOL_CHECK} Parallel mode"
                    [ "$VERIFY_EWF_HASH" = true ] && echo -e "  ${SYMBOL_CHECK} Verify EWF hash"
                    [ "$HTML_REPORT" = true ] && echo -e "  ${SYMBOL_CHECK} HTML report"
                    [ "$JSON_REPORT" = true ] && echo -e "  ${SYMBOL_CHECK} JSON report"
                    echo ""
                    sleep 1
                    return 0
                fi
                ;;
            QUIT|q|Q|ESC)
                printf "\033[?25h"  # Show cursor
                printf "\033[H\033[2J"  # Clear screen
                echo "Exiting..."
                exit 0
                ;;
            1)
                TUI_SCAN_TYPE="quick"
                ;;
            2)
                TUI_SCAN_TYPE="standard"
                ;;
            3)
                TUI_SCAN_TYPE="deep"
                ;;
        esac
    done
}

# ==========================================
# MAIN EXECUTION
# ==========================================

main() {
    # Parse arguments first to set modes
    DEVICE=""
    DO_MOUNT=false
    DO_UPDATE=false
    DEEP_SCAN=false
    OUTPUT_FILE=""
    PARALLEL_MODE=false
    AUTO_CHUNK=false
    QUICK_SCAN=false
    DO_VIRUSTOTAL=false
    DO_ROOTKIT=false
    DO_TIMELINE=false
    RESUME_FILE=""
    HTML_REPORT=false
    JSON_REPORT=false
    QUIET_MODE=false
    VERBOSE_MODE=false
    DRY_RUN=false
    CUSTOM_CONFIG=""
    KEEP_OUTPUT=false
    SAVE_CHECKPOINT=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            -m|--mount)
                DO_MOUNT=true
                shift
                ;;
            -u|--update)
                DO_UPDATE=true
                shift
                ;;
            -d|--deep)
                DEEP_SCAN=true
                shift
                ;;
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            -p|--parallel)
                PARALLEL_MODE=true
                shift
                ;;
            --auto-chunk)
                AUTO_CHUNK=true
                shift
                ;;
            --quick)
                QUICK_SCAN=true
                shift
                ;;
            --virustotal)
                DO_VIRUSTOTAL=true
                shift
                ;;
            --rootkit)
                DO_ROOTKIT=true
                shift
                ;;
            --timeline)
                DO_TIMELINE=true
                shift
                ;;
            --resume)
                RESUME_FILE="$2"
                shift 2
                ;;
            --html)
                HTML_REPORT=true
                shift
                ;;
            --json)
                JSON_REPORT=true
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=true
                LOG_LEVEL="ERROR"
                shift
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                LOG_LEVEL="DEBUG"
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --config)
                CUSTOM_CONFIG="$2"
                shift 2
                ;;
            --log-file)
                LOG_FILE="$2"
                shift 2
                ;;
            --keep-output)
                KEEP_OUTPUT=true
                shift
                ;;
            --portable)
                PORTABLE_MODE=true
                shift
                ;;
            --portable-keep)
                PORTABLE_KEEP=true
                shift
                ;;
            --portable-dir)
                PORTABLE_TOOLS_DIR="$2"
                shift 2
                ;;
            --verify-hash)
                VERIFY_EWF_HASH=true
                shift
                ;;
            --input-format)
                FORCE_INPUT_FORMAT="$2"
                shift 2
                ;;
            --scan-mode)
                if [ "$2" = "full" ] || [ "$2" = "slack" ]; then
                    SCAN_MODE="$2"
                else
                    print_error "Invalid scan mode: $2 (use 'full' or 'slack')"
                    exit 1
                fi
                shift 2
                ;;
            --slack)
                SCAN_MODE="slack"
                shift
                ;;
            --no-color)
                NO_COLOR=true
                shift
                ;;
            --high-contrast)
                HIGH_CONTRAST=true
                shift
                ;;
            -i|--interactive)
                INTERACTIVE_MODE=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            -*)
                print_error "Unknown option: $1"
                usage
                ;;
            *)
                DEVICE="$1"
                shift
                ;;
        esac
    done

    # Load configuration file
    load_config

    # Apply color settings based on flags
    apply_color_settings

    # Print banner
    print_banner

    # Run interactive mode if requested
    if [ "$INTERACTIVE_MODE" = true ]; then
        run_interactive_mode
        # If interactive mode exited (user quit), the script would have exited
        # If we get here, user pressed Start, so continue with scan
    fi

    # Handle resume mode
    if [ -n "$RESUME_FILE" ]; then
        if ! load_checkpoint "$RESUME_FILE"; then
            exit 1
        fi
    fi

    # Validate device
    if [ -z "$DEVICE" ]; then
        print_error "No device specified"
        usage
    fi

    # Export device for subprocesses
    export DEVICE
    export SCAN_DEVICE="$DEVICE"

    # Check privileges
    check_privileges

    # Create output directory
    mkdir -p "$SCAN_OUTPUT_DIR"
    print_status "Scan output directory: $SCAN_OUTPUT_DIR"

    # Enable checkpoint saving
    SAVE_CHECKPOINT=true
    CHECKPOINT_FILE="$SCAN_OUTPUT_DIR/.checkpoint"

    # Initialize results array
    declare -gA RESULTS
    declare -gA SCAN_STATUS

    # Record scan start time for duration calculation
    SCAN_START_TIME=$(date +%s)

    # Run checks
    if ! run_scan "check_tools" check_tools; then
        print_error "Tool check failed"
        exit 1
    fi

    if ! run_scan "get_device_info" get_device_info; then
        print_error "Could not get device info"
        exit 1
    fi

    # Auto chunk size calculation
    if [ "$AUTO_CHUNK" = true ]; then
        calculate_optimal_chunk_size
        print_status "Using auto-calculated chunk size: ${CHUNK_SIZE}MB"
    fi

    # Mount if requested
    if [ "$DO_MOUNT" = true ]; then
        run_scan "mount_device" mount_device
    fi

    # Update ClamAV if requested
    if [ "$DO_UPDATE" = true ]; then
        run_scan "update_clamav" update_clamav
    fi

    # Slack space scan mode
    if [ "$SCAN_MODE" = "slack" ]; then
        print_section "Slack Space Scan Mode"
        print_status "Extracting and analyzing unallocated disk space..."

        # Run slack space extraction and analysis
        run_scan "slack_space" scan_slack_space

        # If slack extraction succeeded, scan the extracted data
        if [ -n "$SLACK_DEVICE" ] && [ -f "$SLACK_DEVICE" ]; then
            print_status "Scanning extracted slack space data..."

            # Store original device path
            local original_device="$DEVICE"

            # Point scans at the extracted slack data
            DEVICE="$SLACK_DEVICE"
            export SCAN_DEVICE="$SLACK_DEVICE"

            # Run scans on slack data
            if [ "$PARALLEL_MODE" = true ]; then
                run_scan "parallel_scans" run_parallel_scans
            else
                run_scan "clamav" scan_clamav
                run_scan "yara" scan_yara
                run_scan "strings" scan_strings
            fi

            # Restore original device path for reporting
            DEVICE="$original_device"
            export SCAN_DEVICE="$original_device"
        else
            print_warning "Slack space extraction failed or no data to scan"
        fi
    else
        # Full drive scan mode

        # Quick scan mode
        if [ "$QUICK_SCAN" = true ]; then
            run_scan "quick_scan" scan_quick

            # If quick scan found issues, suggest full scan
            if [ "${RESULTS[quick_scan]:-0}" -gt 0 ]; then
                print_warning "Quick scan found issues. Running full scan..."
            else
                print_success "Quick scan complete."
                generate_report
                [ "$HTML_REPORT" = true ] && generate_html_report
                [ "$JSON_REPORT" = true ] && generate_json_report
                exit 0
            fi
        fi

        # Run scans (parallel or sequential)
        if [ "$PARALLEL_MODE" = true ]; then
            run_scan "parallel_scans" run_parallel_scans
        else
            # Sequential scans with graceful error handling
            run_scan "clamav" scan_clamav
            run_scan "yara" scan_yara
            run_scan "binwalk" scan_binwalk
            run_scan "strings" scan_strings
        fi

        # VirusTotal scan
        if [ "$DO_VIRUSTOTAL" = true ]; then
            run_scan "virustotal" scan_virustotal
        fi

        # Rootkit scan
        if [ "$DO_ROOTKIT" = true ]; then
            run_scan "rootkit" scan_rootkit
        fi

        # Timeline generation
        if [ "$DO_TIMELINE" = true ]; then
            run_scan "timeline" generate_timeline
        fi

        # Deep scans
        if [ "$DEEP_SCAN" = true ]; then
            print_section "Starting Deep Scan"
            run_scan "entropy" scan_entropy
            run_scan "file_carving" scan_file_carving
            run_scan "executables" scan_executables
            run_scan "boot_sector" scan_boot_sector
            run_scan "bulk_extractor" scan_bulk_extractor
            run_scan "hashes" scan_hashes
        fi
    fi

    # Generate reports
    generate_report

    if [ "$HTML_REPORT" = true ]; then
        generate_html_report
    fi

    if [ "$JSON_REPORT" = true ]; then
        generate_json_report
    fi

    # Calculate total findings and duration
    local total_findings=0
    for key in "${!RESULTS[@]}"; do
        local val="${RESULTS[$key]}"
        if [[ "$val" =~ ^[0-9]+$ ]]; then
            total_findings=$((total_findings + val))
        fi
    done

    # Calculate scan duration
    local scan_end_time=$(date +%s)
    local scan_duration=$((scan_end_time - SCAN_START_TIME))
    local duration_min=$((scan_duration / 60))
    local duration_sec=$((scan_duration % 60))
    local duration_str=$(printf "%d minutes %d seconds" "$duration_min" "$duration_sec")

    # Show summary dashboard
    draw_summary_dashboard "$total_findings" "$duration_str"

    # Summary of scan status
    local failed_scans=0
    for scan in "${!SCAN_STATUS[@]}"; do
        if [ "${SCAN_STATUS[$scan]}" = "failed" ]; then
            failed_scans=$((failed_scans + 1))
        fi
    done

    if [ $failed_scans -gt 0 ]; then
        echo ""
        print_warning "$failed_scans scan(s) encountered errors but scan completed"
    fi
}

# Run main function
main "$@"
