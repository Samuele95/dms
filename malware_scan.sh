#!/bin/bash
#
# Malware Scanner Script for Tsurugi Linux
# Scans a drive for malware using ClamAV, YARA rules, string analysis,
# file carving, entropy analysis, and bulk extraction
#
# Version 2.0 - Enhanced with robustness, performance, and feature improvements
#

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Default values
CLAMDB_DIR="/tmp/clamdb"
CHUNK_SIZE=500  # MB per chunk for scanning
YARA_RULES_BASE="/opt/Qu1cksc0pe/Systems"
OLEDUMP_RULES="/opt/oledump"
SCAN_OUTPUT_DIR="/tmp/malware_scan_$$"
YARA_CACHE_DIR="/tmp/yara_cache"
CHECKPOINT_FILE=""
VT_API_KEY=""
VT_RATE_LIMIT=4  # requests per minute for free API
MAX_PARALLEL_JOBS=4
LOG_LEVEL="INFO"  # DEBUG, INFO, WARNING, ERROR
LOG_FILE=""

# Portable tools settings
PORTABLE_MODE=false
PORTABLE_TOOLS_DIR="/tmp/malscan_portable_tools"
PORTABLE_KEEP=false  # Keep portable tools after scan

# Tool version configuration for portable downloads
YARA_VERSION="4.5.0"
CLAMAV_VERSION="1.3.1"

# USB/Kit mode settings
USB_MODE=false                     # Auto-detected if running from USB kit
USB_ROOT=""                        # Root directory of USB kit
KIT_MODE="none"                    # "none", "minimal", "full"
KIT_MANIFEST=""                    # Path to .dms_kit_manifest.json
DMS_ROOT=""                        # DMS installation directory
DMS_DATABASES_DIR=""               # Bundled databases directory
DMS_TOOLS_DIR=""                   # Bundled tools directory

# ISO/Kit building options
DO_BUILD_KIT=false                 # --build-full-kit flag
DO_BUILD_MINIMAL_KIT=false         # --build-minimal-kit flag
DO_BUILD_ISO=false                 # --build-iso flag
DO_UPDATE_KIT=false                # --update-kit flag
DO_FLASH_ISO=false                 # --flash-iso flag
KIT_TARGET=""                      # --kit-target path
ISO_OUTPUT=""                      # --iso-output path
FLASH_DEVICE=""                    # Device for --flash-iso
FORCE_FLASH=false                  # --force flag for flashing

# Output storage options
OUTPUT_DEVICE=""                   # --output-device path
OUTPUT_PATH=""                     # --output-path for results
USE_TMPFS_OUTPUT=false             # --output-tmpfs flag
CASE_NAME=""                       # --case-name value

# Input handling - EWF/Forensic image support
INPUT_TYPE=""              # "block_device", "ewf", "raw_image"
ORIGINAL_INPUT=""          # User's original input path
ACTUAL_DEVICE=""           # Device path used for scanning (may be virtual)

# EWF-specific variables
IS_EWF_MOUNT=false         # Track if we mounted EWF
TEMP_MOUNT_POINT=""        # Mount point for virtual device
EWF_SEGMENTS=()            # Array of segment files found
EWF_TOTAL_SIZE=""          # Image size from ewfinfo
EWF_HASH_MD5=""            # Stored MD5 from EWF metadata
EWF_HASH_SHA1=""           # Stored SHA1 from EWF metadata
EWF_ACQUISITION_DATE=""    # Acquisition date from metadata
EWF_CASE_NUMBER=""         # Case number from metadata

# EWF options
VERIFY_EWF_HASH=false      # --verify-hash flag
FORCE_INPUT_FORMAT=""      # --input-format value
EWF_SUPPORT=true           # Enable EWF support
TEMP_MOUNT_BASE="/tmp"     # Base directory for temp mounts

# TUI/Display options
NO_COLOR=false             # --no-color flag
HIGH_CONTRAST=false        # --high-contrast flag
INTERACTIVE_MODE=false     # --interactive flag

# Scan mode options
SCAN_MODE="full"           # "full" or "slack"
SLACK_DEVICE=""            # Path to extracted slack space file

# Slack space settings
SLACK_EXTRACT_TIMEOUT=600  # Max seconds for extraction
SLACK_MIN_SIZE_MB=10       # Skip if slack < this size
MAX_CARVED_FILES=1000      # Limit recovered files
CARVING_TOOLS="foremost"   # Tools to use: foremost,photorec,scalpel

# Forensic analysis settings
FORENSIC_ANALYSIS=false    # --forensic-analysis flag (enables all)
DO_PERSISTENCE_SCAN=false  # --persistence-scan flag
DO_EXECUTION_SCAN=false    # --execution-scan flag
DO_FILE_ANOMALIES=false    # --file-anomalies flag
DO_RE_TRIAGE=false         # --re-triage flag
DO_MFT_ANALYSIS=false      # --mft-analysis flag
ATTACK_MAPPING=true        # --attack-mapping flag (include ATT&CK IDs)

# Forensic tools paths (can be overridden in config)
REGRIPPER_PATH=""          # Path to rip.pl
CAPA_PATH=""               # Path to capa binary
RADARE2_PATH=""            # Path to radare2/rizin
PYTHON_FORENSIC_TOOLS=""   # Path to Python forensic tools

# Mounted filesystem path for artifact analysis
MOUNTED_FS_PATH=""         # Path where image is mounted for file-level access

# Enhanced color scheme
SUCCESS_COLOR='\033[1;32m'   # Bright green
ERROR_COLOR='\033[1;31m'     # Bright red
WARNING_COLOR='\033[1;33m'   # Bright yellow
INFO_COLOR='\033[1;34m'      # Bright blue
HEADER_COLOR='\033[1;36m'    # Bright cyan
MUTED_COLOR='\033[0;90m'     # Gray for secondary info
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

# TUI symbols (Unicode)
SYMBOL_CHECK="✓"
SYMBOL_CROSS="✗"
SYMBOL_WARNING="⚠"
SYMBOL_BULLET="●"
SYMBOL_CIRCLE="○"
SPINNER_CHARS=("⠋" "⠙" "⠹" "⠸" "⠼" "⠴" "⠦" "⠧" "⠇" "⠏")

# Configuration file locations
CONFIG_LOCATIONS=(
    "$HOME/.malscan.conf"
    "/etc/malscan.conf"
    "./malscan.conf"
)

# ============================================
# LIBRARY MODULE LOADING
# ============================================
# Determine script's actual location (resolve symlinks)
SCRIPT_PATH="${BASH_SOURCE[0]}"
while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    [[ $SCRIPT_PATH != /* ]] && SCRIPT_PATH="$SCRIPT_DIR/$SCRIPT_PATH"
done
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

# Source library modules if available
DMS_LIB_DIR="${DMS_ROOT:-$SCRIPT_DIR}/lib"

# USB mode detection and environment setup
if [ -f "$DMS_LIB_DIR/usb_mode.sh" ]; then
    source "$DMS_LIB_DIR/usb_mode.sh"
fi

# Output storage management
if [ -f "$DMS_LIB_DIR/output_storage.sh" ]; then
    source "$DMS_LIB_DIR/output_storage.sh"
fi

# Update manager for USB kit maintenance
if [ -f "$DMS_LIB_DIR/update_manager.sh" ]; then
    source "$DMS_LIB_DIR/update_manager.sh"
fi

# Kit builder for creating portable kits
if [ -f "$DMS_LIB_DIR/kit_builder.sh" ]; then
    source "$DMS_LIB_DIR/kit_builder.sh"
fi

# ISO builder for live forensic images
if [ -f "$DMS_LIB_DIR/iso_builder.sh" ]; then
    source "$DMS_LIB_DIR/iso_builder.sh"
fi

# Track background processes for cleanup
declare -a BG_PIDS=()
declare -gA RESULTS
declare -gA SCAN_STATUS  # Track which scans succeeded/failed

# Statistics tracking array for detailed reporting
declare -gA STATS=(
    # ClamAV statistics
    [clamav_scanned]=0
    [clamav_infected]=0
    [clamav_signatures]=""

    # YARA statistics
    [yara_rules_checked]=0
    [yara_matches]=0
    [yara_match_details]=""

    # Strings analysis
    [strings_total]=0
    [strings_urls]=0
    [strings_executables]=0
    [strings_credentials]=0
    [strings_samples]=""

    # Entropy analysis
    [entropy_regions_scanned]=0
    [entropy_high_count]=0
    [entropy_avg]="0"
    [entropy_max]="0"
    [entropy_high_offsets]=""

    # File carving
    [carved_total]=0
    [carved_by_type]=""
    [carved_executables]=0

    # Slack space
    [slack_size_mb]=0
    [slack_data_recovered_mb]=0
    [slack_files_recovered]=0

    # Executables
    [pe_headers]=0
    [elf_headers]=0
    [pe_offsets]=""
    [elf_offsets]=""

    # Bulk extractor
    [bulk_emails]=0
    [bulk_urls]=0
    [bulk_ccn]=0

    # Forensic analysis - Persistence artifacts
    [persistence_findings]=0
    [persistence_registry_run]=0
    [persistence_services]=0
    [persistence_tasks]=0
    [persistence_startup]=0
    [persistence_wmi]=0
    [persistence_details]=""

    # Forensic analysis - Execution artifacts
    [execution_findings]=0
    [execution_prefetch]=0
    [execution_amcache]=0
    [execution_shimcache]=0
    [execution_userassist]=0
    [execution_srum]=0
    [execution_bam]=0
    [execution_anomalies]=0
    [execution_suspicious_paths]=0
    [execution_details]=""

    # Forensic analysis - File anomalies
    [file_anomalies]=0
    [file_timestomping]=0
    [file_ads]=0
    [file_extension_mismatch]=0
    [file_suspicious_paths]=0
    [file_packed]=0
    [file_attribute_anomalies]=0
    [file_anomaly_details]=""

    # Forensic analysis - RE triage
    [re_triaged_files]=0
    [re_packed_files]=0
    [re_suspicious_imports]=0
    [re_capa_matches]=0
    [re_shellcode_detected]=0
    [re_suspicious_strings]=0
    [re_attack_techniques]=""
    [re_triage_details]=""

    # Forensic analysis - Filesystem
    [mft_deleted_recovered]=0
    [mft_timestomping]=0
    [usn_entries]=0
    [filesystem_anomalies]=0
    [filesystem_details]=""
)

# Guidance recommendations array
declare -a GUIDANCE_RECOMMENDATIONS=()
declare -a GUIDANCE_NO_ACTION=()

# ==========================================
# CLEANUP AND TRAP HANDLERS
# ==========================================

cleanup() {
    local exit_code=$?

    log "DEBUG" "Cleanup triggered with exit code: $exit_code"

    # Kill any background processes
    for pid in "${BG_PIDS[@]}"; do
        if kill -0 "$pid" 2>/dev/null; then
            log "DEBUG" "Killing background process: $pid"
            kill "$pid" 2>/dev/null || true
            wait "$pid" 2>/dev/null || true
        fi
    done

    # Save checkpoint if we have progress
    if [ -n "$CHECKPOINT_FILE" ] && [ "$SAVE_CHECKPOINT" = true ]; then
        save_checkpoint
    fi

    # Unmount EWF image if we mounted one
    if [ "$IS_EWF_MOUNT" = true ] && [ -d "$TEMP_MOUNT_POINT" ]; then
        log "DEBUG" "Unmounting EWF image from: $TEMP_MOUNT_POINT"
        if ! umount "$TEMP_MOUNT_POINT" 2>/dev/null; then
            fusermount -u "$TEMP_MOUNT_POINT" 2>/dev/null || {
                log "WARNING" "Could not unmount EWF image from $TEMP_MOUNT_POINT"
            }
        fi
        rmdir "$TEMP_MOUNT_POINT" 2>/dev/null || true
        IS_EWF_MOUNT=false
    fi

    # Clean up temp files unless --keep-output is set
    if [ "$KEEP_OUTPUT" != true ] && [ -d "$SCAN_OUTPUT_DIR" ]; then
        if [ "$exit_code" -ne 0 ]; then
            log "WARNING" "Scan interrupted. Temp files preserved at: $SCAN_OUTPUT_DIR"
        else
            # Only clean up on successful completion if not keeping output
            if [ "$KEEP_OUTPUT" != true ]; then
                log "DEBUG" "Cleaning up temp directory: $SCAN_OUTPUT_DIR"
            fi
        fi
    fi

    # Clean up YARA cache if it's a temp cache
    if [ -d "$YARA_CACHE_DIR" ] && [[ "$YARA_CACHE_DIR" == /tmp/* ]]; then
        log "DEBUG" "Preserving YARA cache at: $YARA_CACHE_DIR"
    fi

    # Clean up portable tools directory unless --portable-keep is set
    if [ "$PORTABLE_MODE" = true ] && [ "$PORTABLE_KEEP" != true ] && [ -d "$PORTABLE_TOOLS_DIR" ]; then
        log "DEBUG" "Cleaning up portable tools directory: $PORTABLE_TOOLS_DIR"
        rm -rf "$PORTABLE_TOOLS_DIR"
    elif [ "$PORTABLE_MODE" = true ] && [ "$PORTABLE_KEEP" = true ]; then
        log "INFO" "Portable tools preserved at: $PORTABLE_TOOLS_DIR"
    fi

    exit $exit_code
}

# Set trap handlers
trap cleanup EXIT
trap 'log "WARNING" "Received interrupt signal"; exit 130' INT
trap 'log "WARNING" "Received termination signal"; exit 143' TERM

# ==========================================
# LOGGING SYSTEM
# ==========================================

log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log level hierarchy: DEBUG < INFO < WARNING < ERROR
    local level_num=0
    local current_level_num=0

    case "$level" in
        DEBUG)   level_num=0 ;;
        INFO)    level_num=1 ;;
        WARNING) level_num=2 ;;
        ERROR)   level_num=3 ;;
    esac

    case "$LOG_LEVEL" in
        DEBUG)   current_level_num=0 ;;
        INFO)    current_level_num=1 ;;
        WARNING) current_level_num=2 ;;
        ERROR)   current_level_num=3 ;;
    esac

    # Skip if message level is below current log level
    if [ $level_num -lt $current_level_num ]; then
        return
    fi

    # Format message for console (unless quiet mode)
    if [ "$QUIET_MODE" != true ]; then
        case "$level" in
            DEBUG)   echo -e "${CYAN}[DEBUG]${NC} $message" ;;
            INFO)    echo -e "${BLUE}[*]${NC} $message" ;;
            WARNING) echo -e "${YELLOW}[!]${NC} $message" ;;
            ERROR)   echo -e "${RED}[-]${NC} $message" ;;
        esac
    fi

    # Write to log file if specified
    if [ -n "$LOG_FILE" ]; then
        echo "[$timestamp] [$level] $message" >> "$LOG_FILE"
    fi
}

print_banner() {
    if [ "$QUIET_MODE" = true ]; then
        return
    fi
    echo ""
    echo -e "${HEADER_COLOR}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                               ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██████╗ ███╗   ███╗███████╗${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██╔══██╗████╗ ████║██╔════╝${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██║  ██║██╔████╔██║███████╗${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██║  ██║██║╚██╔╝██║╚════██║${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}██████╔╝██║ ╚═╝ ██║███████║${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}           ${BOLD}╚═════╝ ╚═╝     ╚═╝╚══════╝${NC}                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                               ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}             ${MUTED_COLOR}D R I V E   M A L W A R E   S C A N${NC}                ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                               ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${HEADER_COLOR}║${NC}                  ${BOLD}DMS v2.1${NC}  ${MUTED_COLOR}|${NC}  ${GREEN}EWF Support${NC}                     ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}      ${MUTED_COLOR}ClamAV + YARA + Forensic Analysis + Deep Scan${NC}           ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
}

print_status() {
    log "INFO" "$1"
}

print_success() {
    if [ "$QUIET_MODE" != true ]; then
        echo -e "${GREEN}[+]${NC} $1"
    fi
    [ -n "$LOG_FILE" ] && echo "[$(date '+%Y-%m-%d %H:%M:%S')] [SUCCESS] $1" >> "$LOG_FILE"
}

print_warning() {
    log "WARNING" "$1"
}

print_error() {
    log "ERROR" "$1"
}

print_section() {
    if [ "$QUIET_MODE" = true ]; then
        return
    fi
    echo ""
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"
    echo -e "${YELLOW} $1${NC}"
    echo -e "${YELLOW}═══════════════════════════════════════════════════════════${NC}"
}

# ==========================================
# TUI HELPER FUNCTIONS
# ==========================================

# Get terminal width for responsive layouts
get_terminal_width() {
    local width
    width=$(tput cols 2>/dev/null || echo 80)
    echo "$width"
}

# Apply color settings based on --no-color and --high-contrast flags
apply_color_settings() {
    if [ "$NO_COLOR" = true ]; then
        RED=''
        GREEN=''
        YELLOW=''
        BLUE=''
        CYAN=''
        MAGENTA=''
        NC=''
        SUCCESS_COLOR=''
        ERROR_COLOR=''
        WARNING_COLOR=''
        INFO_COLOR=''
        HEADER_COLOR=''
        MUTED_COLOR=''
        BOLD=''
        DIM=''
        RESET=''
        # Use ASCII fallbacks for symbols
        SYMBOL_CHECK="[OK]"
        SYMBOL_CROSS="[X]"
        SYMBOL_WARNING="[!]"
        SYMBOL_BULLET="*"
        SYMBOL_CIRCLE="o"
    elif [ "$HIGH_CONTRAST" = true ]; then
        # High contrast mode - bold text only, no dim colors
        DIM=''
        MUTED_COLOR="$BOLD"
    fi
}

# Draw a box around content
draw_box() {
    local title="$1"
    local width="${2:-60}"
    local style="${3:-single}"  # single, double, rounded

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local tl tr bl br h v
    case "$style" in
        double)
            tl="╔" tr="╗" bl="╚" br="╝" h="═" v="║"
            ;;
        rounded)
            tl="╭" tr="╮" bl="╰" br="╯" h="─" v="│"
            ;;
        *)  # single
            tl="┌" tr="┐" bl="└" br="┘" h="─" v="│"
            ;;
    esac

    local inner_width=$((width - 2))
    local line=$(printf "%${inner_width}s" | tr ' ' "$h")

    echo -e "${HEADER_COLOR}${tl}${line}${tr}${NC}"
    if [ -n "$title" ]; then
        local title_len=${#title}
        local padding=$(( (inner_width - title_len) / 2 ))
        local left_pad=$(printf "%${padding}s" "")
        local right_pad_len=$((inner_width - padding - title_len))
        local right_pad=$(printf "%${right_pad_len}s" "")
        echo -e "${HEADER_COLOR}${v}${NC}${left_pad}${BOLD}${title}${NC}${right_pad}${HEADER_COLOR}${v}${NC}"
        echo -e "${HEADER_COLOR}${tl}${line}${tr}${NC}"
    fi
}

# Close a box
draw_box_end() {
    local width="${1:-60}"
    local style="${2:-single}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local bl br h
    case "$style" in
        double) bl="╚" br="╝" h="═" ;;
        rounded) bl="╰" br="╯" h="─" ;;
        *) bl="└" br="┘" h="─" ;;
    esac

    local inner_width=$((width - 2))
    local line=$(printf "%${inner_width}s" | tr ' ' "$h")
    echo -e "${HEADER_COLOR}${bl}${line}${br}${NC}"
}

# Draw box content line
draw_box_line() {
    local content="$1"
    local width="${2:-60}"
    local style="${3:-single}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local v
    case "$style" in
        double) v="║" ;;
        *) v="│" ;;
    esac

    local inner_width=$((width - 4))
    printf "${HEADER_COLOR}${v}${NC} %-${inner_width}s ${HEADER_COLOR}${v}${NC}\n" "$content"
}

# Enhanced progress bar with Unicode blocks
draw_progress_bar() {
    local current="$1"
    local total="$2"
    local description="${3:-Processing}"
    local width="${4:-30}"
    local start_time="${5:-}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local percent=$((current * 100 / total))
    local filled=$((percent * width / 100))
    local empty=$((width - filled))

    # Use Unicode blocks for smoother progress bar
    local bar=""
    for ((i=0; i<filled; i++)); do
        bar+="█"
    done
    for ((i=0; i<empty; i++)); do
        bar+="░"
    done

    # Calculate ETA if start_time provided
    local eta_str=""
    local speed_str=""
    if [ -n "$start_time" ] && [ "$current" -gt 0 ]; then
        local elapsed=$(($(date +%s) - start_time))
        if [ "$elapsed" -gt 0 ]; then
            local rate=$(echo "scale=2; $current / $elapsed" | bc 2>/dev/null || echo "0")
            if [ "$(echo "$rate > 0" | bc 2>/dev/null || echo 0)" = "1" ]; then
                local remaining=$((total - current))
                local eta_secs=$(echo "scale=0; $remaining / $rate" | bc 2>/dev/null || echo "0")
                local eta_min=$((eta_secs / 60))
                local eta_sec=$((eta_secs % 60))
                eta_str=$(printf "ETA: %02d:%02d" "$eta_min" "$eta_sec")
            fi
        fi
    fi

    # Clear line and print progress
    printf "\r\033[K${INFO_COLOR}[*]${NC} %s [${GREEN}%s${NC}] %3d%% %s" \
        "$description" "$bar" "$percent" "$eta_str"
}

# Animated spinner for indeterminate operations
draw_spinner() {
    local message="$1"
    local pid="$2"
    local spin_idx=0

    if [ "$QUIET_MODE" = true ]; then
        wait "$pid" 2>/dev/null
        return
    fi

    while kill -0 "$pid" 2>/dev/null; do
        printf "\r${INFO_COLOR}%s${NC} %s" "${SPINNER_CHARS[$spin_idx]}" "$message"
        spin_idx=$(( (spin_idx + 1) % ${#SPINNER_CHARS[@]} ))
        sleep 0.1
    done
    printf "\r\033[K"  # Clear line when done
}

# Draw a status line with icon
draw_status_line() {
    local status="$1"  # success, error, warning, info, pending, running
    local message="$2"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local icon color
    case "$status" in
        success)  icon="$SYMBOL_CHECK" color="$SUCCESS_COLOR" ;;
        error)    icon="$SYMBOL_CROSS" color="$ERROR_COLOR" ;;
        warning)  icon="$SYMBOL_WARNING" color="$WARNING_COLOR" ;;
        info)     icon="$SYMBOL_BULLET" color="$INFO_COLOR" ;;
        pending)  icon="$SYMBOL_CIRCLE" color="$MUTED_COLOR" ;;
        running)  icon="$SYMBOL_BULLET" color="$YELLOW" ;;
        *)        icon="*" color="$NC" ;;
    esac

    echo -e "${color}${icon}${NC} $message"
}

# Draw a table header
draw_table_header() {
    local -a headers=("$@")
    local width=$(get_terminal_width)
    local col_width=$(( (width - 4) / ${#headers[@]} ))

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    # Top border
    printf "${HEADER_COLOR}┌"
    for ((i=0; i<${#headers[@]}; i++)); do
        printf "%${col_width}s" | tr ' ' '─'
        [ $i -lt $((${#headers[@]} - 1)) ] && printf "┬"
    done
    printf "┐${NC}\n"

    # Headers
    printf "${HEADER_COLOR}│${NC}"
    for header in "${headers[@]}"; do
        printf " ${BOLD}%-$((col_width-2))s${NC} ${HEADER_COLOR}│${NC}" "$header"
    done
    echo ""

    # Separator
    printf "${HEADER_COLOR}├"
    for ((i=0; i<${#headers[@]}; i++)); do
        printf "%${col_width}s" | tr ' ' '─'
        [ $i -lt $((${#headers[@]} - 1)) ] && printf "┼"
    done
    printf "┤${NC}\n"
}

# Draw a table row
draw_table_row() {
    local -a cols=("$@")
    local width=$(get_terminal_width)
    local col_width=$(( (width - 4) / ${#cols[@]} ))

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    printf "${HEADER_COLOR}│${NC}"
    for col in "${cols[@]}"; do
        printf " %-$((col_width-2))s ${HEADER_COLOR}│${NC}" "$col"
    done
    echo ""
}

# Draw table footer
draw_table_footer() {
    local num_cols="$1"
    local width=$(get_terminal_width)
    local col_width=$(( (width - 4) / num_cols ))

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    printf "${HEADER_COLOR}└"
    for ((i=0; i<num_cols; i++)); do
        printf "%${col_width}s" | tr ' ' '─'
        [ $i -lt $((num_cols - 1)) ] && printf "┴"
    done
    printf "┘${NC}\n"
}

# Draw summary dashboard at end of scan
draw_summary_dashboard() {
    local total_findings="$1"
    local duration="$2"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local width=64
    local inner=$((width - 4))

    echo ""
    echo -e "${HEADER_COLOR}╔$(printf '%*s' $((width-2)) | tr ' ' '═')╗${NC}"
    echo -e "${HEADER_COLOR}║$(printf '%*s' $(( (inner - 14) / 2 )) '')${BOLD}SCAN COMPLETE${NC}$(printf '%*s' $(( (inner - 13) / 2 )) '')${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╠$(printf '%*s' $((width-2)) | tr ' ' '═')╣${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"

    # Device info
    local display_input="${ORIGINAL_INPUT:-$DEVICE}"
    local input_type_display=""
    case "$INPUT_TYPE" in
        ewf) input_type_display=" (EWF Image)" ;;
        raw_image) input_type_display=" (Raw Image)" ;;
        block_device) input_type_display="" ;;
    esac

    printf "${HEADER_COLOR}║${NC}   Device:     %-43s ${HEADER_COLOR}║${NC}\n" "${display_input}${input_type_display}"
    printf "${HEADER_COLOR}║${NC}   Size:       %-43s ${HEADER_COLOR}║${NC}\n" "${DEVICE_SIZE_GB} GB"
    printf "${HEADER_COLOR}║${NC}   Scan Mode:  %-43s ${HEADER_COLOR}║${NC}\n" "$([ "$SCAN_MODE" = "slack" ] && echo "Slack Space Only" || echo "Full Drive")"
    printf "${HEADER_COLOR}║${NC}   Duration:   %-43s ${HEADER_COLOR}║${NC}\n" "$duration"

    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"

    # Statistics-based findings summary (no subjective labels)
    echo -e "${HEADER_COLOR}║${NC}   ┌────────────────────────────────────────────────────┐   ${HEADER_COLOR}║${NC}"

    # Build findings summary string
    local findings_summary=""
    local clamav_count="${RESULTS[clamav]:-0}"
    local yara_count=$((${RESULTS[yara_Windows]:-0} + ${RESULTS[yara_Linux]:-0}))
    local carved_exec="${STATS[carved_executables]:-0}"

    if [ "$clamav_count" != "0" ] && [ "$clamav_count" != "N/A" ]; then
        findings_summary+="${clamav_count} AV detection(s), "
    fi
    if [ "$yara_count" -gt 0 ]; then
        findings_summary+="${yara_count} YARA match(es), "
    fi
    if [ "$carved_exec" -gt 0 ]; then
        findings_summary+="${carved_exec} recovered exe(s), "
    fi

    # Remove trailing comma and space
    findings_summary="${findings_summary%, }"

    if [ -z "$findings_summary" ]; then
        findings_summary="No notable findings"
    fi

    printf "${HEADER_COLOR}║${NC}   │  FINDINGS: %-40s │   ${HEADER_COLOR}║${NC}\n" "$findings_summary"
    printf "${HEADER_COLOR}║${NC}   │  Items to review: %-33d │   ${HEADER_COLOR}║${NC}\n" "$total_findings"
    echo -e "${HEADER_COLOR}║${NC}   └────────────────────────────────────────────────────┘   ${HEADER_COLOR}║${NC}"

    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}   SCAN RESULTS:                                            ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}   ────────────────────────────────────────────────────     ${HEADER_COLOR}║${NC}"

    # Results breakdown with counts (no subjective icons)
    printf "${HEADER_COLOR}║${NC}     ClamAV ................ %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[clamav]:-0} detected"
    printf "${HEADER_COLOR}║${NC}     YARA Windows .......... %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[yara_Windows]:-0} matches"
    printf "${HEADER_COLOR}║${NC}     YARA Linux ............ %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[yara_Linux]:-0} matches"
    printf "${HEADER_COLOR}║${NC}     String Patterns ....... %-28s ${HEADER_COLOR}║${NC}\n" "${RESULTS[strings]:-0} found"

    # Slack space results if applicable
    if [ "$SCAN_MODE" = "slack" ]; then
        printf "${HEADER_COLOR}║${NC}     Slack Space ........... %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[slack_size_mb]:-0} MB extracted"
        printf "${HEADER_COLOR}║${NC}     Files Recovered ....... %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[slack_files_recovered]:-0} files"
    fi

    # Deep scan results if applicable
    if [ "$DEEP_SCAN" = true ] || [ "$SCAN_MODE" = "slack" ]; then
        printf "${HEADER_COLOR}║${NC}     High Entropy Regions .. %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[entropy_high_count]:-0} regions"
        printf "${HEADER_COLOR}║${NC}     Carved Executables .... %-28s ${HEADER_COLOR}║${NC}\n" "${STATS[carved_executables]:-${RESULTS[carved_files]:-0}} files"
    fi

    if [ "$SCAN_MODE" = "full" ] && [ "$DEEP_SCAN" = true ]; then
        local boot_status="Normal"
        [ "${RESULTS[boot_sector]:-0}" = "1" ] && boot_status="Review needed"
        printf "${HEADER_COLOR}║${NC}     Boot Sector ........... %-28s ${HEADER_COLOR}║${NC}\n" "$boot_status"
    fi

    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"
    printf "${HEADER_COLOR}║${NC}   Reports saved to: %-38s ${HEADER_COLOR}║${NC}\n" "$SCAN_OUTPUT_DIR"
    echo -e "${HEADER_COLOR}║${NC}                                                            ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╚$(printf '%*s' $((width-2)) | tr ' ' '═')╝${NC}"
}

# Clear the current line
clear_line() {
    printf "\r\033[K"
}

# Move cursor up N lines
move_cursor_up() {
    local n="${1:-1}"
    printf "\033[${n}A"
}

# ==========================================
# CONFIGURATION FILE SUPPORT
# ==========================================

load_config() {
    local config_file=""

    # Check for custom config file first
    if [ -n "$CUSTOM_CONFIG" ] && [ -f "$CUSTOM_CONFIG" ]; then
        config_file="$CUSTOM_CONFIG"
    else
        # Search default locations
        for loc in "${CONFIG_LOCATIONS[@]}"; do
            if [ -f "$loc" ]; then
                config_file="$loc"
                break
            fi
        done
    fi

    if [ -n "$config_file" ]; then
        log "DEBUG" "Loading configuration from: $config_file"

        # Source config file safely (only known variables)
        while IFS='=' read -r key value; do
            # Skip comments and empty lines
            [[ "$key" =~ ^[[:space:]]*# ]] && continue
            [[ -z "$key" ]] && continue

            # Remove leading/trailing whitespace and quotes
            key=$(echo "$key" | xargs)
            value=$(echo "$value" | xargs | sed 's/^["'"'"']//;s/["'"'"']$//')

            case "$key" in
                CLAMDB_DIR)       CLAMDB_DIR="$value" ;;
                CHUNK_SIZE)       CHUNK_SIZE="$value" ;;
                YARA_RULES_BASE)  YARA_RULES_BASE="$value" ;;
                OLEDUMP_RULES)    OLEDUMP_RULES="$value" ;;
                VT_API_KEY)       VT_API_KEY="$value" ;;
                VT_RATE_LIMIT)    VT_RATE_LIMIT="$value" ;;
                MAX_PARALLEL_JOBS) MAX_PARALLEL_JOBS="$value" ;;
                LOG_LEVEL)        LOG_LEVEL="$value" ;;
                YARA_CACHE_DIR)   YARA_CACHE_DIR="$value" ;;
                PORTABLE_TOOLS_DIR) PORTABLE_TOOLS_DIR="$value" ;;
                YARA_VERSION)     YARA_VERSION="$value" ;;
                CLAMAV_VERSION)   CLAMAV_VERSION="$value" ;;
                # EWF/Forensic image options
                EWF_SUPPORT)      EWF_SUPPORT="$value" ;;
                EWF_VERIFY_HASH)  [ "$value" = "true" ] && VERIFY_EWF_HASH=true ;;
                EWF_MOUNT_OPTIONS) EWF_MOUNT_OPTIONS="$value" ;;
                TEMP_MOUNT_BASE)  TEMP_MOUNT_BASE="$value" ;;
                # Display options
                NO_COLOR)         [ "$value" = "true" ] && NO_COLOR=true ;;
                HIGH_CONTRAST)    [ "$value" = "true" ] && HIGH_CONTRAST=true ;;
                # Forensic analysis options
                FORENSIC_ANALYSIS) [ "$value" = "true" ] && FORENSIC_ANALYSIS=true ;;
                PERSISTENCE_SCAN)  [ "$value" = "true" ] && DO_PERSISTENCE_SCAN=true ;;
                EXECUTION_SCAN)    [ "$value" = "true" ] && DO_EXECUTION_SCAN=true ;;
                FILE_ANOMALIES)    [ "$value" = "true" ] && DO_FILE_ANOMALIES=true ;;
                RE_TRIAGE)         [ "$value" = "true" ] && DO_RE_TRIAGE=true ;;
                MFT_ANALYSIS)      [ "$value" = "true" ] && DO_MFT_ANALYSIS=true ;;
                REGRIPPER_PATH)    REGRIPPER_PATH="$value" ;;
                CAPA_PATH)         CAPA_PATH="$value" ;;
            esac
        done < "$config_file"

        print_status "Loaded configuration from: $config_file"
    fi
}

# ==========================================
# PORTABLE TOOLS SETUP
# ==========================================

detect_architecture() {
    local arch=$(uname -m)
    case "$arch" in
        x86_64|amd64)   echo "x86_64" ;;
        aarch64|arm64)  echo "aarch64" ;;
        armv7l|armhf)   echo "armv7" ;;
        i686|i386)      echo "i686" ;;
        *)              echo "$arch" ;;
    esac
}

setup_portable_environment() {
    print_section "Setting Up Portable Tools Environment"

    local arch=$(detect_architecture)
    log "DEBUG" "Detected architecture: $arch"

    # Create directory structure
    mkdir -p "$PORTABLE_TOOLS_DIR"/{bin,lib,share,python}

    # Export environment variables for portable tools
    export PATH="$PORTABLE_TOOLS_DIR/bin:$PATH"
    export LD_LIBRARY_PATH="$PORTABLE_TOOLS_DIR/lib:${LD_LIBRARY_PATH:-}"
    export PYTHONUSERBASE="$PORTABLE_TOOLS_DIR/python"

    print_status "Portable tools directory: $PORTABLE_TOOLS_DIR"
    print_status "Architecture: $arch"

    return 0
}

download_file() {
    local url="$1"
    local output="$2"
    local description="${3:-file}"

    log "DEBUG" "Downloading $description from: $url"

    if command -v curl &> /dev/null; then
        if curl -fsSL --connect-timeout 30 --max-time 300 -o "$output" "$url" 2>/dev/null; then
            return 0
        fi
    elif command -v wget &> /dev/null; then
        if wget -q --timeout=30 -O "$output" "$url" 2>/dev/null; then
            return 0
        fi
    else
        print_error "Neither curl nor wget available for downloads"
        return 1
    fi

    print_error "Failed to download: $description"
    return 1
}

install_yara_portable() {
    print_status "Installing YARA (portable)..."

    local arch=$(detect_architecture)
    local yara_dir="$PORTABLE_TOOLS_DIR/yara"
    mkdir -p "$yara_dir"

    # Try to download pre-built YARA binary
    # Using GitHub releases for VirusTotal/yara
    local yara_url=""

    case "$arch" in
        x86_64)
            # Try downloading from GitHub releases
            yara_url="https://github.com/VirusTotal/yara/releases/download/v${YARA_VERSION}/yara-${YARA_VERSION}-linux64.tar.gz"
            ;;
        *)
            print_warning "No pre-built YARA binary for $arch, attempting to build from source..."
            install_yara_from_source
            return $?
            ;;
    esac

    local tarball="$PORTABLE_TOOLS_DIR/yara.tar.gz"

    if download_file "$yara_url" "$tarball" "YARA ${YARA_VERSION}"; then
        if tar -xzf "$tarball" -C "$yara_dir" 2>/dev/null; then
            # Find and copy binaries
            find "$yara_dir" -name "yara" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
            find "$yara_dir" -name "yarac" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
            chmod +x "$PORTABLE_TOOLS_DIR/bin/yara" "$PORTABLE_TOOLS_DIR/bin/yarac" 2>/dev/null

            if [ -x "$PORTABLE_TOOLS_DIR/bin/yara" ]; then
                print_success "YARA installed successfully"
                rm -f "$tarball"
                return 0
            fi
        fi
    fi

    # Fallback: try building from source
    print_warning "Pre-built binary failed, attempting source build..."
    install_yara_from_source
}

install_yara_from_source() {
    local src_dir="$PORTABLE_TOOLS_DIR/src/yara"
    mkdir -p "$src_dir"

    local src_url="https://github.com/VirusTotal/yara/archive/refs/tags/v${YARA_VERSION}.tar.gz"
    local tarball="$PORTABLE_TOOLS_DIR/yara-src.tar.gz"

    if ! download_file "$src_url" "$tarball" "YARA source"; then
        return 1
    fi

    if ! tar -xzf "$tarball" -C "$src_dir" --strip-components=1 2>/dev/null; then
        print_error "Failed to extract YARA source"
        return 1
    fi

    # Check for build dependencies
    if ! command -v gcc &> /dev/null || ! command -v make &> /dev/null; then
        print_error "Build tools (gcc, make) required for source compilation"
        return 1
    fi

    print_status "Building YARA from source (this may take a while)..."

    cd "$src_dir" || return 1

    if [ -f "bootstrap.sh" ]; then
        ./bootstrap.sh > /dev/null 2>&1 || true
    fi

    if [ -f "configure" ]; then
        ./configure --prefix="$PORTABLE_TOOLS_DIR" --disable-shared > /dev/null 2>&1 && \
        make -j$(nproc 2>/dev/null || echo 2) > /dev/null 2>&1 && \
        make install > /dev/null 2>&1
    else
        # Try direct compilation
        gcc -O2 -o "$PORTABLE_TOOLS_DIR/bin/yara" libyara/*.c cli/yara.c \
            -Ilibyara/include -lpthread -lm 2>/dev/null || return 1
    fi

    cd - > /dev/null || true
    rm -f "$tarball"

    if [ -x "$PORTABLE_TOOLS_DIR/bin/yara" ]; then
        print_success "YARA built and installed successfully"
        return 0
    fi

    print_error "Failed to build YARA from source"
    return 1
}

install_clamav_portable() {
    print_status "Installing ClamAV (portable)..."

    local arch=$(detect_architecture)
    local clam_dir="$PORTABLE_TOOLS_DIR/clamav"
    mkdir -p "$clam_dir"

    # ClamAV provides portable builds
    local clam_url=""

    case "$arch" in
        x86_64)
            clam_url="https://www.clamav.net/downloads/production/clamav-${CLAMAV_VERSION}.linux.x86_64.tar.gz"
            ;;
        aarch64)
            clam_url="https://www.clamav.net/downloads/production/clamav-${CLAMAV_VERSION}.linux.aarch64.tar.gz"
            ;;
        *)
            print_warning "No pre-built ClamAV for $arch"
            return 1
            ;;
    esac

    local tarball="$PORTABLE_TOOLS_DIR/clamav.tar.gz"

    if download_file "$clam_url" "$tarball" "ClamAV ${CLAMAV_VERSION}"; then
        if tar -xzf "$tarball" -C "$clam_dir" --strip-components=1 2>/dev/null; then
            # Copy binaries
            cp "$clam_dir"/bin/* "$PORTABLE_TOOLS_DIR/bin/" 2>/dev/null || true
            cp -r "$clam_dir"/lib/* "$PORTABLE_TOOLS_DIR/lib/" 2>/dev/null || true

            chmod +x "$PORTABLE_TOOLS_DIR/bin/clamscan" "$PORTABLE_TOOLS_DIR/bin/freshclam" 2>/dev/null

            if [ -x "$PORTABLE_TOOLS_DIR/bin/clamscan" ]; then
                print_success "ClamAV installed successfully"
                rm -f "$tarball"

                # Update CLAMDB_DIR to portable location
                CLAMDB_DIR="$PORTABLE_TOOLS_DIR/share/clamav"
                mkdir -p "$CLAMDB_DIR"

                return 0
            fi
        fi
    fi

    print_error "Failed to install ClamAV"
    return 1
}

install_binwalk_portable() {
    print_status "Installing binwalk (portable via pip)..."

    # Check if python3 and pip are available
    if ! command -v python3 &> /dev/null; then
        print_error "Python3 required for binwalk installation"
        return 1
    fi

    local pip_cmd=""
    if command -v pip3 &> /dev/null; then
        pip_cmd="pip3"
    elif python3 -m pip --version &> /dev/null; then
        pip_cmd="python3 -m pip"
    else
        print_error "pip not available for Python package installation"
        return 1
    fi

    # Install binwalk to user directory
    if $pip_cmd install --user --target="$PORTABLE_TOOLS_DIR/python" binwalk > /dev/null 2>&1; then
        # Create wrapper script
        cat > "$PORTABLE_TOOLS_DIR/bin/binwalk" << 'WRAPPER_EOF'
#!/bin/bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
export PYTHONPATH="$SCRIPT_DIR/python:$PYTHONPATH"
exec python3 -m binwalk "$@"
WRAPPER_EOF
        chmod +x "$PORTABLE_TOOLS_DIR/bin/binwalk"

        if "$PORTABLE_TOOLS_DIR/bin/binwalk" --help > /dev/null 2>&1; then
            print_success "binwalk installed successfully"
            return 0
        fi
    fi

    print_error "Failed to install binwalk"
    return 1
}

install_strings_portable() {
    print_status "Installing strings (portable)..."

    # strings is part of binutils, usually always present
    # If missing, we can create a simple Python replacement

    cat > "$PORTABLE_TOOLS_DIR/bin/strings" << 'STRINGS_EOF'
#!/usr/bin/env python3
"""Portable strings implementation for extracting printable strings from files."""
import sys
import re

def extract_strings(filename, min_length=4):
    """Extract printable ASCII strings from a file."""
    pattern = rb'[\x20-\x7e]{' + str(min_length).encode() + rb',}'
    try:
        if filename == '-':
            data = sys.stdin.buffer.read()
        else:
            with open(filename, 'rb') as f:
                data = f.read()
        for match in re.finditer(pattern, data):
            print(match.group().decode('ascii', errors='ignore'))
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1
    return 0

if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(description='Extract printable strings from files')
    parser.add_argument('files', nargs='*', default=['-'], help='Files to process')
    parser.add_argument('-n', type=int, default=4, help='Minimum string length')
    args = parser.parse_args()

    for f in args.files:
        extract_strings(f, args.n)
STRINGS_EOF

    chmod +x "$PORTABLE_TOOLS_DIR/bin/strings"
    print_success "strings (Python implementation) installed"
    return 0
}

install_foremost_portable() {
    print_status "Installing foremost (portable)..."

    local arch=$(detect_architecture)

    # Try to download AppImage or static binary
    # Foremost doesn't have official portable builds, so we'll try to compile

    if ! command -v gcc &> /dev/null; then
        print_warning "gcc required for foremost compilation"
        return 1
    fi

    local src_url="https://github.com/korczis/foremost/archive/refs/heads/master.tar.gz"
    local src_dir="$PORTABLE_TOOLS_DIR/src/foremost"
    local tarball="$PORTABLE_TOOLS_DIR/foremost-src.tar.gz"

    mkdir -p "$src_dir"

    if download_file "$src_url" "$tarball" "foremost source"; then
        if tar -xzf "$tarball" -C "$src_dir" --strip-components=1 2>/dev/null; then
            cd "$src_dir" || return 1

            # Compile foremost
            if make -j$(nproc 2>/dev/null || echo 2) > /dev/null 2>&1; then
                cp foremost "$PORTABLE_TOOLS_DIR/bin/" 2>/dev/null
                cp foremost.conf "$PORTABLE_TOOLS_DIR/share/" 2>/dev/null || true
                chmod +x "$PORTABLE_TOOLS_DIR/bin/foremost"

                cd - > /dev/null || true
                rm -f "$tarball"

                if [ -x "$PORTABLE_TOOLS_DIR/bin/foremost" ]; then
                    print_success "foremost built and installed successfully"
                    return 0
                fi
            fi

            cd - > /dev/null || true
        fi
    fi

    print_warning "Could not install foremost (optional tool)"
    return 1
}

install_ssdeep_portable() {
    print_status "Installing ssdeep (portable)..."

    if ! command -v gcc &> /dev/null; then
        print_warning "gcc required for ssdeep compilation"
        return 1
    fi

    local src_url="https://github.com/ssdeep-project/ssdeep/releases/download/release-2.14.1/ssdeep-2.14.1.tar.gz"
    local src_dir="$PORTABLE_TOOLS_DIR/src/ssdeep"
    local tarball="$PORTABLE_TOOLS_DIR/ssdeep-src.tar.gz"

    mkdir -p "$src_dir"

    if download_file "$src_url" "$tarball" "ssdeep source"; then
        if tar -xzf "$tarball" -C "$src_dir" --strip-components=1 2>/dev/null; then
            cd "$src_dir" || return 1

            if ./configure --prefix="$PORTABLE_TOOLS_DIR" > /dev/null 2>&1 && \
               make -j$(nproc 2>/dev/null || echo 2) > /dev/null 2>&1 && \
               make install > /dev/null 2>&1; then

                cd - > /dev/null || true
                rm -f "$tarball"

                if [ -x "$PORTABLE_TOOLS_DIR/bin/ssdeep" ]; then
                    print_success "ssdeep built and installed successfully"
                    return 0
                fi
            fi

            cd - > /dev/null || true
        fi
    fi

    print_warning "Could not install ssdeep (optional tool)"
    return 1
}

install_exiftool_portable() {
    print_status "Installing exiftool (portable)..."

    # ExifTool is a Perl script, very portable
    local exif_url="https://exiftool.org/Image-ExifTool-12.76.tar.gz"
    local exif_dir="$PORTABLE_TOOLS_DIR/exiftool"
    local tarball="$PORTABLE_TOOLS_DIR/exiftool.tar.gz"

    mkdir -p "$exif_dir"

    if ! command -v perl &> /dev/null; then
        print_warning "Perl required for exiftool"
        return 1
    fi

    if download_file "$exif_url" "$tarball" "exiftool"; then
        if tar -xzf "$tarball" -C "$exif_dir" --strip-components=1 2>/dev/null; then
            # Create wrapper
            cat > "$PORTABLE_TOOLS_DIR/bin/exiftool" << EXIF_WRAPPER
#!/bin/bash
exec perl "$exif_dir/exiftool" "\$@"
EXIF_WRAPPER
            chmod +x "$PORTABLE_TOOLS_DIR/bin/exiftool"

            rm -f "$tarball"

            if "$PORTABLE_TOOLS_DIR/bin/exiftool" -ver > /dev/null 2>&1; then
                print_success "exiftool installed successfully"
                return 0
            fi
        fi
    fi

    print_warning "Could not install exiftool (optional tool)"
    return 1
}

install_md5deep_portable() {
    print_status "Installing md5deep/hashdeep (portable)..."

    # Create a Python-based replacement for md5deep
    cat > "$PORTABLE_TOOLS_DIR/bin/md5deep" << 'MD5DEEP_EOF'
#!/usr/bin/env python3
"""Portable md5deep implementation for recursive file hashing."""
import hashlib
import os
import sys

def hash_file(filepath):
    """Calculate MD5 hash of a file."""
    md5 = hashlib.md5()
    try:
        with open(filepath, 'rb') as f:
            for chunk in iter(lambda: f.read(8192), b''):
                md5.update(chunk)
        return md5.hexdigest()
    except (IOError, PermissionError):
        return None

def process_path(path, recursive=False):
    """Process a path, optionally recursively."""
    if os.path.isfile(path):
        h = hash_file(path)
        if h:
            print(f"{h}  {path}")
    elif os.path.isdir(path) and recursive:
        for root, dirs, files in os.walk(path):
            for name in files:
                filepath = os.path.join(root, name)
                h = hash_file(filepath)
                if h:
                    print(f"{h}  {filepath}")

if __name__ == '__main__':
    recursive = '-r' in sys.argv
    paths = [arg for arg in sys.argv[1:] if arg != '-r']
    if not paths:
        paths = ['.']
    for path in paths:
        process_path(path, recursive)
MD5DEEP_EOF

    chmod +x "$PORTABLE_TOOLS_DIR/bin/md5deep"
    print_success "md5deep (Python implementation) installed"
    return 0
}

install_bulk_extractor_portable() {
    print_status "Installing bulk_extractor (portable)..."

    local arch=$(detect_architecture)

    # bulk_extractor has complex dependencies, try pre-built
    local be_url=""

    case "$arch" in
        x86_64)
            # Try GitHub releases
            be_url="https://github.com/simsong/bulk_extractor/releases/download/v2.0.0/bulk_extractor-2.0.0-linux.tar.gz"
            ;;
        *)
            print_warning "No pre-built bulk_extractor for $arch"
            return 1
            ;;
    esac

    local tarball="$PORTABLE_TOOLS_DIR/bulk_extractor.tar.gz"
    local be_dir="$PORTABLE_TOOLS_DIR/bulk_extractor"

    mkdir -p "$be_dir"

    if download_file "$be_url" "$tarball" "bulk_extractor"; then
        if tar -xzf "$tarball" -C "$be_dir" --strip-components=1 2>/dev/null; then
            find "$be_dir" -name "bulk_extractor" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
            chmod +x "$PORTABLE_TOOLS_DIR/bin/bulk_extractor" 2>/dev/null

            rm -f "$tarball"

            if [ -x "$PORTABLE_TOOLS_DIR/bin/bulk_extractor" ]; then
                print_success "bulk_extractor installed successfully"
                return 0
            fi
        fi
    fi

    print_warning "Could not install bulk_extractor (optional tool)"
    return 1
}

# ==========================================
# FORENSIC TOOLS PORTABLE INSTALLERS
# ==========================================

install_regripper_portable() {
    print_status "Installing RegRipper (portable)..."

    local regripper_dir="$PORTABLE_TOOLS_DIR/regripper"
    mkdir -p "$regripper_dir"

    # Check if Perl is available (required for RegRipper)
    if ! command -v perl &> /dev/null; then
        print_error "Perl is required for RegRipper but not installed"
        print_status "Install Perl with: sudo apt install perl libparse-win32registry-perl"
        return 1
    fi

    # Clone RegRipper from GitHub
    local regripper_url="https://github.com/keydet89/RegRipper3.0/archive/refs/heads/master.tar.gz"
    local tarball="$PORTABLE_TOOLS_DIR/regripper.tar.gz"

    if download_file "$regripper_url" "$tarball" "RegRipper 3.0"; then
        if tar -xzf "$tarball" -C "$regripper_dir" --strip-components=1 2>/dev/null; then
            rm -f "$tarball"

            # Create wrapper script
            cat > "$PORTABLE_TOOLS_DIR/bin/rip.pl" << 'RIPWRAPPER'
#!/bin/bash
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/../regripper" && pwd)"
perl "$SCRIPT_DIR/rip.pl" "$@"
RIPWRAPPER
            chmod +x "$PORTABLE_TOOLS_DIR/bin/rip.pl"

            # Verify installation
            if [ -f "$regripper_dir/rip.pl" ]; then
                REGRIPPER_PATH="$regripper_dir/rip.pl"
                print_success "RegRipper installed successfully"

                # Check for required Perl modules
                if ! perl -MParse::Win32Registry -e 1 2>/dev/null; then
                    print_warning "Perl module Parse::Win32Registry not found"
                    print_status "Install with: sudo cpan Parse::Win32Registry"
                    print_status "Or: sudo apt install libparse-win32registry-perl"
                fi

                return 0
            fi
        fi
    fi

    print_warning "Could not install RegRipper"
    return 1
}

install_capa_portable() {
    print_status "Installing capa (portable)..."

    local arch=$(detect_architecture)
    local capa_url=""
    local capa_version="7.1.0"  # Update as needed

    case "$arch" in
        x86_64)
            capa_url="https://github.com/mandiant/capa/releases/download/v${capa_version}/capa-v${capa_version}-linux.zip"
            ;;
        aarch64)
            print_warning "capa does not have official ARM64 builds, skipping"
            return 1
            ;;
        *)
            print_warning "No pre-built capa for $arch"
            return 1
            ;;
    esac

    local zipfile="$PORTABLE_TOOLS_DIR/capa.zip"
    local capa_dir="$PORTABLE_TOOLS_DIR/capa"

    mkdir -p "$capa_dir"

    if download_file "$capa_url" "$zipfile" "capa ${capa_version}"; then
        if command -v unzip &> /dev/null; then
            if unzip -q -o "$zipfile" -d "$capa_dir" 2>/dev/null; then
                # Find and copy the binary
                find "$capa_dir" -name "capa" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
                chmod +x "$PORTABLE_TOOLS_DIR/bin/capa" 2>/dev/null

                rm -f "$zipfile"

                if [ -x "$PORTABLE_TOOLS_DIR/bin/capa" ]; then
                    CAPA_PATH="$PORTABLE_TOOLS_DIR/bin/capa"
                    print_success "capa installed successfully"

                    # Download capa rules
                    print_status "Downloading capa rules..."
                    local rules_url="https://github.com/mandiant/capa-rules/archive/refs/heads/master.tar.gz"
                    local rules_tarball="$PORTABLE_TOOLS_DIR/capa-rules.tar.gz"

                    if download_file "$rules_url" "$rules_tarball" "capa rules"; then
                        mkdir -p "$capa_dir/rules"
                        tar -xzf "$rules_tarball" -C "$capa_dir/rules" --strip-components=1 2>/dev/null
                        rm -f "$rules_tarball"
                        print_success "capa rules downloaded"
                    fi

                    return 0
                fi
            fi
        else
            print_warning "unzip required for capa installation"
        fi
    fi

    print_warning "Could not install capa (optional for RE triage)"
    return 1
}

install_radare2_portable() {
    print_status "Installing radare2 (portable)..."

    local arch=$(detect_architecture)
    local r2_version="5.9.0"  # Update as needed

    # radare2 provides portable tarballs
    local r2_url=""

    case "$arch" in
        x86_64)
            r2_url="https://github.com/radareorg/radare2/releases/download/${r2_version}/radare2-${r2_version}-linux-x86_64.tar.gz"
            ;;
        aarch64)
            r2_url="https://github.com/radareorg/radare2/releases/download/${r2_version}/radare2-${r2_version}-linux-arm64.tar.gz"
            ;;
        *)
            print_warning "No pre-built radare2 for $arch"
            return 1
            ;;
    esac

    local tarball="$PORTABLE_TOOLS_DIR/radare2.tar.gz"
    local r2_dir="$PORTABLE_TOOLS_DIR/radare2"

    mkdir -p "$r2_dir"

    if download_file "$r2_url" "$tarball" "radare2 ${r2_version}"; then
        if tar -xzf "$tarball" -C "$r2_dir" --strip-components=1 2>/dev/null; then
            # Copy binaries
            if [ -d "$r2_dir/bin" ]; then
                cp "$r2_dir/bin/"* "$PORTABLE_TOOLS_DIR/bin/" 2>/dev/null || true
            else
                find "$r2_dir" -name "r2" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
                find "$r2_dir" -name "rabin2" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
                find "$r2_dir" -name "rahash2" -type f -exec cp {} "$PORTABLE_TOOLS_DIR/bin/" \; 2>/dev/null
            fi

            chmod +x "$PORTABLE_TOOLS_DIR/bin/r2" "$PORTABLE_TOOLS_DIR/bin/rabin2" 2>/dev/null

            rm -f "$tarball"

            if [ -x "$PORTABLE_TOOLS_DIR/bin/rabin2" ]; then
                RADARE2_PATH="$PORTABLE_TOOLS_DIR/bin"
                print_success "radare2 installed successfully"
                return 0
            fi
        fi
    fi

    print_warning "Could not install radare2 (optional for RE triage)"
    return 1
}

install_python_forensic_tools() {
    print_status "Installing Python forensic tools..."

    # Check if python3 and pip are available
    if ! command -v python3 &> /dev/null; then
        print_error "Python3 required for forensic tools"
        return 1
    fi

    local pip_cmd=""
    if command -v pip3 &> /dev/null; then
        pip_cmd="pip3"
    elif python3 -m pip --version &> /dev/null; then
        pip_cmd="python3 -m pip"
    else
        print_warning "pip not available for Python forensic tools"
        return 1
    fi

    # Install forensic Python packages
    local packages=("pefile" "python-registry" "prefetch-parser" "yara-python")
    local failed=0

    for pkg in "${packages[@]}"; do
        print_status "Installing $pkg..."
        if $pip_cmd install --user --quiet "$pkg" 2>/dev/null; then
            log "DEBUG" "Installed $pkg successfully"
        else
            log "DEBUG" "Failed to install $pkg"
            ((failed++))
        fi
    done

    if [ $failed -lt ${#packages[@]} ]; then
        print_success "Python forensic tools installed (${failed} packages failed)"
        return 0
    fi

    print_warning "Could not install Python forensic tools"
    return 1
}

install_behavioral_yara_rules() {
    print_status "Downloading behavioral YARA rules..."

    local rules_dir="$PORTABLE_TOOLS_DIR/yara-rules"
    mkdir -p "$rules_dir"

    # Download signature-base rules (Neo23x0)
    local sig_base_url="https://github.com/Neo23x0/signature-base/archive/refs/heads/master.tar.gz"
    local sig_tarball="$PORTABLE_TOOLS_DIR/signature-base.tar.gz"

    if download_file "$sig_base_url" "$sig_tarball" "signature-base YARA rules"; then
        mkdir -p "$rules_dir/signature-base"
        tar -xzf "$sig_tarball" -C "$rules_dir/signature-base" --strip-components=1 2>/dev/null
        rm -f "$sig_tarball"
        print_success "signature-base rules downloaded"
    fi

    # Download YARA-Rules community rules
    local community_url="https://github.com/Yara-Rules/rules/archive/refs/heads/master.tar.gz"
    local community_tarball="$PORTABLE_TOOLS_DIR/yara-rules-community.tar.gz"

    if download_file "$community_url" "$community_tarball" "YARA community rules"; then
        mkdir -p "$rules_dir/community"
        tar -xzf "$community_tarball" -C "$rules_dir/community" --strip-components=1 2>/dev/null
        rm -f "$community_tarball"
        print_success "YARA community rules downloaded"
    fi

    return 0
}

setup_forensic_tools() {
    # Check if forensic analysis is enabled
    if [ "$FORENSIC_ANALYSIS" != true ] && [ "$DO_PERSISTENCE_SCAN" != true ] && \
       [ "$DO_EXECUTION_SCAN" != true ] && [ "$DO_FILE_ANOMALIES" != true ] && \
       [ "$DO_RE_TRIAGE" != true ] && [ "$DO_MFT_ANALYSIS" != true ]; then
        return 0
    fi

    print_section "Setting Up Forensic Analysis Tools"

    local -a missing_forensic=()

    # Check for required forensic tools based on enabled scans
    if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_PERSISTENCE_SCAN" = true ]; then
        if [ -z "$REGRIPPER_PATH" ] && ! command -v rip.pl &> /dev/null; then
            missing_forensic+=("regripper")
        fi
    fi

    if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_RE_TRIAGE" = true ]; then
        if [ -z "$CAPA_PATH" ] && ! command -v capa &> /dev/null; then
            missing_forensic+=("capa")
        fi
        if [ -z "$RADARE2_PATH" ] && ! command -v rabin2 &> /dev/null; then
            missing_forensic+=("radare2")
        fi
    fi

    if [ ${#missing_forensic[@]} -eq 0 ]; then
        print_success "All required forensic tools are available"
        return 0
    fi

    print_status "Missing forensic tools: ${missing_forensic[*]}"

    if [ "$PORTABLE_MODE" != true ]; then
        print_warning "Run with --portable to auto-download forensic tools"
        return 1
    fi

    # Install missing forensic tools
    for tool in "${missing_forensic[@]}"; do
        case "$tool" in
            regripper)
                install_regripper_portable || true
                ;;
            capa)
                install_capa_portable || true
                ;;
            radare2)
                install_radare2_portable || true
                ;;
        esac
    done

    # Install Python forensic tools
    install_python_forensic_tools || true

    # Download behavioral YARA rules
    install_behavioral_yara_rules || true

    return 0
}

setup_portable_tools() {
    local -a missing_basic=()
    local -a missing_deep=()

    # Check which basic tools are missing
    local basic_tools=("clamscan" "yara" "strings" "binwalk")
    local deep_tools=("foremost" "ssdeep" "exiftool" "md5deep" "bulk_extractor")

    for tool in "${basic_tools[@]}"; do
        if ! command -v "$tool" &> /dev/null; then
            missing_basic+=("$tool")
        fi
    done

    if [ "$DEEP_SCAN" = true ]; then
        for tool in "${deep_tools[@]}"; do
            if ! command -v "$tool" &> /dev/null; then
                missing_deep+=("$tool")
            fi
        done
    fi

    # If no tools missing, return early
    if [ ${#missing_basic[@]} -eq 0 ] && [ ${#missing_deep[@]} -eq 0 ]; then
        print_success "All required tools are available system-wide"
        return 0
    fi

    print_status "Missing tools detected. Setting up portable environment..."
    print_status "Missing basic tools: ${missing_basic[*]:-none}"
    [ "$DEEP_SCAN" = true ] && print_status "Missing deep scan tools: ${missing_deep[*]:-none}"

    # Setup the environment
    setup_portable_environment

    local failed=0

    # Install missing basic tools
    for tool in "${missing_basic[@]}"; do
        case "$tool" in
            clamscan)
                install_clamav_portable || ((failed++))
                ;;
            yara)
                install_yara_portable || ((failed++))
                ;;
            strings)
                install_strings_portable || ((failed++))
                ;;
            binwalk)
                install_binwalk_portable || ((failed++))
                ;;
        esac
    done

    # Install missing deep scan tools (optional, don't fail)
    if [ "$DEEP_SCAN" = true ]; then
        for tool in "${missing_deep[@]}"; do
            case "$tool" in
                foremost)
                    install_foremost_portable || true
                    ;;
                ssdeep)
                    install_ssdeep_portable || true
                    ;;
                exiftool)
                    install_exiftool_portable || true
                    ;;
                md5deep)
                    install_md5deep_portable || true
                    ;;
                bulk_extractor)
                    install_bulk_extractor_portable || true
                    ;;
            esac
        done
    fi

    # Verify critical tools were installed
    print_section "Portable Tools Verification"

    local verified=0
    for tool in clamscan yara strings binwalk; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool: $(command -v $tool)"
            ((verified++))
        else
            print_error "$tool: NOT AVAILABLE"
        fi
    done

    if [ $verified -lt 4 ]; then
        print_error "Some required tools could not be installed"
        print_status "You may need to install them manually or check network connectivity"
        return 1
    fi

    print_success "Portable environment ready"
    return 0
}

# ==========================================
# INPUT VALIDATION AND SECURITY
# ==========================================

# Detect input type based on path format and file extension
detect_input_type() {
    local input="$1"

    # Check for forced format first
    if [ -n "$FORCE_INPUT_FORMAT" ]; then
        case "$FORCE_INPUT_FORMAT" in
            block|device) echo "block_device"; return 0 ;;
            ewf)          echo "ewf"; return 0 ;;
            raw)          echo "raw_image"; return 0 ;;
            auto)         ;; # Fall through to auto-detection
            *)
                print_error "Unknown input format: $FORCE_INPUT_FORMAT"
                return 1
                ;;
        esac
    fi

    # Auto-detect based on path format
    if [[ "$input" =~ ^/dev/ ]]; then
        echo "block_device"
        return 0
    fi

    # Check file extension for EWF formats
    # Supports: .E01-.E99, .Ex01, .L01-.L99, .Lx01
    local lower_input=$(echo "$input" | tr '[:upper:]' '[:lower:]')
    if [[ "$lower_input" =~ \.(e[0-9]{2}|ex[0-9]{2}|l[0-9]{2}|lx[0-9]{2})$ ]]; then
        echo "ewf"
        return 0
    fi

    # Check for raw image extensions
    if [[ "$lower_input" =~ \.(raw|dd|img|bin)$ ]]; then
        echo "raw_image"
        return 0
    fi

    # Try to detect by file magic if file exists
    if [ -f "$input" ]; then
        local file_type=$(file -b "$input" 2>/dev/null | head -1)
        if [[ "$file_type" =~ "EWF/Expert Witness" ]] || [[ "$file_type" =~ "EnCase" ]]; then
            echo "ewf"
            return 0
        fi
    fi

    echo "unknown"
    return 0
}

# Check if EWF tools are available
check_ewf_tools() {
    if ! command -v ewfmount &> /dev/null; then
        print_error "ewfmount not found. Please install libewf-tools:"
        print_error "  sudo apt install libewf-tools"
        return 1
    fi
    if ! command -v ewfinfo &> /dev/null; then
        print_warning "ewfinfo not found - EWF metadata extraction will be limited"
    fi
    return 0
}

# Validate EWF input file
validate_ewf_input() {
    local input="$1"

    # Check if first segment file exists
    if [ ! -f "$input" ]; then
        print_error "EWF image not found: $input"
        return 1
    fi

    # Check if readable
    if [ ! -r "$input" ]; then
        print_error "Cannot read EWF image: $input (permission denied)"
        return 1
    fi

    # Find all segments in the same directory
    local base_dir=$(dirname "$input")
    local base_name=$(basename "$input")
    # Extract base name without extension (e.g., "image" from "image.E01")
    local name_without_ext="${base_name%.[EeLl]*[0-9][0-9]}"

    # Find all segment files
    EWF_SEGMENTS=()
    while IFS= read -r -d '' segment; do
        EWF_SEGMENTS+=("$segment")
    done < <(find "$base_dir" -maxdepth 1 -name "${name_without_ext}.[EeLl]*" -print0 2>/dev/null | sort -z)

    if [ ${#EWF_SEGMENTS[@]} -eq 0 ]; then
        # Fallback: just use the provided file
        EWF_SEGMENTS=("$input")
    fi

    local segment_count=${#EWF_SEGMENTS[@]}
    if [ "$segment_count" -gt 1 ]; then
        print_status "Found $segment_count EWF segments"
        log "DEBUG" "EWF segments: ${EWF_SEGMENTS[*]}"
    fi

    return 0
}

# Extract EWF image metadata using ewfinfo
get_ewf_info() {
    local input="$1"

    if ! command -v ewfinfo &> /dev/null; then
        log "DEBUG" "ewfinfo not available, skipping metadata extraction"
        return 0
    fi

    print_status "Extracting EWF image metadata..."

    local ewf_output
    ewf_output=$(ewfinfo "$input" 2>/dev/null) || {
        print_warning "Could not extract EWF metadata"
        return 0
    }

    # Parse ewfinfo output
    EWF_TOTAL_SIZE=$(echo "$ewf_output" | grep -i "Media size:" | awk '{print $3}' | head -1)
    EWF_HASH_MD5=$(echo "$ewf_output" | grep -i "MD5 hash:" | awk '{print $3}' | head -1)
    EWF_HASH_SHA1=$(echo "$ewf_output" | grep -i "SHA1 hash:" | awk '{print $3}' | head -1)
    EWF_ACQUISITION_DATE=$(echo "$ewf_output" | grep -i "Acquisition date:" | cut -d: -f2- | xargs)
    EWF_CASE_NUMBER=$(echo "$ewf_output" | grep -i "Case number:" | cut -d: -f2- | xargs)

    # Display info in a nice box
    if [ "$QUIET_MODE" != true ]; then
        draw_box "EWF Image Information" 60 "rounded"
        [ -n "$EWF_TOTAL_SIZE" ] && draw_box_line "Size: $EWF_TOTAL_SIZE" 60
        [ -n "$EWF_HASH_MD5" ] && draw_box_line "MD5:  $EWF_HASH_MD5" 60
        [ -n "$EWF_HASH_SHA1" ] && draw_box_line "SHA1: $EWF_HASH_SHA1" 60
        [ -n "$EWF_ACQUISITION_DATE" ] && draw_box_line "Acquired: $EWF_ACQUISITION_DATE" 60
        [ -n "$EWF_CASE_NUMBER" ] && draw_box_line "Case: $EWF_CASE_NUMBER" 60
        draw_box_end 60 "rounded"
    fi

    return 0
}

# Verify EWF hash integrity
verify_ewf_hash() {
    local input="$1"

    if ! command -v ewfverify &> /dev/null; then
        print_warning "ewfverify not found - cannot verify EWF hash"
        return 0
    fi

    print_section "EWF Hash Verification"
    print_status "Verifying EWF image integrity (this may take a while)..."

    # Run ewfverify with progress
    local verify_result
    if [ "$QUIET_MODE" = true ]; then
        verify_result=$(ewfverify -q "$input" 2>&1)
    else
        verify_result=$(ewfverify "$input" 2>&1)
    fi
    local verify_status=$?

    if [ $verify_status -eq 0 ]; then
        print_success "EWF hash verification PASSED - Image integrity confirmed"
        draw_status_line "success" "Evidence integrity verified"
        return 0
    else
        print_error "EWF hash verification FAILED - Image may be corrupted!"
        print_error "$verify_result"
        draw_status_line "error" "Evidence integrity check failed"
        return 1
    fi
}

# Mount EWF image and return virtual device path
mount_ewf_image() {
    local input="$1"

    # Create unique temp mount point
    TEMP_MOUNT_POINT="${TEMP_MOUNT_BASE}/malscan_ewf_$$"

    print_status "Mounting EWF image..."
    log "DEBUG" "Mount point: $TEMP_MOUNT_POINT"

    # Create mount point directory
    if ! mkdir -p "$TEMP_MOUNT_POINT"; then
        print_error "Failed to create mount point: $TEMP_MOUNT_POINT"
        return 1
    fi

    # Mount EWF using FUSE
    local mount_output
    mount_output=$(ewfmount "$input" "$TEMP_MOUNT_POINT" 2>&1)
    local mount_status=$?

    if [ $mount_status -ne 0 ]; then
        print_error "Failed to mount EWF image:"
        print_error "$mount_output"
        rmdir "$TEMP_MOUNT_POINT" 2>/dev/null
        return 1
    fi

    # Wait briefly for mount to complete
    sleep 1

    # Find the virtual device (usually ewf1)
    if [ -f "$TEMP_MOUNT_POINT/ewf1" ]; then
        ACTUAL_DEVICE="$TEMP_MOUNT_POINT/ewf1"
    elif [ -f "$TEMP_MOUNT_POINT/ewf" ]; then
        ACTUAL_DEVICE="$TEMP_MOUNT_POINT/ewf"
    else
        # Try to find any file in mount point
        ACTUAL_DEVICE=$(find "$TEMP_MOUNT_POINT" -type f -name "ewf*" 2>/dev/null | head -1)
        if [ -z "$ACTUAL_DEVICE" ]; then
            print_error "No virtual device found after mounting EWF"
            umount "$TEMP_MOUNT_POINT" 2>/dev/null || fusermount -u "$TEMP_MOUNT_POINT" 2>/dev/null
            rmdir "$TEMP_MOUNT_POINT" 2>/dev/null
            return 1
        fi
    fi

    IS_EWF_MOUNT=true
    print_success "EWF mounted successfully"
    draw_status_line "success" "Virtual device: $ACTUAL_DEVICE"

    return 0
}

# Unmount EWF image (called during cleanup)
unmount_ewf_image() {
    if [ "$IS_EWF_MOUNT" != true ]; then
        return 0
    fi

    if [ -z "$TEMP_MOUNT_POINT" ] || [ ! -d "$TEMP_MOUNT_POINT" ]; then
        return 0
    fi

    log "DEBUG" "Unmounting EWF image from: $TEMP_MOUNT_POINT"

    # Try umount first, then fusermount as fallback
    if ! umount "$TEMP_MOUNT_POINT" 2>/dev/null; then
        fusermount -u "$TEMP_MOUNT_POINT" 2>/dev/null || {
            print_warning "Could not unmount EWF image from $TEMP_MOUNT_POINT"
            return 1
        }
    fi

    # Remove mount point directory
    rmdir "$TEMP_MOUNT_POINT" 2>/dev/null || true

    IS_EWF_MOUNT=false
    TEMP_MOUNT_POINT=""

    log "DEBUG" "EWF image unmounted successfully"
    return 0
}

# Validate block device (original logic)
validate_block_device() {
    local device="$1"

    # Validate device path format (prevent command injection)
    if [[ ! "$device" =~ ^/dev/[a-zA-Z0-9_/-]+$ ]]; then
        print_error "Invalid device path format: $device"
        print_error "Device path must match /dev/[a-zA-Z0-9_/-]+"
        return 1
    fi

    # Check if device exists
    if [ ! -e "$device" ]; then
        print_error "Device does not exist: $device"
        return 1
    fi

    # Check if it's a block device
    if [ ! -b "$device" ]; then
        print_error "$device is not a block device"
        return 1
    fi

    # Check if device is readable
    if [ ! -r "$device" ]; then
        print_error "Cannot read device: $device (permission denied)"
        return 1
    fi

    return 0
}

# Main validation function - handles all input types
validate_device() {
    local input="$1"

    # Check if input is provided
    if [ -z "$input" ]; then
        print_error "No device or image specified"
        return 1
    fi

    # Store original input for display purposes
    ORIGINAL_INPUT="$input"

    # Detect input type
    INPUT_TYPE=$(detect_input_type "$input")
    log "DEBUG" "Detected input type: $INPUT_TYPE"

    case "$INPUT_TYPE" in
        block_device)
            # Original block device validation
            if ! validate_block_device "$input"; then
                return 1
            fi
            ACTUAL_DEVICE="$input"
            ;;

        ewf)
            # EWF forensic image
            if [ "$EWF_SUPPORT" != true ]; then
                print_error "EWF support is disabled"
                return 1
            fi

            # Check for EWF tools
            if ! check_ewf_tools; then
                return 1
            fi

            # Validate EWF input
            if ! validate_ewf_input "$input"; then
                return 1
            fi

            # Get EWF metadata
            get_ewf_info "$input"

            # Verify hash if requested
            if [ "$VERIFY_EWF_HASH" = true ]; then
                if ! verify_ewf_hash "$input"; then
                    print_error "Hash verification failed. Aborting scan."
                    return 1
                fi
            fi

            # Mount EWF image
            if ! mount_ewf_image "$input"; then
                return 1
            fi
            ;;

        raw_image)
            # Raw disk image - validate file exists and is readable
            if [ ! -f "$input" ]; then
                print_error "Raw image not found: $input"
                return 1
            fi
            if [ ! -r "$input" ]; then
                print_error "Cannot read raw image: $input (permission denied)"
                return 1
            fi
            ACTUAL_DEVICE="$input"
            print_status "Using raw disk image: $input"
            ;;

        unknown)
            print_error "Unable to determine input type: $input"
            print_error "Supported types: block device (/dev/*), EWF (.E01), raw image (.raw, .dd)"
            print_status "Tip: Use --input-format to force a specific type"
            return 1
            ;;

        *)
            print_error "Unsupported input type: $INPUT_TYPE"
            return 1
            ;;
    esac

    return 0
}

check_privileges() {
    if [ "$EUID" -ne 0 ]; then
        print_warning "Not running as root. Some operations may fail."
        print_warning "Consider running with sudo for full access."
        return 1
    fi
    return 0
}

check_disk_space() {
    local required_mb="$1"
    local target_dir="${2:-/tmp}"

    # Get available space in MB
    local available_mb=$(df -m "$target_dir" 2>/dev/null | awk 'NR==2 {print $4}')

    if [ -z "$available_mb" ]; then
        print_warning "Could not determine available disk space"
        return 0  # Continue anyway
    fi

    if [ "$available_mb" -lt "$required_mb" ]; then
        print_error "Insufficient disk space in $target_dir"
        print_error "Required: ${required_mb}MB, Available: ${available_mb}MB"
        return 1
    fi

    log "DEBUG" "Disk space check passed: ${available_mb}MB available, ${required_mb}MB required"
    return 0
}

# ==========================================
# WRAPPER FOR GRACEFUL ERROR HANDLING
# ==========================================

run_scan() {
    local scan_name="$1"
    local scan_function="$2"
    shift 2

    if [ "$DRY_RUN" = true ]; then
        print_status "[DRY-RUN] Would execute: $scan_name"
        SCAN_STATUS["$scan_name"]="skipped"
        return 0
    fi

    log "DEBUG" "Starting scan: $scan_name"

    # Run the scan function and capture exit status
    if "$scan_function" "$@"; then
        SCAN_STATUS["$scan_name"]="success"
        log "DEBUG" "Scan completed successfully: $scan_name"
        return 0
    else
        local exit_code=$?
        SCAN_STATUS["$scan_name"]="failed"
        print_warning "Scan encountered errors: $scan_name (exit code: $exit_code)"
        return $exit_code
    fi
}

# ==========================================
# PROGRESS INDICATOR
# ==========================================

show_progress() {
    local current="$1"
    local total="$2"
    local start_time="$3"
    local description="${4:-Processing}"

    if [ "$QUIET_MODE" = true ]; then
        return
    fi

    local percent=$((current * 100 / total))
    local elapsed=$(($(date +%s) - start_time))
    local eta="--:--"

    if [ $current -gt 0 ] && [ $elapsed -gt 0 ]; then
        local rate=$(echo "scale=2; $current / $elapsed" | bc 2>/dev/null || echo "0")
        if [ "$(echo "$rate > 0" | bc 2>/dev/null)" = "1" ]; then
            local remaining=$((total - current))
            local eta_secs=$(echo "scale=0; $remaining / $rate" | bc 2>/dev/null || echo "0")
            local eta_min=$((eta_secs / 60))
            local eta_sec=$((eta_secs % 60))
            eta=$(printf "%02d:%02d" $eta_min $eta_sec)
        fi
    fi

    # Create progress bar
    local bar_width=30
    local filled=$((percent * bar_width / 100))
    local empty=$((bar_width - filled))
    local bar=$(printf "%${filled}s" | tr ' ' '█')$(printf "%${empty}s" | tr ' ' '░')

    printf "\r${BLUE}[*]${NC} %s [%s] %3d%% ETA: %s" "$description" "$bar" "$percent" "$eta"
}

# ==========================================
# CHECKPOINT/RESUME CAPABILITY
# ==========================================

save_checkpoint() {
    if [ -z "$CHECKPOINT_FILE" ]; then
        CHECKPOINT_FILE="$SCAN_OUTPUT_DIR/.checkpoint"
    fi

    log "DEBUG" "Saving checkpoint to: $CHECKPOINT_FILE"

    {
        echo "# Malscan Checkpoint File"
        echo "# Generated: $(date)"
        echo "DEVICE=$DEVICE"
        echo "SCAN_OUTPUT_DIR=$SCAN_OUTPUT_DIR"
        echo "DEEP_SCAN=$DEEP_SCAN"
        echo "CURRENT_CHUNK=$CURRENT_CHUNK"
        echo "COMPLETED_SCANS=${!SCAN_STATUS[*]}"

        # Save results
        for key in "${!RESULTS[@]}"; do
            echo "RESULT_${key}=${RESULTS[$key]}"
        done

        # Save scan status
        for key in "${!SCAN_STATUS[@]}"; do
            echo "STATUS_${key}=${SCAN_STATUS[$key]}"
        done
    } > "$CHECKPOINT_FILE"
}

load_checkpoint() {
    local checkpoint_file="$1"

    if [ ! -f "$checkpoint_file" ]; then
        print_error "Checkpoint file not found: $checkpoint_file"
        return 1
    fi

    print_status "Loading checkpoint from: $checkpoint_file"

    while IFS='=' read -r key value; do
        [[ "$key" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$key" ]] && continue

        case "$key" in
            DEVICE)          DEVICE="$value" ;;
            SCAN_OUTPUT_DIR) SCAN_OUTPUT_DIR="$value" ;;
            DEEP_SCAN)       DEEP_SCAN="$value" ;;
            CURRENT_CHUNK)   RESUME_CHUNK="$value" ;;
            RESULT_*)        RESULTS["${key#RESULT_}"]="$value" ;;
            STATUS_*)        SCAN_STATUS["${key#STATUS_}"]="$value" ;;
        esac
    done < "$checkpoint_file"

    print_success "Checkpoint loaded. Resuming from chunk: ${RESUME_CHUNK:-0}"
    return 0
}

# ==========================================
# DYNAMIC CHUNK SIZE CALCULATION
# ==========================================

calculate_optimal_chunk_size() {
    # Get available memory in MB
    local available_mem=$(free -m 2>/dev/null | awk '/^Mem:/ {print $7}')

    if [ -z "$available_mem" ] || [ "$available_mem" -eq 0 ]; then
        log "DEBUG" "Could not determine available memory, using default chunk size"
        return
    fi

    # Use 25% of available memory, capped at 2GB
    local optimal=$((available_mem / 4))

    if [ $optimal -gt 2048 ]; then
        optimal=2048
    elif [ $optimal -lt 100 ]; then
        optimal=100  # Minimum chunk size
    fi

    CHUNK_SIZE=$optimal
    log "DEBUG" "Calculated optimal chunk size: ${CHUNK_SIZE}MB (based on ${available_mem}MB available)"
}

# ==========================================
# YARA RULE COMPILATION CACHING
# ==========================================

compile_yara_rules() {
    local rules_dir="$1"
    local category="$2"

    if ! command -v yarac &> /dev/null; then
        log "DEBUG" "yarac not available, using uncompiled rules"
        return 1
    fi

    mkdir -p "$YARA_CACHE_DIR"

    local cache_file="$YARA_CACHE_DIR/${category}.yarc"
    local rules_hash=$(find "$rules_dir" -name "*.yar*" -exec md5sum {} \; 2>/dev/null | md5sum | cut -d' ' -f1)
    local hash_file="$YARA_CACHE_DIR/${category}.hash"

    # Check if cache is valid
    if [ -f "$cache_file" ] && [ -f "$hash_file" ]; then
        local cached_hash=$(cat "$hash_file")
        if [ "$cached_hash" = "$rules_hash" ]; then
            log "DEBUG" "Using cached compiled rules for $category"
            echo "$cache_file"
            return 0
        fi
    fi

    # Compile rules
    log "DEBUG" "Compiling YARA rules for $category..."

    local rule_files=$(find "$rules_dir" -name "*.yar*" -type f 2>/dev/null)
    if [ -z "$rule_files" ]; then
        return 1
    fi

    # Create a combined rule file
    local combined_file="$YARA_CACHE_DIR/${category}_combined.yar"
    > "$combined_file"

    for rule in $rule_files; do
        cat "$rule" >> "$combined_file" 2>/dev/null || true
        echo "" >> "$combined_file"
    done

    if yarac "$combined_file" "$cache_file" 2>/dev/null; then
        echo "$rules_hash" > "$hash_file"
        log "DEBUG" "Compiled YARA rules cached for $category"
        echo "$cache_file"
        return 0
    else
        log "DEBUG" "Failed to compile rules for $category, using uncompiled"
        rm -f "$cache_file" "$hash_file"
        return 1
    fi
}

# ==========================================
# TOOL CHECKING
# ==========================================

usage() {
    cat << 'EOF'
DMS - Drive Malware Scan v2.1

Usage: malware_scan.sh <input> [options]

Arguments:
  <input>               Device or image to scan:
                        - Block device: /dev/sdb1
                        - EWF image: evidence.E01 (auto-detected)
                        - Raw image: disk.raw, disk.dd

Basic Options:
  -m, --mount           Mount the device before scanning
  -u, --update          Update ClamAV databases before scanning
  -d, --deep            Enable deep scan (file carving, entropy, bulk_extractor)
  -o, --output FILE     Output report file (default: auto-generated)
  -h, --help            Show this help message

Image Support:
  --verify-hash         Verify EWF hash before scanning (forensically sound)
  --input-format TYPE   Force input type: auto, block, ewf, raw (default: auto)

Scan Scope:
  --scan-mode MODE      Scan mode: full (entire drive) or slack (unallocated only)
  --slack               Shortcut for --scan-mode slack

Performance Options:
  -p, --parallel        Enable parallel scanning (ClamAV, YARA, binwalk, strings)
  --auto-chunk          Automatically calculate optimal chunk size based on RAM
  --quick               Quick scan mode (sample-based, faster preliminary analysis)

Feature Options:
  --virustotal          Enable VirusTotal hash lookup (requires API key)
  --rootkit             Run rootkit detection (requires mounted filesystem)
  --timeline            Generate file timeline using fls/mactime
  --resume FILE         Resume from a checkpoint file

Forensic Analysis:
  --forensic-analysis   Enable all forensic artifact analysis
  --persistence-scan    Scan for persistence mechanisms (registry, tasks, services)
  --execution-scan      Analyze execution artifacts (prefetch, amcache, shimcache)
  --file-anomalies      Detect file anomalies (timestomping, ADS, suspicious paths)
  --re-triage           Run RE triage on carved executables (capa, imports, entropy)
  --mft-analysis        Parse MFT for deleted files and filesystem anomalies
  --attack-mapping      Include MITRE ATT&CK technique IDs (default: enabled)
  --no-attack-mapping   Disable ATT&CK mapping in output

Output Options:
  --html                Generate HTML report
  --json                Generate JSON report
  -q, --quiet           Quiet mode (minimal output)
  -v, --verbose         Verbose mode (debug output)

Display Options:
  --no-color            Disable colored output
  --high-contrast       High visibility mode (bold text only)
  -i, --interactive     Interactive menu mode

Advanced Options:
  --dry-run             Preview actions without executing scans
  --config FILE         Use custom configuration file
  --log-file FILE       Write logs to file
  --keep-output         Keep temporary output directory after scan

Portable Mode:
  --portable            Auto-download missing tools to private directory
  --portable-keep       Keep portable tools after scan completes
  --portable-dir DIR    Custom portable tools directory (default: /tmp/malscan_portable_tools)

USB/Kit Operations:
  --update-kit          Update USB kit databases (requires network)
  --build-full-kit      Build complete offline forensic kit (~1.2GB)
  --build-minimal-kit   Build minimal kit (scripts only, ~10MB)
  --kit-target DIR      Target directory for kit build (default: ./dms-kit)
  --usb-mode            Force USB kit mode detection

ISO/Live Image:
  --build-iso           Build bootable DMS Forensic Live ISO (~2.5GB)
  --iso-output FILE     Output path for ISO file
  --flash-iso DEV       Flash ISO to USB device
  --create-persistence  Create persistence partition after flashing
  --force               Override safety checks for non-removable devices

Output Storage:
  --output-device DEV   Use specific device for scan output
  --output-path PATH    Use specific directory for scan output
  --output-tmpfs        Store output in RAM (lost on reboot)
  --case-name NAME      Custom case directory name

Configuration:
  Config file searched in: ~/.malscan.conf, /etc/malscan.conf, ./malscan.conf

Examples:
  ./malware_scan.sh /dev/sdb1                      # Full drive scan
  ./malware_scan.sh /dev/sdb1 --slack              # Slack space only (unallocated)
  ./malware_scan.sh evidence.E01 --scan-mode slack # EWF image, slack space only
  ./malware_scan.sh /dev/sdb1 -m -u                # Mount + update DBs
  ./malware_scan.sh /dev/sdb1 -d                   # Deep forensic scan
  ./malware_scan.sh evidence.E01                   # EWF image (auto-detected)
  ./malware_scan.sh evidence.E01 --verify-hash     # Verify integrity first
  ./malware_scan.sh disk.raw --input-format raw    # Raw image
  ./malware_scan.sh /dev/sdb1 -p --auto-chunk      # Parallel scan with auto chunk
  ./malware_scan.sh /dev/sdb1 --quick              # Fast preliminary scan
  ./malware_scan.sh /dev/sdb1 --json --html        # Multiple report formats
  ./malware_scan.sh /dev/sdb1 --resume .checkpoint # Resume interrupted scan
  ./malware_scan.sh /dev/sdb1 --portable           # Auto-download missing tools
  ./malware_scan.sh /dev/sdb1 -i                   # Interactive mode
  ./malware_scan.sh /dev/sdb1 --forensic-analysis  # Full forensic artifact analysis
  ./malware_scan.sh /dev/sdb1 --persistence-scan   # Persistence mechanism detection
  ./malware_scan.sh evidence.E01 --forensic-analysis --portable  # Forensic analysis on EWF

USB Kit Examples:
  ./malware_scan.sh --build-full-kit --kit-target /media/usb  # Build offline kit
  ./malware_scan.sh --update-kit                    # Update kit databases
  ./run-dms.sh /dev/sda1 --deep                     # Run from USB kit
  ./malware_scan.sh --build-iso --iso-output ~/dms.iso  # Build live ISO
  ./malware_scan.sh --flash-iso /dev/sdc --iso-output ~/dms.iso  # Flash to USB
  ./malware_scan.sh /dev/sda1 --output-device /dev/sdc1  # Save results to external USB

Supported Image Formats:
  - EWF/E01: Expert Witness Format (.E01, .E02, ... .Ex01, .L01, .Lx01)
  - RAW: Raw disk images (.raw, .dd, .img, .bin)
EOF
    exit 1
}

check_tools() {
    print_section "Checking Required Tools"

    local basic_tools=("clamscan" "yara" "strings" "dd" "binwalk")
    local deep_tools=("foremost" "bulk_extractor" "ssdeep" "exiftool" "md5deep")
    local slack_tools=("blkls" "foremost")  # Tools for slack space scanning
    local optional_tools=("yarac" "chkrootkit" "rkhunter" "fls" "mactime" "scalpel" "photorec")
    local missing=()

    echo "Basic tools:"
    for tool in "${basic_tools[@]}"; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool found"
        else
            print_error "$tool not found"
            missing+=("$tool")
        fi
    done

    if [ "$DEEP_SCAN" = true ]; then
        echo ""
        echo "Deep scan tools:"
        for tool in "${deep_tools[@]}"; do
            if command -v "$tool" &> /dev/null; then
                print_success "$tool found"
            else
                print_warning "$tool not found (optional)"
            fi
        done
    fi

    if [ "$SCAN_MODE" = "slack" ]; then
        echo ""
        echo "Slack space tools:"
        for tool in "${slack_tools[@]}"; do
            if command -v "$tool" &> /dev/null; then
                print_success "$tool found"
            else
                print_warning "$tool not found"
                if [ "$tool" = "blkls" ]; then
                    print_status "  Install with: apt install sleuthkit"
                fi
            fi
        done
    fi

    echo ""
    echo "Optional enhancement tools:"
    for tool in "${optional_tools[@]}"; do
        if command -v "$tool" &> /dev/null; then
            print_success "$tool found"
        else
            log "DEBUG" "$tool not available"
        fi
    done

    # Handle missing tools
    if [ ${#missing[@]} -gt 0 ]; then
        if [ "$PORTABLE_MODE" = true ]; then
            print_warning "Missing required tools: ${missing[*]}"
            print_status "Portable mode enabled - attempting to download missing tools..."
            echo ""

            if setup_portable_tools; then
                # Re-verify tools after portable setup
                missing=()
                for tool in "${basic_tools[@]}"; do
                    if ! command -v "$tool" &> /dev/null; then
                        missing+=("$tool")
                    fi
                done

                if [ ${#missing[@]} -gt 0 ]; then
                    print_error "Still missing required tools after portable setup: ${missing[*]}"
                    return 1
                fi

                print_success "All required tools now available via portable environment"
                return 0
            else
                print_error "Portable tools setup failed"
                return 1
            fi
        else
            print_error "Missing required tools: ${missing[*]}"
            print_status "Tip: Use --portable to auto-download missing tools"
            return 1
        fi
    fi

    return 0
}

get_device_info() {
    print_section "Device Information"

    # Validate device/image first (this sets ACTUAL_DEVICE and INPUT_TYPE)
    if ! validate_device "$DEVICE"; then
        return 1
    fi

    # Get device/image size based on input type
    case "$INPUT_TYPE" in
        block_device)
            # Standard block device - use lsblk
            DEVICE_SIZE=$(lsblk -b -d -n -o SIZE "$ACTUAL_DEVICE" 2>/dev/null || echo "0")
            FS_TYPE=$(lsblk -n -o FSTYPE "$ACTUAL_DEVICE" 2>/dev/null || echo "unknown")
            ;;

        ewf)
            # EWF image - use file size or ewfinfo
            if [ -n "$EWF_TOTAL_SIZE" ]; then
                # Parse size from ewfinfo (may be in various formats like "1.0 GB")
                local size_str="$EWF_TOTAL_SIZE"
                # Try to extract numeric value and unit
                local num=$(echo "$size_str" | grep -oP '[\d.]+' | head -1)
                local unit=$(echo "$size_str" | grep -oP '[KMGT]?B' | head -1)
                case "$unit" in
                    TB) DEVICE_SIZE=$(echo "$num * 1024 * 1024 * 1024 * 1024" | bc 2>/dev/null || echo "0") ;;
                    GB) DEVICE_SIZE=$(echo "$num * 1024 * 1024 * 1024" | bc 2>/dev/null || echo "0") ;;
                    MB) DEVICE_SIZE=$(echo "$num * 1024 * 1024" | bc 2>/dev/null || echo "0") ;;
                    KB) DEVICE_SIZE=$(echo "$num * 1024" | bc 2>/dev/null || echo "0") ;;
                    B|*) DEVICE_SIZE=$(echo "$num" | bc 2>/dev/null || echo "0") ;;
                esac
            else
                # Fall back to file size of virtual device
                DEVICE_SIZE=$(stat -c%s "$ACTUAL_DEVICE" 2>/dev/null || echo "0")
            fi
            FS_TYPE="EWF Image"
            ;;

        raw_image)
            # Raw image - use file size
            DEVICE_SIZE=$(stat -c%s "$ACTUAL_DEVICE" 2>/dev/null || echo "0")
            FS_TYPE="Raw Image"
            ;;

        *)
            DEVICE_SIZE=0
            FS_TYPE="unknown"
            ;;
    esac

    DEVICE_SIZE_GB=$(echo "scale=2; $DEVICE_SIZE / 1024 / 1024 / 1024" | bc 2>/dev/null || echo "unknown")

    # Display device information using TUI box
    if [ "$QUIET_MODE" != true ]; then
        draw_box "Input Source" 60 "double"

        local display_input="${ORIGINAL_INPUT:-$DEVICE}"
        local type_label=""
        case "$INPUT_TYPE" in
            block_device) type_label="Block Device" ;;
            ewf) type_label="EWF Forensic Image" ;;
            raw_image) type_label="Raw Disk Image" ;;
            *) type_label="Unknown" ;;
        esac

        draw_box_line "Input:      $display_input" 60 "double"
        draw_box_line "Type:       $type_label" 60 "double"
        draw_box_line "Size:       ${DEVICE_SIZE_GB} GB" 60 "double"

        if [ "$INPUT_TYPE" = "block_device" ]; then
            draw_box_line "Filesystem: $FS_TYPE" 60 "double"
        fi

        # EWF-specific metadata
        if [ "$INPUT_TYPE" = "ewf" ]; then
            [ -n "$EWF_HASH_MD5" ] && draw_box_line "MD5:        $EWF_HASH_MD5" 60 "double"
            [ ${#EWF_SEGMENTS[@]} -gt 1 ] && draw_box_line "Segments:   ${#EWF_SEGMENTS[@]} files" 60 "double"
            [ -n "$EWF_CASE_NUMBER" ] && draw_box_line "Case:       $EWF_CASE_NUMBER" 60 "double"
        fi

        draw_box_end 60 "double"
    fi

    # Calculate number of chunks needed
    DEVICE_SIZE_MB=$((DEVICE_SIZE / 1024 / 1024))
    if [ "$DEVICE_SIZE_MB" -eq 0 ]; then
        DEVICE_SIZE_MB=1  # Minimum 1MB to avoid division by zero
    fi
    NUM_CHUNKS=$(( (DEVICE_SIZE_MB + CHUNK_SIZE - 1) / CHUNK_SIZE ))

    if [ "$QUIET_MODE" != true ]; then
        echo ""
        print_status "Scan chunks: $NUM_CHUNKS (${CHUNK_SIZE}MB each)"
    fi

    # Update DEVICE to point to actual device for scanning functions
    # This makes EWF transparent to the scanning functions
    DEVICE="$ACTUAL_DEVICE"
    export DEVICE
    export SCAN_DEVICE="$DEVICE"

    return 0
}

mount_device() {
    print_section "Mounting Device"

    MOUNT_POINT=$(udisksctl mount -b "$DEVICE" 2>&1 | grep -oP "at \K/.*" || true)

    if [ -n "$MOUNT_POINT" ]; then
        print_success "Mounted at: $MOUNT_POINT"

        # Get usage info
        USED_SPACE=$(df -h "$MOUNT_POINT" | awk 'NR==2 {print $3}')
        AVAIL_SPACE=$(df -h "$MOUNT_POINT" | awk 'NR==2 {print $4}')
        echo "Used:       $USED_SPACE"
        echo "Available:  $AVAIL_SPACE"

        # List files
        FILE_COUNT=$(find "$MOUNT_POINT" -type f 2>/dev/null | wc -l)
        echo "Files:      $FILE_COUNT"
    else
        print_warning "Could not mount device (may already be mounted or permission denied)"
    fi
}

update_clamav() {
    print_section "Updating ClamAV Databases"

    mkdir -p "$CLAMDB_DIR"

    if freshclam --datadir="$CLAMDB_DIR" --log=/tmp/freshclam.log 2>&1 | tail -5; then
        print_success "ClamAV databases updated"
    else
        print_warning "Could not update ClamAV databases, using existing if available"
    fi
}

check_clamav_db() {
    if [ ! -d "$CLAMDB_DIR" ] || [ -z "$(ls -A $CLAMDB_DIR/*.cvd 2>/dev/null)" ]; then
        print_warning "ClamAV databases not found, downloading..."
        update_clamav
    fi

    # Verify databases exist
    if [ -z "$(ls -A $CLAMDB_DIR/*.cvd 2>/dev/null)" ]; then
        print_error "ClamAV databases not available"
        return 1
    fi

    # Get signature count
    SIG_COUNT=$(clamscan --database="$CLAMDB_DIR" --version 2>/dev/null | head -1 || echo "unknown")
    print_status "ClamAV: $SIG_COUNT"
    return 0
}

# ==========================================
# SCANNING FUNCTIONS
# ==========================================

scan_clamav() {
    print_section "ClamAV Scan"

    if ! check_clamav_db; then
        print_error "Skipping ClamAV scan - no databases"
        RESULTS["clamav"]="N/A"
        return 1
    fi

    CLAMAV_INFECTED=0

    print_status "Scanning device in ${CHUNK_SIZE}MB chunks..."

    local offset=${RESUME_CHUNK:-0}
    local chunk_num=$((offset / CHUNK_SIZE + 1))
    local start_time=$(date +%s)

    while [ $offset -lt $DEVICE_SIZE_MB ]; do
        CURRENT_CHUNK=$offset

        show_progress $chunk_num $NUM_CHUNKS $start_time "ClamAV scanning"

        result=$(dd if="$DEVICE" bs=1M count=$CHUNK_SIZE skip=$offset 2>/dev/null | \
                 clamscan --database="$CLAMDB_DIR" - 2>&1) || true

        infected=$(echo "$result" | grep "Infected files:" | awk '{print $3}')
        if [ "$infected" != "0" ] && [ -n "$infected" ]; then
            CLAMAV_INFECTED=$((CLAMAV_INFECTED + infected))
            echo ""
            print_error "MALWARE DETECTED in chunk $chunk_num!"
            echo "$result" | grep -E "FOUND|Infected"
        fi

        offset=$((offset + CHUNK_SIZE))
        chunk_num=$((chunk_num + 1))

        # Save checkpoint periodically
        if [ "$SAVE_CHECKPOINT" = true ] && [ $((chunk_num % 10)) -eq 0 ]; then
            save_checkpoint
        fi
    done

    echo ""
    if [ $CLAMAV_INFECTED -eq 0 ]; then
        print_success "ClamAV: CLEAN (0 infected)"
    else
        print_error "ClamAV: $CLAMAV_INFECTED INFECTED FILES FOUND"
    fi

    RESULTS["clamav"]=$CLAMAV_INFECTED
    return 0
}

scan_yara_category() {
    local category=$1
    local rules_dir=$2
    local sample_size=${3:-500}

    if [ ! -d "$rules_dir" ]; then
        print_warning "YARA rules directory not found: $rules_dir"
        return 0
    fi

    local rule_count=$(find "$rules_dir" -name "*.yar*" 2>/dev/null | wc -l)
    if [ "$rule_count" -eq 0 ]; then
        print_warning "No YARA rules found in: $rules_dir"
        return 0
    fi

    print_status "Scanning with $category rules ($rule_count rules)..."

    local matches=0
    local scanned=0

    # Try to use compiled rules
    local compiled_rules=$(compile_yara_rules "$rules_dir" "$category")

    if [ -n "$compiled_rules" ] && [ -f "$compiled_rules" ]; then
        # Use compiled rules
        result=$(dd if="$DEVICE" bs=1M count=$sample_size 2>/dev/null | yara -C "$compiled_rules" - 2>/dev/null || true)
        if [ -n "$result" ]; then
            matches=$(echo "$result" | wc -l)
            print_error "YARA MATCHES ($category):"
            echo "$result"
        fi
        scanned=$rule_count
    else
        # Fall back to individual rules
        for rule in "$rules_dir"/*.yar*; do
            if [ -f "$rule" ]; then
                scanned=$((scanned + 1))
                result=$(dd if="$DEVICE" bs=1M count=$sample_size 2>/dev/null | yara -w "$rule" - 2>/dev/null || true)

                if [ -n "$result" ]; then
                    matches=$((matches + 1))
                    print_error "YARA MATCH: $(basename "$rule")"
                    echo "$result"
                fi
            fi
        done
    fi

    if [ $matches -eq 0 ]; then
        print_success "$category: CLEAN ($scanned rules checked)"
    else
        print_error "$category: $matches MATCHES FOUND"
    fi

    RESULTS["yara_$category"]=$matches
    return 0
}

scan_yara() {
    print_section "YARA Scan"

    # Windows malware
    scan_yara_category "Windows" "$YARA_RULES_BASE/Windows/YaraRules_Windows"

    # Linux malware
    scan_yara_category "Linux" "$YARA_RULES_BASE/Linux/YaraRules_Linux"

    # Android malware
    scan_yara_category "Android" "$YARA_RULES_BASE/Android/YaraRules"

    # Document malware (oledump)
    if [ -d "$OLEDUMP_RULES" ]; then
        scan_yara_category "Documents" "$OLEDUMP_RULES"
    fi

    return 0
}

scan_binwalk() {
    print_section "Binwalk Signature Scan"

    print_status "Scanning for embedded file signatures..."

    binwalk_result=$(binwalk --signature "$DEVICE" 2>/dev/null | head -50) || true

    if [ -z "$binwalk_result" ] || [ "$(echo "$binwalk_result" | wc -l)" -le 3 ]; then
        print_success "Binwalk: No suspicious embedded files detected"
        RESULTS["binwalk"]=0
    else
        print_warning "Binwalk found embedded signatures:"
        echo "$binwalk_result"
        RESULTS["binwalk"]=1
    fi

    return 0
}

scan_strings() {
    print_section "String Analysis"

    print_status "Searching for suspicious strings..."

    # Suspicious patterns
    local patterns=(
        "http://|https://"
        "\.exe|\.dll|\.bat|\.ps1|\.vbs|\.scr"
        "cmd\.exe|powershell|wscript|cscript"
        "password|passwd|credential"
        "ransomware|decrypt|bitcoin|wallet"
        "keylog|backdoor|trojan|malware"
        "base64_decode|eval\(|exec\("
    )

    local found=0

    for pattern in "${patterns[@]}"; do
        matches=$(dd if="$DEVICE" bs=1M count=1000 2>/dev/null | strings -n 8 | grep -iE "$pattern" | head -20) || true
        if [ -n "$matches" ]; then
            found=$((found + 1))
            print_warning "Pattern '$pattern' found:"
            echo "$matches" | head -10
            echo ""
        fi
    done

    if [ $found -eq 0 ]; then
        print_success "String analysis: CLEAN"
    else
        print_warning "String analysis: $found suspicious patterns found"
    fi

    RESULTS["strings"]=$found
    return 0
}

# ==========================================
# PARALLEL SCANNING
# ==========================================

run_parallel_scans() {
    print_section "Parallel Scanning Mode"

    print_status "Running scans in parallel (max $MAX_PARALLEL_JOBS jobs)..."

    local temp_dir="$SCAN_OUTPUT_DIR/parallel_results"
    mkdir -p "$temp_dir"

    # Start scans in background
    (
        scan_clamav > "$temp_dir/clamav.log" 2>&1
        echo "clamav:${RESULTS[clamav]:-0}" > "$temp_dir/clamav.result"
    ) &
    BG_PIDS+=($!)

    (
        scan_yara > "$temp_dir/yara.log" 2>&1
        for key in "${!RESULTS[@]}"; do
            [[ "$key" == yara_* ]] && echo "$key:${RESULTS[$key]}" >> "$temp_dir/yara.result"
        done
    ) &
    BG_PIDS+=($!)

    (
        scan_binwalk > "$temp_dir/binwalk.log" 2>&1
        echo "binwalk:${RESULTS[binwalk]:-0}" > "$temp_dir/binwalk.result"
    ) &
    BG_PIDS+=($!)

    (
        scan_strings > "$temp_dir/strings.log" 2>&1
        echo "strings:${RESULTS[strings]:-0}" > "$temp_dir/strings.result"
    ) &
    BG_PIDS+=($!)

    # Wait for all background jobs
    local job_count=${#BG_PIDS[@]}
    local completed=0

    for pid in "${BG_PIDS[@]}"; do
        wait "$pid" 2>/dev/null || true
        completed=$((completed + 1))
        show_progress $completed $job_count $(date +%s) "Parallel scans"
    done

    echo ""

    # Collect results
    for result_file in "$temp_dir"/*.result; do
        if [ -f "$result_file" ]; then
            while IFS=':' read -r key value; do
                RESULTS["$key"]="$value"
            done < "$result_file"
        fi
    done

    # Show logs
    print_status "Scan logs available in: $temp_dir"

    # Clear background PIDs array
    BG_PIDS=()

    return 0
}

# ==========================================
# QUICK SCAN MODE
# ==========================================

scan_quick() {
    print_section "Quick Scan Mode"

    print_status "Performing sample-based quick scan (10 random regions)..."

    local num_samples=10
    local sample_size_mb=50
    local max_offset=$((DEVICE_SIZE_MB - sample_size_mb))
    local suspicious_count=0

    if [ $max_offset -le 0 ]; then
        max_offset=$DEVICE_SIZE_MB
        sample_size_mb=$((DEVICE_SIZE_MB / num_samples))
    fi

    for i in $(seq 1 $num_samples); do
        local offset=$((RANDOM % max_offset))

        printf "\r${BLUE}[*]${NC} Scanning sample %d/%d at offset %dMB..." "$i" "$num_samples" "$offset"

        # Quick ClamAV check
        local result=$(dd if="$DEVICE" bs=1M count=$sample_size_mb skip=$offset 2>/dev/null | \
                      clamscan --database="$CLAMDB_DIR" - 2>&1) || true

        local infected=$(echo "$result" | grep "Infected files:" | awk '{print $3}')
        if [ "$infected" != "0" ] && [ -n "$infected" ]; then
            suspicious_count=$((suspicious_count + 1))
            echo ""
            print_error "Suspicious content at offset ${offset}MB!"
        fi

        # Quick string check
        local sus_strings=$(dd if="$DEVICE" bs=1M count=$sample_size_mb skip=$offset 2>/dev/null | \
                          strings -n 8 | grep -iE "malware|trojan|backdoor|ransomware" | head -5) || true
        if [ -n "$sus_strings" ]; then
            suspicious_count=$((suspicious_count + 1))
        fi
    done

    echo ""

    if [ $suspicious_count -eq 0 ]; then
        print_success "Quick scan: No obvious threats detected"
        print_status "Recommendation: Run full scan for comprehensive analysis"
    else
        print_error "Quick scan: $suspicious_count suspicious regions found!"
        print_status "Recommendation: Run full deep scan immediately"
    fi

    RESULTS["quick_scan"]=$suspicious_count
    return 0
}

# ==========================================
# VIRUSTOTAL INTEGRATION
# ==========================================

scan_virustotal() {
    print_section "VirusTotal Hash Lookup"

    if [ -z "$VT_API_KEY" ]; then
        print_warning "VirusTotal API key not configured"
        print_status "Set VT_API_KEY in config file or environment"
        return 0
    fi

    if [ -z "$MOUNT_POINT" ] || [ ! -d "$MOUNT_POINT" ]; then
        print_warning "No mounted filesystem for VirusTotal scan"
        return 0
    fi

    print_status "Checking file hashes against VirusTotal..."

    local vt_results="$SCAN_OUTPUT_DIR/virustotal_results.txt"
    local checked=0
    local malicious=0
    local rate_limit_delay=$((60 / VT_RATE_LIMIT))

    # Get list of executable files
    local exec_files=$(find "$MOUNT_POINT" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.scr" -o -executable \) 2>/dev/null | head -20)

    for file in $exec_files; do
        if [ ! -f "$file" ]; then
            continue
        fi

        local file_hash=$(sha256sum "$file" 2>/dev/null | cut -d' ' -f1)
        if [ -z "$file_hash" ]; then
            continue
        fi

        printf "\r${BLUE}[*]${NC} Checking: %s..." "$(basename "$file")"

        # Query VirusTotal
        local vt_response=$(curl -s --request GET \
            --url "https://www.virustotal.com/api/v3/files/$file_hash" \
            --header "x-apikey: $VT_API_KEY" 2>/dev/null)

        if echo "$vt_response" | grep -q '"malicious"'; then
            local malicious_count=$(echo "$vt_response" | grep -oP '"malicious":\s*\K\d+' | head -1)
            if [ "$malicious_count" -gt 0 ]; then
                malicious=$((malicious + 1))
                echo ""
                print_error "MALICIOUS: $file ($malicious_count detections)"
                echo "$file: $malicious_count detections" >> "$vt_results"
            fi
        fi

        checked=$((checked + 1))

        # Rate limiting
        sleep $rate_limit_delay
    done

    echo ""

    if [ $malicious -eq 0 ]; then
        print_success "VirusTotal: No known malware found ($checked files checked)"
    else
        print_error "VirusTotal: $malicious MALICIOUS files detected!"
        print_status "Details saved to: $vt_results"
    fi

    RESULTS["virustotal"]=$malicious
    return 0
}

# ==========================================
# ROOTKIT DETECTION
# ==========================================

scan_rootkit() {
    print_section "Rootkit Detection"

    if [ -z "$MOUNT_POINT" ] || [ ! -d "$MOUNT_POINT" ]; then
        print_warning "Rootkit scan requires mounted filesystem"
        return 0
    fi

    local rootkit_findings=0

    # Try chkrootkit
    if command -v chkrootkit &> /dev/null; then
        print_status "Running chkrootkit..."

        local chk_result=$(chkrootkit -r "$MOUNT_POINT" 2>/dev/null | grep -i "INFECTED" || true)

        if [ -n "$chk_result" ]; then
            rootkit_findings=$((rootkit_findings + 1))
            print_error "chkrootkit found infections:"
            echo "$chk_result"
        else
            print_success "chkrootkit: No rootkits detected"
        fi
    else
        print_warning "chkrootkit not available"
    fi

    # Try rkhunter
    if command -v rkhunter &> /dev/null; then
        print_status "Running rkhunter (basic checks)..."

        local rkh_result=$(rkhunter --check --skip-keypress --rootdir "$MOUNT_POINT" \
                         --report-warnings-only 2>/dev/null | grep -i "warning" || true)

        if [ -n "$rkh_result" ]; then
            rootkit_findings=$((rootkit_findings + 1))
            print_warning "rkhunter warnings:"
            echo "$rkh_result" | head -10
        else
            print_success "rkhunter: No warnings"
        fi
    else
        print_warning "rkhunter not available"
    fi

    if [ $rootkit_findings -eq 0 ]; then
        print_success "Rootkit scan: CLEAN"
    else
        print_error "Rootkit scan: $rootkit_findings potential issues found"
    fi

    RESULTS["rootkit"]=$rootkit_findings
    return 0
}

# ==========================================
# FILE TIMELINE GENERATION
# ==========================================

generate_timeline() {
    print_section "File Timeline Generation"

    if ! command -v fls &> /dev/null || ! command -v mactime &> /dev/null; then
        print_warning "Timeline tools (fls, mactime) not available"
        return 0
    fi

    local timeline_dir="$SCAN_OUTPUT_DIR/timeline"
    mkdir -p "$timeline_dir"

    print_status "Extracting filesystem metadata with fls..."

    # Generate body file
    local body_file="$timeline_dir/filesystem.body"
    if fls -r -m "/" "$DEVICE" > "$body_file" 2>/dev/null; then
        local entry_count=$(wc -l < "$body_file")
        print_success "Extracted $entry_count filesystem entries"

        # Generate timeline
        print_status "Creating timeline with mactime..."
        local timeline_file="$timeline_dir/timeline.txt"

        if mactime -b "$body_file" > "$timeline_file" 2>/dev/null; then
            print_success "Timeline generated: $timeline_file"

            # Show recent activity
            echo ""
            print_status "Recent file activity (last 10 entries):"
            tail -10 "$timeline_file"

            RESULTS["timeline"]=1
        else
            print_warning "Failed to generate timeline"
            RESULTS["timeline"]=0
        fi
    else
        print_warning "Failed to extract filesystem metadata"
        RESULTS["timeline"]=0
    fi

    return 0
}

# ==========================================
# SLACK SPACE ANALYSIS FUNCTIONS
# ==========================================

extract_slack_space() {
    print_section "Slack Space Extraction"

    local device_to_extract="$DEVICE"
    local slack_file="$SCAN_OUTPUT_DIR/unallocated.raw"

    # Check if blkls is available
    if ! command -v blkls &>/dev/null; then
        print_error "blkls (Sleuth Kit) not found. Required for slack space extraction."
        print_status "Install with: apt install sleuthkit"
        return 1
    fi

    print_status "Extracting unallocated blocks from $device_to_extract..."
    print_status "This may take a while depending on disk size..."

    # Extract unallocated space using blkls
    # -A extracts all unallocated blocks (slack space + unallocated)
    local start_time=$(date +%s)

    if timeout "$SLACK_EXTRACT_TIMEOUT" blkls -A "$device_to_extract" > "$slack_file" 2>/dev/null; then
        local end_time=$(date +%s)
        local duration=$((end_time - start_time))

        # Get size of extracted data
        local slack_size_bytes=$(stat -c%s "$slack_file" 2>/dev/null || echo 0)
        local slack_size_mb=$((slack_size_bytes / 1024 / 1024))

        STATS[slack_size_mb]=$slack_size_mb

        if [ "$slack_size_mb" -lt "$SLACK_MIN_SIZE_MB" ]; then
            print_warning "Slack space too small (${slack_size_mb}MB < ${SLACK_MIN_SIZE_MB}MB minimum)"
            rm -f "$slack_file"
            return 1
        fi

        print_success "Extracted ${slack_size_mb}MB of unallocated data in ${duration}s"
        SLACK_DEVICE="$slack_file"
        return 0
    else
        print_error "Failed to extract slack space (timeout or error)"
        rm -f "$slack_file"
        return 1
    fi
}

catalog_reconstructed_files() {
    local output_dir="$1"
    local catalog_file="$SCAN_OUTPUT_DIR/carved_catalog.txt"
    local exe_count=0
    local by_type=""

    print_status "Cataloging recovered files..."

    # Count files by type
    declare -A type_counts

    while IFS= read -r -d '' file; do
        local ext="${file##*.}"
        ext=$(echo "$ext" | tr '[:upper:]' '[:lower:]')

        # Count by extension
        type_counts["$ext"]=$((${type_counts["$ext"]:-0} + 1))

        # Count executables
        case "$ext" in
            exe|dll|sys|scr|com|msi)
                exe_count=$((exe_count + 1))
                ;;
        esac
    done < <(find "$output_dir" -type f -print0 2>/dev/null)

    # Build by_type string
    for ext in "${!type_counts[@]}"; do
        by_type+="${ext}:${type_counts[$ext]},"
    done
    by_type="${by_type%,}"  # Remove trailing comma

    # Update stats
    STATS[carved_by_type]="$by_type"
    STATS[carved_executables]=$exe_count

    # Write catalog
    {
        echo "Recovered Files Catalog"
        echo "========================"
        echo "Generated: $(date)"
        echo ""
        echo "By Type:"
        for ext in "${!type_counts[@]}"; do
            printf "  %-10s %d files\n" "$ext" "${type_counts[$ext]}"
        done | sort -t: -k2 -rn
        echo ""
        echo "Executables found: $exe_count"
    } > "$catalog_file"

    print_success "Catalog written to: $catalog_file"
}

reconstruct_deleted_files() {
    local input="$1"
    local output_dir="$SCAN_OUTPUT_DIR/reconstructed"

    print_section "File Recovery (Reconstruction)"

    mkdir -p "$output_dir/foremost"

    local total_recovered=0

    # 1. Extract with foremost (primary carver)
    if command -v foremost &>/dev/null; then
        print_status "Running foremost file carver..."
        if foremost -t all -o "$output_dir/foremost" -i "$input" 2>&1 | tail -5; then
            local foremost_count=$(find "$output_dir/foremost" -type f ! -name "audit.txt" 2>/dev/null | wc -l)
            print_success "Foremost recovered $foremost_count files"
            total_recovered=$((total_recovered + foremost_count))
        fi
    else
        print_warning "foremost not available"
    fi

    # 2. Try photorec if available (better for certain formats)
    if command -v photorec &>/dev/null && echo "$CARVING_TOOLS" | grep -q "photorec"; then
        mkdir -p "$output_dir/photorec"
        print_status "Running photorec file carver..."

        # photorec requires interactive mode normally, use testdisk's photorec with /cmd for batch
        # This is a simplified approach - photorec is tricky in batch mode
        print_warning "photorec available but requires manual operation - skipping automated recovery"
    fi

    # 3. Try scalpel if available
    if command -v scalpel &>/dev/null && echo "$CARVING_TOOLS" | grep -q "scalpel"; then
        mkdir -p "$output_dir/scalpel"
        print_status "Running scalpel file carver..."
        if scalpel -o "$output_dir/scalpel" "$input" 2>&1 | tail -5; then
            local scalpel_count=$(find "$output_dir/scalpel" -type f 2>/dev/null | wc -l)
            print_success "Scalpel recovered $scalpel_count files"
            total_recovered=$((total_recovered + scalpel_count))
        fi
    fi

    # Limit number of files if needed
    if [ $total_recovered -gt "$MAX_CARVED_FILES" ]; then
        print_warning "Recovered $total_recovered files, limiting to $MAX_CARVED_FILES for analysis"
    fi

    STATS[carved_total]=$total_recovered
    STATS[slack_files_recovered]=$total_recovered

    # Calculate recovered data size
    local recovered_size=$(du -sm "$output_dir" 2>/dev/null | cut -f1)
    STATS[slack_data_recovered_mb]=${recovered_size:-0}

    # Catalog what was found
    catalog_reconstructed_files "$output_dir"

    print_success "Total files recovered: $total_recovered"
    return 0
}

extract_slack_artifacts() {
    local input="$1"
    local artifacts_dir="$SCAN_OUTPUT_DIR/slack_artifacts"

    print_section "Slack Space Artifact Extraction"

    mkdir -p "$artifacts_dir"

    # Use bulk_extractor for structured data
    if command -v bulk_extractor &>/dev/null; then
        print_status "Running bulk_extractor on slack space..."

        timeout 600 bulk_extractor -o "$artifacts_dir" "$input" 2>&1 | tail -10 || true

        # Parse and categorize findings
        if [ -d "$artifacts_dir" ]; then
            # Email addresses
            if [ -f "$artifacts_dir/email.txt" ] && [ -s "$artifacts_dir/email.txt" ]; then
                STATS[bulk_emails]=$(wc -l < "$artifacts_dir/email.txt")
                print_status "Found ${STATS[bulk_emails]} email addresses"
            fi

            # URLs
            if [ -f "$artifacts_dir/url.txt" ] && [ -s "$artifacts_dir/url.txt" ]; then
                STATS[bulk_urls]=$(wc -l < "$artifacts_dir/url.txt")
                # Extract sample URLs
                local url_samples=$(head -5 "$artifacts_dir/url.txt" | tr '\n' '|')
                STATS[strings_samples]="${url_samples%|}"
                print_status "Found ${STATS[bulk_urls]} URLs"
            fi

            # Credit card numbers
            if [ -f "$artifacts_dir/ccn.txt" ] && [ -s "$artifacts_dir/ccn.txt" ]; then
                STATS[bulk_ccn]=$(wc -l < "$artifacts_dir/ccn.txt")
                print_warning "Found ${STATS[bulk_ccn]} potential credit card numbers"
            fi
        fi
    else
        print_warning "bulk_extractor not available, using basic extraction..."

        # Fallback: use strings for basic artifact extraction
        print_status "Extracting strings from slack space..."
        strings -a "$input" > "$artifacts_dir/all_strings.txt" 2>/dev/null

        # Extract URLs
        grep -oE 'https?://[^[:space:]]+' "$artifacts_dir/all_strings.txt" > "$artifacts_dir/urls.txt" 2>/dev/null
        STATS[strings_urls]=$(wc -l < "$artifacts_dir/urls.txt" 2>/dev/null || echo 0)

        # Extract email-like patterns
        grep -oE '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' "$artifacts_dir/all_strings.txt" > "$artifacts_dir/emails.txt" 2>/dev/null
        STATS[bulk_emails]=$(wc -l < "$artifacts_dir/emails.txt" 2>/dev/null || echo 0)

        print_status "Extracted ${STATS[strings_urls]} URLs and ${STATS[bulk_emails]} emails"
    fi

    return 0
}

map_slack_entropy() {
    local input="$1"

    print_section "Slack Space Entropy Mapping"

    print_status "Analyzing entropy distribution in slack space..."

    local high_entropy_regions=0
    local total_entropy=0
    local max_entropy=0
    local regions_scanned=0
    local high_offsets=""

    python3 << SLACK_ENTROPY_EOF
import math
import sys
import os

input_file = "$input"
chunk_size_mb = 10
high_entropy_threshold = 7.5
regions = []

try:
    file_size = os.path.getsize(input_file)
    num_chunks = min(50, file_size // (chunk_size_mb * 1024 * 1024) + 1)

    print(f"Scanning {num_chunks} regions of {chunk_size_mb}MB each...")
    print("-" * 60)

    suspicious = 0
    total_entropy = 0
    max_entropy = 0
    high_offsets = []

    with open(input_file, 'rb') as f:
        for i in range(num_chunks):
            offset_mb = i * chunk_size_mb
            f.seek(offset_mb * 1024 * 1024)
            data = f.read(chunk_size_mb * 1024 * 1024)

            if len(data) == 0:
                continue

            freq = [0] * 256
            for b in data:
                freq[b] += 1

            entropy = 0
            for fr in freq:
                if fr > 0:
                    p = fr / len(data)
                    entropy -= p * math.log2(p)

            total_entropy += entropy
            if entropy > max_entropy:
                max_entropy = entropy

            status = ""
            if entropy > high_entropy_threshold:
                status = "HIGH ENTROPY"
                suspicious += 1
                high_offsets.append(f"0x{offset_mb * 1024 * 1024:X}")
                print(f"Region {offset_mb:5d}MB: Entropy={entropy:.2f}/8.0 - {status}")
            elif entropy > 6.0:
                status = "Data present"

    print("-" * 60)

    avg_entropy = total_entropy / num_chunks if num_chunks > 0 else 0

    print(f"STATS:regions={num_chunks}")
    print(f"STATS:high={suspicious}")
    print(f"STATS:avg={avg_entropy:.2f}")
    print(f"STATS:max={max_entropy:.2f}")
    print(f"STATS:offsets={','.join(high_offsets)}")

    if suspicious > 0:
        print(f"Found {suspicious} high-entropy regions (possible encryption/packed data)")
        sys.exit(1)
    else:
        print("No suspicious high-entropy regions detected")
        sys.exit(0)

except Exception as e:
    print(f"Error: {e}")
    sys.exit(2)
SLACK_ENTROPY_EOF

    local exit_code=$?

    # Parse output for stats (this is a simplified approach)
    if [ $exit_code -eq 1 ]; then
        STATS[entropy_high_count]=1
    else
        STATS[entropy_high_count]=0
    fi

    return 0
}

scan_slack_space() {
    print_section "Slack Space Analysis"

    if [ "$SCAN_MODE" != "slack" ]; then
        print_status "Scan mode is 'full', skipping dedicated slack analysis..."
        return 0
    fi

    # 1. Extract unallocated data
    if ! extract_slack_space; then
        print_error "Failed to extract slack space"
        return 1
    fi

    if [ -z "$SLACK_DEVICE" ] || [ ! -f "$SLACK_DEVICE" ]; then
        print_error "No slack space data to analyze"
        return 1
    fi

    # 2. Attempt file reconstruction with multiple tools
    reconstruct_deleted_files "$SLACK_DEVICE"

    # 3. Deep pattern extraction
    extract_slack_artifacts "$SLACK_DEVICE"

    # 4. Entropy mapping of slack regions
    map_slack_entropy "$SLACK_DEVICE"

    # 5. Scan reconstructed files for malware
    local reconstructed_dir="$SCAN_OUTPUT_DIR/reconstructed"
    if [ -d "$reconstructed_dir" ]; then
        print_section "Scanning Recovered Files"

        # ClamAV scan of recovered files
        if command -v clamscan &>/dev/null; then
            print_status "Scanning recovered files with ClamAV..."
            local clam_result=$(clamscan --database="$CLAMDB_DIR" -r "$reconstructed_dir" 2>&1) || true
            local infected=$(echo "$clam_result" | grep "Infected files:" | awk '{print $3}')

            if [ -n "$infected" ] && [ "$infected" != "0" ]; then
                print_warning "Found $infected infected files in recovered data!"
                RESULTS["carved_malware"]=$infected
                STATS[clamav_infected]=$infected
            else
                print_success "Recovered files: CLEAN"
                RESULTS["carved_malware"]=0
            fi
        fi

        # YARA scan of recovered executables
        if [ "${STATS[carved_executables]}" -gt 0 ]; then
            print_status "Scanning recovered executables with YARA..."
            # This would call the existing YARA scanning logic
        fi
    fi

    print_success "Slack space analysis complete"
    return 0
}

# ==========================================
# FORENSIC ANALYSIS FUNCTIONS
# ==========================================

# ATT&CK technique mapping for findings
declare -gA ATTACK_TECHNIQUES=(
    # Persistence
    ["registry_run"]="T1547.001"
    ["registry_services"]="T1543.003"
    ["scheduled_task"]="T1053.005"
    ["startup_folder"]="T1547.001"
    ["wmi_subscription"]="T1546.003"
    ["dll_hijack"]="T1574.001"

    # Execution Evidence
    ["prefetch_execution"]="T1059"
    ["suspicious_execution_path"]="T1204.002"
    ["lolbin_execution"]="T1218"

    # Defense Evasion / Masquerading
    ["double_extension"]="T1036.007"
    ["name_mismatch"]="T1036.005"
    ["masquerading"]="T1036"
    ["timestomping"]="T1070.006"

    # Process Injection
    ["process_hollowing"]="T1055.012"
    ["process_injection"]="T1055"

    # Credential Access
    ["credential_access"]="T1003"
    ["credential_dumping"]="T1003.001"
)

scan_persistence_artifacts() {
    print_section "Persistence Artifact Analysis"

    # Check if we have access to filesystem (mounted or extracted)
    local fs_path=""
    if [ -n "$MOUNTED_FS_PATH" ] && [ -d "$MOUNTED_FS_PATH" ]; then
        fs_path="$MOUNTED_FS_PATH"
    elif [ -n "$MOUNT_POINT" ] && [ -d "$MOUNT_POINT" ]; then
        fs_path="$MOUNT_POINT"
    fi

    if [ -z "$fs_path" ]; then
        print_warning "Filesystem not mounted - attempting to locate registry hives in carved files"
        # Try to find registry hives in carved/recovered files
        fs_path="$SCAN_OUTPUT_DIR"
    fi

    print_status "Analyzing persistence mechanisms..."

    local findings_file="$SCAN_OUTPUT_DIR/persistence_findings.txt"
    local total_findings=0

    # Initialize findings file
    cat > "$findings_file" << 'EOF'
================================================================================
PERSISTENCE ARTIFACT ANALYSIS REPORT
================================================================================
Generated: $(date)

EOF

    # 1. Registry Analysis with RegRipper
    scan_registry_persistence "$fs_path" "$findings_file"

    # 2. Scheduled Tasks Analysis
    scan_scheduled_tasks "$fs_path" "$findings_file"

    # 3. Startup Folder Analysis
    scan_startup_folders "$fs_path" "$findings_file"

    # 4. WMI Subscription Analysis
    scan_wmi_persistence "$fs_path" "$findings_file"

    # 5. Service Analysis (from registry)
    scan_service_persistence "$fs_path" "$findings_file"

    # Calculate total findings
    total_findings=$((${STATS[persistence_registry_run]} + ${STATS[persistence_services]} + \
                      ${STATS[persistence_tasks]} + ${STATS[persistence_startup]} + \
                      ${STATS[persistence_wmi]}))

    STATS[persistence_findings]=$total_findings
    RESULTS["persistence"]=$total_findings

    if [ $total_findings -gt 0 ]; then
        print_warning "Found $total_findings persistence artifacts - review recommended"

        # Add to guidance
        GUIDANCE_RECOMMENDATIONS+=("Review persistence artifacts in $findings_file")

        if [ "$ATTACK_MAPPING" = true ]; then
            print_status "ATT&CK Techniques detected:"
            [ "${STATS[persistence_registry_run]}" -gt 0 ] && echo "  - ${ATTACK_TECHNIQUES[registry_run]}: Registry Run Keys/Startup Folder"
            [ "${STATS[persistence_services]}" -gt 0 ] && echo "  - ${ATTACK_TECHNIQUES[registry_services]}: Windows Service"
            [ "${STATS[persistence_tasks]}" -gt 0 ] && echo "  - ${ATTACK_TECHNIQUES[scheduled_task]}: Scheduled Task/Job"
            [ "${STATS[persistence_wmi]}" -gt 0 ] && echo "  - ${ATTACK_TECHNIQUES[wmi_subscription]}: WMI Event Subscription"
        fi
    else
        print_success "No suspicious persistence artifacts detected"
        GUIDANCE_NO_ACTION+=("Persistence artifact scan: No suspicious findings")
    fi

    return 0
}

scan_registry_persistence() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing registry for persistence mechanisms..."

    # Common registry hive locations
    local -a hive_paths=(
        "Windows/System32/config/SOFTWARE"
        "Windows/System32/config/SYSTEM"
        "Windows/System32/config/SAM"
        "Windows/System32/config/SECURITY"
        "Users/*/NTUSER.DAT"
        "Users/*/AppData/Local/Microsoft/Windows/UsrClass.dat"
    )

    local hives_found=0
    local registry_findings=0

    echo "" >> "$findings_file"
    echo "=== REGISTRY PERSISTENCE ANALYSIS ===" >> "$findings_file"
    echo "" >> "$findings_file"

    # Find registry hives
    for hive_pattern in "${hive_paths[@]}"; do
        while IFS= read -r -d '' hive; do
            [ -f "$hive" ] || continue
            ((hives_found++))

            local hive_name=$(basename "$hive")
            log "DEBUG" "Found registry hive: $hive"

            # Use RegRipper if available
            if [ -n "$REGRIPPER_PATH" ] || command -v rip.pl &> /dev/null; then
                local rip_cmd="${REGRIPPER_PATH:-rip.pl}"
                local rip_output="$SCAN_OUTPUT_DIR/regripper_${hive_name}.txt"

                # Run relevant plugins based on hive type
                case "$hive_name" in
                    SOFTWARE)
                        # Run persistence-related plugins
                        local plugins=("run" "soft_run" "appinitdlls" "clsid" "shellext")
                        for plugin in "${plugins[@]}"; do
                            perl "$rip_cmd" -r "$hive" -p "$plugin" >> "$rip_output" 2>/dev/null || true
                        done
                        ;;
                    SYSTEM)
                        local plugins=("services" "svc" "devclass")
                        for plugin in "${plugins[@]}"; do
                            perl "$rip_cmd" -r "$hive" -p "$plugin" >> "$rip_output" 2>/dev/null || true
                        done
                        ;;
                    NTUSER.DAT)
                        local plugins=("run" "runmru" "userassist" "muicache")
                        for plugin in "${plugins[@]}"; do
                            perl "$rip_cmd" -r "$hive" -p "$plugin" >> "$rip_output" 2>/dev/null || true
                        done
                        ;;
                esac

                # Parse output for suspicious entries
                if [ -f "$rip_output" ] && [ -s "$rip_output" ]; then
                    # Look for suspicious patterns in Run keys
                    local suspicious=$(grep -iE "(powershell|cmd\.exe|wscript|cscript|mshta|regsvr32|rundll32|certutil)" "$rip_output" 2>/dev/null | wc -l)

                    if [ "$suspicious" -gt 0 ]; then
                        echo "[HIGH] Suspicious entries in $hive_name:" >> "$findings_file"
                        grep -iE "(powershell|cmd\.exe|wscript|cscript|mshta|regsvr32|rundll32|certutil)" "$rip_output" >> "$findings_file" 2>/dev/null || true
                        echo "" >> "$findings_file"
                        registry_findings=$((registry_findings + suspicious))
                    fi

                    # Look for suspicious paths
                    local temp_paths=$(grep -iE "(\\\\temp\\\\|\\\\appdata\\\\local\\\\temp|\\\\public\\\\|\\\\downloads\\\\)" "$rip_output" 2>/dev/null | wc -l)
                    if [ "$temp_paths" -gt 0 ]; then
                        echo "[MED] Executables in suspicious paths:" >> "$findings_file"
                        grep -iE "(\\\\temp\\\\|\\\\appdata\\\\local\\\\temp|\\\\public\\\\|\\\\downloads\\\\)" "$rip_output" >> "$findings_file" 2>/dev/null || true
                        echo "" >> "$findings_file"
                        registry_findings=$((registry_findings + temp_paths))
                    fi
                fi
            else
                # Fallback: Use python-registry if available
                if python3 -c "import Registry" 2>/dev/null; then
                    analyze_registry_python "$hive" "$findings_file"
                else
                    log "DEBUG" "No registry parsing tool available for $hive"
                fi
            fi

        done < <(find "$fs_path" -ipath "*$hive_pattern" -type f -print0 2>/dev/null)
    done

    if [ $hives_found -eq 0 ]; then
        echo "No registry hives found in filesystem" >> "$findings_file"
        print_warning "No registry hives found"
    else
        print_status "Analyzed $hives_found registry hives"
    fi

    STATS[persistence_registry_run]=$registry_findings

    return 0
}

analyze_registry_python() {
    local hive_path="$1"
    local findings_file="$2"

    python3 << REGPY_EOF
import sys
try:
    from Registry import Registry
except ImportError:
    sys.exit(0)

hive_path = "$hive_path"
findings_file = "$findings_file"

# Common persistence keys to check
run_keys = [
    "Microsoft\\Windows\\CurrentVersion\\Run",
    "Microsoft\\Windows\\CurrentVersion\\RunOnce",
    "Microsoft\\Windows\\CurrentVersion\\RunServices",
    "Microsoft\\Windows\\CurrentVersion\\RunServicesOnce",
    "Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
]

suspicious_patterns = [
    "powershell", "cmd.exe", "wscript", "cscript", "mshta",
    "regsvr32", "rundll32", "certutil", "bitsadmin",
    "\\\\temp\\\\", "\\\\public\\\\", "\\\\downloads\\\\",
    "-enc", "-encodedcommand", "-e ", "frombase64",
]

try:
    reg = Registry.Registry(hive_path)

    with open(findings_file, 'a') as f:
        for key_path in run_keys:
            try:
                key = reg.open(key_path)
                for value in key.values():
                    val_data = str(value.value()).lower()
                    for pattern in suspicious_patterns:
                        if pattern.lower() in val_data:
                            f.write(f"[HIGH] Suspicious Run entry found:\\n")
                            f.write(f"  Key: {key_path}\\n")
                            f.write(f"  Name: {value.name()}\\n")
                            f.write(f"  Value: {value.value()}\\n")
                            f.write(f"  Pattern: {pattern}\\n\\n")
                            break
            except Registry.RegistryKeyNotFoundException:
                pass
            except Exception as e:
                pass

except Exception as e:
    pass
REGPY_EOF
}

scan_scheduled_tasks() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing scheduled tasks..."

    echo "" >> "$findings_file"
    echo "=== SCHEDULED TASKS ANALYSIS ===" >> "$findings_file"
    echo "" >> "$findings_file"

    local tasks_dir="$fs_path/Windows/System32/Tasks"
    local task_count=0
    local suspicious_tasks=0

    if [ ! -d "$tasks_dir" ]; then
        echo "Scheduled tasks directory not found" >> "$findings_file"
        return 0
    fi

    # Analyze each task XML file
    while IFS= read -r -d '' task_file; do
        ((task_count++))
        local task_name=$(basename "$task_file")

        # Parse XML for suspicious content
        if command -v xmllint &> /dev/null; then
            local command=$(xmllint --xpath "//Command/text()" "$task_file" 2>/dev/null || true)
            local arguments=$(xmllint --xpath "//Arguments/text()" "$task_file" 2>/dev/null || true)
        else
            # Fallback: grep-based analysis
            local command=$(grep -oP '(?<=<Command>)[^<]+' "$task_file" 2>/dev/null || true)
            local arguments=$(grep -oP '(?<=<Arguments>)[^<]+' "$task_file" 2>/dev/null || true)
        fi

        # Check for suspicious patterns
        local combined="$command $arguments"
        local is_suspicious=false

        if echo "$combined" | grep -qiE "(powershell|cmd\.exe.*\/c|wscript|cscript|mshta|certutil|bitsadmin)" 2>/dev/null; then
            is_suspicious=true
        fi

        if echo "$combined" | grep -qiE "(\\\\temp\\\\|\\\\public\\\\|\\\\appdata\\\\|base64|encodedcommand|-enc )" 2>/dev/null; then
            is_suspicious=true
        fi

        if [ "$is_suspicious" = true ]; then
            ((suspicious_tasks++))
            echo "[HIGH] Suspicious scheduled task: $task_name" >> "$findings_file"
            echo "  Command: $command" >> "$findings_file"
            echo "  Arguments: $arguments" >> "$findings_file"
            echo "  ATT&CK: ${ATTACK_TECHNIQUES[scheduled_task]}" >> "$findings_file"
            echo "" >> "$findings_file"
        fi

    done < <(find "$tasks_dir" -type f -print0 2>/dev/null)

    print_status "Analyzed $task_count scheduled tasks, $suspicious_tasks suspicious"
    STATS[persistence_tasks]=$suspicious_tasks

    return 0
}

scan_startup_folders() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing startup folders..."

    echo "" >> "$findings_file"
    echo "=== STARTUP FOLDER ANALYSIS ===" >> "$findings_file"
    echo "" >> "$findings_file"

    local -a startup_paths=(
        "ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp"
        "Users/*/AppData/Roaming/Microsoft/Windows/Start Menu/Programs/Startup"
    )

    local startup_items=0
    local suspicious_items=0

    for startup_pattern in "${startup_paths[@]}"; do
        while IFS= read -r -d '' startup_dir; do
            [ -d "$startup_dir" ] || continue

            while IFS= read -r -d '' item; do
                ((startup_items++))
                local item_name=$(basename "$item")
                local item_ext="${item_name##*.}"

                # Suspicious extensions in startup
                if echo "$item_ext" | grep -qiE "^(exe|bat|cmd|ps1|vbs|js|wsf|hta|scr|pif)$"; then
                    ((suspicious_items++))
                    echo "[MED] Executable in startup folder: $item_name" >> "$findings_file"
                    echo "  Path: $item" >> "$findings_file"

                    # Get file hash if possible
                    if command -v md5sum &> /dev/null; then
                        local hash=$(md5sum "$item" 2>/dev/null | awk '{print $1}')
                        [ -n "$hash" ] && echo "  MD5: $hash" >> "$findings_file"
                    fi

                    echo "  ATT&CK: ${ATTACK_TECHNIQUES[startup_folder]}" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi

                # Check for LNK files pointing to suspicious locations
                if [ "$item_ext" = "lnk" ]; then
                    # LNK parsing would require pylnk or similar
                    echo "[INFO] Shortcut in startup: $item_name" >> "$findings_file"
                fi

            done < <(find "$startup_dir" -type f -print0 2>/dev/null)

        done < <(find "$fs_path" -ipath "*$startup_pattern" -type d -print0 2>/dev/null)
    done

    print_status "Found $startup_items startup items, $suspicious_items suspicious"
    STATS[persistence_startup]=$suspicious_items

    return 0
}

scan_wmi_persistence() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing WMI persistence..."

    echo "" >> "$findings_file"
    echo "=== WMI PERSISTENCE ANALYSIS ===" >> "$findings_file"
    echo "" >> "$findings_file"

    # WMI repository location
    local wmi_repo="$fs_path/Windows/System32/wbem/Repository/OBJECTS.DATA"
    local wmi_findings=0

    if [ ! -f "$wmi_repo" ]; then
        echo "WMI repository not found" >> "$findings_file"
        return 0
    fi

    # Extract strings from WMI repository and look for event subscriptions
    if command -v strings &> /dev/null; then
        local wmi_strings=$(strings -n 10 "$wmi_repo" 2>/dev/null)

        # Look for CommandLineEventConsumer (common persistence method)
        if echo "$wmi_strings" | grep -qi "CommandLineEventConsumer"; then
            ((wmi_findings++))
            echo "[HIGH] CommandLineEventConsumer found in WMI repository" >> "$findings_file"
            echo "  This is commonly used for WMI persistence" >> "$findings_file"
            echo "  ATT&CK: ${ATTACK_TECHNIQUES[wmi_subscription]}" >> "$findings_file"
            echo "" >> "$findings_file"

            # Extract potential command lines
            echo "Potential commands in WMI:" >> "$findings_file"
            echo "$wmi_strings" | grep -iE "(powershell|cmd\.exe|wscript|cscript)" | head -10 >> "$findings_file"
            echo "" >> "$findings_file"
        fi

        # Look for ActiveScriptEventConsumer
        if echo "$wmi_strings" | grep -qi "ActiveScriptEventConsumer"; then
            ((wmi_findings++))
            echo "[HIGH] ActiveScriptEventConsumer found in WMI repository" >> "$findings_file"
            echo "  ATT&CK: ${ATTACK_TECHNIQUES[wmi_subscription]}" >> "$findings_file"
            echo "" >> "$findings_file"
        fi

        # Look for __EventFilter bindings
        if echo "$wmi_strings" | grep -qi "__EventFilter"; then
            echo "[INFO] WMI Event Filters detected (may be legitimate)" >> "$findings_file"
        fi
    fi

    print_status "WMI analysis complete, $wmi_findings suspicious findings"
    STATS[persistence_wmi]=$wmi_findings

    return 0
}

scan_service_persistence() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing services for persistence..."

    echo "" >> "$findings_file"
    echo "=== SERVICE PERSISTENCE ANALYSIS ===" >> "$findings_file"
    echo "" >> "$findings_file"

    local system_hive="$fs_path/Windows/System32/config/SYSTEM"
    local service_findings=0

    if [ ! -f "$system_hive" ]; then
        echo "SYSTEM hive not found" >> "$findings_file"
        return 0
    fi

    # Use RegRipper services plugin if available
    if [ -n "$REGRIPPER_PATH" ] || command -v rip.pl &> /dev/null; then
        local rip_cmd="${REGRIPPER_PATH:-rip.pl}"
        local services_output="$SCAN_OUTPUT_DIR/services_analysis.txt"

        perl "$rip_cmd" -r "$system_hive" -p services > "$services_output" 2>/dev/null || true

        if [ -f "$services_output" ] && [ -s "$services_output" ]; then
            # Look for services with suspicious paths
            while IFS= read -r line; do
                if echo "$line" | grep -qiE "(\\\\temp\\\\|\\\\public\\\\|\\\\appdata\\\\|\\\\users\\\\.*\\\\)"; then
                    ((service_findings++))
                    echo "[HIGH] Service with suspicious path:" >> "$findings_file"
                    echo "  $line" >> "$findings_file"
                    echo "  ATT&CK: ${ATTACK_TECHNIQUES[registry_services]}" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi

                # Services running PowerShell or cmd
                if echo "$line" | grep -qiE "(powershell|cmd\.exe.*\/c)"; then
                    ((service_findings++))
                    echo "[HIGH] Service executing scripts:" >> "$findings_file"
                    echo "  $line" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            done < "$services_output"
        fi
    fi

    print_status "Service analysis complete, $service_findings suspicious findings"
    STATS[persistence_services]=$service_findings

    return 0
}

# ==========================================
# EXECUTION ARTIFACT ANALYSIS
# ==========================================

scan_execution_artifacts() {
    print_section "Execution Artifact Analysis"

    # Check if we have access to filesystem (mounted or extracted)
    local fs_path=""
    if [ -n "$MOUNTED_FS_PATH" ] && [ -d "$MOUNTED_FS_PATH" ]; then
        fs_path="$MOUNTED_FS_PATH"
    elif [ -n "$MOUNT_POINT" ] && [ -d "$MOUNT_POINT" ]; then
        fs_path="$MOUNT_POINT"
    fi

    if [ -z "$fs_path" ]; then
        print_warning "Filesystem not mounted - attempting to locate artifacts in carved files"
        fs_path="$SCAN_OUTPUT_DIR"
    fi

    print_status "Analyzing program execution evidence..."

    local findings_file="$SCAN_OUTPUT_DIR/execution_findings.txt"
    local total_findings=0

    # Initialize findings file
    cat > "$findings_file" << 'EOF'
================================================================================
EXECUTION ARTIFACT ANALYSIS REPORT
================================================================================
Generated: $(date)

This report identifies evidence of program execution on the system.
High-confidence execution artifacts indicate programs that definitely ran.

EOF

    # 1. Prefetch Analysis (Windows XP+)
    scan_prefetch_artifacts "$fs_path" "$findings_file"

    # 2. Amcache Analysis (Windows 8+)
    scan_amcache_artifacts "$fs_path" "$findings_file"

    # 3. Shimcache/AppCompatCache Analysis
    scan_shimcache_artifacts "$fs_path" "$findings_file"

    # 4. UserAssist Analysis (GUI program execution)
    scan_userassist_artifacts "$fs_path" "$findings_file"

    # 5. SRUM Analysis (System Resource Usage Monitor)
    scan_srum_artifacts "$fs_path" "$findings_file"

    # 6. BAM/DAM Analysis (Background Activity Moderator)
    scan_bam_artifacts "$fs_path" "$findings_file"

    # 7. Execution Anomaly Detection
    detect_execution_anomalies "$fs_path" "$findings_file"

    # Calculate total findings
    total_findings=$((${STATS[execution_prefetch]} + ${STATS[execution_amcache]} + \
                      ${STATS[execution_shimcache]} + ${STATS[execution_userassist]} + \
                      ${STATS[execution_srum]} + ${STATS[execution_bam]} + \
                      ${STATS[execution_anomalies]:-0}))

    STATS[execution_findings]=$total_findings
    RESULTS["execution"]=$total_findings

    if [ $total_findings -gt 0 ]; then
        print_warning "Found $total_findings execution-related findings - review recommended"

        GUIDANCE_RECOMMENDATIONS+=("Review execution artifacts in $findings_file")

        if [ "$ATTACK_MAPPING" = true ]; then
            print_status "Execution evidence summary:"
            [ "${STATS[execution_prefetch]}" -gt 0 ] && echo "  - Prefetch: ${STATS[execution_prefetch]} suspicious entries"
            [ "${STATS[execution_amcache]}" -gt 0 ] && echo "  - Amcache: ${STATS[execution_amcache]} suspicious entries"
            [ "${STATS[execution_anomalies]:-0}" -gt 0 ] && echo "  - Anomalies: ${STATS[execution_anomalies]:-0} detected"
        fi
    else
        print_success "No suspicious execution artifacts detected"
        GUIDANCE_NO_ACTION+=("Execution artifact scan: No suspicious findings")
    fi

    return 0
}

scan_prefetch_artifacts() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing Prefetch files..."

    echo "" >> "$findings_file"
    echo "=== PREFETCH ANALYSIS ===" >> "$findings_file"
    echo "Prefetch files prove program execution with timestamps" >> "$findings_file"
    echo "" >> "$findings_file"

    local prefetch_dir="$fs_path/Windows/Prefetch"
    local prefetch_count=0
    local suspicious_prefetch=0

    if [ ! -d "$prefetch_dir" ]; then
        echo "Prefetch directory not found (may be disabled or non-Windows)" >> "$findings_file"
        STATS[execution_prefetch]=0
        return 0
    fi

    # Suspicious executable patterns (commonly abused by malware)
    local -a suspicious_names=(
        "POWERSHELL" "CMD" "WSCRIPT" "CSCRIPT" "MSHTA"
        "REGSVR32" "RUNDLL32" "CERTUTIL" "BITSADMIN"
        "MSIEXEC" "WMIC" "PSEXEC" "PROCDUMP"
        "MIMIKATZ" "LAZAGNE" "BLOODHOUND" "SHARPHOUND"
        "COBALTSTRIKE" "BEACON" "RUBEUS" "KERBEROAST"
    )

    # Suspicious path patterns
    local -a suspicious_paths=(
        "TEMP" "TMP" "PUBLIC" "DOWNLOADS" "APPDATA"
        "RECYCLE" "PROGRAMDATA\\\\TEMP"
    )

    # Python-based Prefetch parser
    if ! python3 << 'PREFETCH_EOF' 2>/dev/null
import sys
import os
import struct
from datetime import datetime, timedelta

prefetch_dir = os.environ.get('PREFETCH_DIR', sys.argv[1] if len(sys.argv) > 1 else '')
findings_file = os.environ.get('FINDINGS_FILE', sys.argv[2] if len(sys.argv) > 2 else '')

suspicious_names = [
    "POWERSHELL", "CMD", "WSCRIPT", "CSCRIPT", "MSHTA",
    "REGSVR32", "RUNDLL32", "CERTUTIL", "BITSADMIN",
    "MSIEXEC", "WMIC", "PSEXEC", "PROCDUMP",
    "MIMIKATZ", "LAZAGNE", "BLOODHOUND", "SHARPHOUND",
]

suspicious_paths = [
    "\\TEMP\\", "\\TMP\\", "\\PUBLIC\\", "\\DOWNLOADS\\",
    "\\APPDATA\\LOCAL\\TEMP", "\\RECYCLE", "\\PROGRAMDATA\\TEMP"
]

def parse_prefetch_basic(filepath):
    """Basic prefetch header parsing"""
    try:
        with open(filepath, 'rb') as f:
            # Read signature
            sig = f.read(4)
            if sig not in [b'SCCA', b'MAM\x04']:
                return None

            # Version detection
            f.seek(0)
            data = f.read(84)
            if len(data) < 84:
                return None

            version = struct.unpack('<I', data[0:4])[0]

            # Extract executable name (offset varies by version)
            if version == 0x17:  # Win XP/2003
                name_offset = 16
            elif version == 0x1A:  # Vista/7
                name_offset = 16
            elif version == 0x1E:  # Win 8
                name_offset = 16
            elif version == 0x1F:  # Win 10
                name_offset = 16
            else:
                name_offset = 16

            f.seek(name_offset)
            name_data = f.read(60)
            exe_name = name_data.decode('utf-16-le', errors='ignore').split('\x00')[0]

            # Run count (varies by version)
            f.seek(0x90 if version >= 0x1E else 0x90)
            run_count_data = f.read(4)
            run_count = struct.unpack('<I', run_count_data)[0] if len(run_count_data) == 4 else 0

            return {
                'name': exe_name,
                'version': version,
                'run_count': run_count
            }
    except Exception:
        return None

def analyze_prefetch(prefetch_dir, findings_file):
    suspicious_count = 0
    total_count = 0

    with open(findings_file, 'a') as f:
        for filename in os.listdir(prefetch_dir):
            if not filename.upper().endswith('.PF'):
                continue

            filepath = os.path.join(prefetch_dir, filename)
            total_count += 1

            pf_info = parse_prefetch_basic(filepath)
            if not pf_info:
                continue

            exe_name = pf_info.get('name', filename.split('-')[0]).upper()

            # Check suspicious names
            is_suspicious = False
            reason = ""

            for susp in suspicious_names:
                if susp in exe_name:
                    is_suspicious = True
                    reason = f"Potentially abused utility: {susp}"
                    break

            # Check high-entropy names (random alphanumeric)
            base_name = exe_name.split('.')[0]
            if len(base_name) >= 8 and base_name.isalnum():
                alpha_count = sum(1 for c in base_name if c.isalpha())
                digit_count = sum(1 for c in base_name if c.isdigit())
                if digit_count > 2 and alpha_count > 4:
                    is_suspicious = True
                    reason = "High-entropy executable name"

            if is_suspicious:
                suspicious_count += 1
                f.write(f"[MED] Suspicious prefetch: {filename}\n")
                f.write(f"  Executable: {pf_info.get('name', 'Unknown')}\n")
                f.write(f"  Run count: {pf_info.get('run_count', 'Unknown')}\n")
                f.write(f"  Reason: {reason}\n")
                f.write(f"  File: {filepath}\n\n")

        f.write(f"\nPrefetch Summary: {total_count} files analyzed, {suspicious_count} suspicious\n\n")

    print(f"PREFETCH_SUSPICIOUS={suspicious_count}")
    print(f"PREFETCH_TOTAL={total_count}")

if __name__ == '__main__':
    if os.path.isdir(prefetch_dir):
        analyze_prefetch(prefetch_dir, findings_file)
PREFETCH_EOF
    then
        : # Python succeeded
    else
        # Fallback: basic filename analysis
        while IFS= read -r -d '' pf_file; do
            ((prefetch_count++))
            local pf_name=$(basename "$pf_file")
            local exe_name="${pf_name%%-*}"

            # Check against suspicious names
            for pattern in "${suspicious_names[@]}"; do
                if echo "$exe_name" | grep -qi "$pattern"; then
                    ((suspicious_prefetch++))
                    echo "[INFO] Prefetch for potentially abused utility: $pf_name" >> "$findings_file"
                    if command -v stat &> /dev/null; then
                        local mtime=$(stat -c '%y' "$pf_file" 2>/dev/null || echo "Unknown")
                        echo "  Last modified: $mtime" >> "$findings_file"
                    fi
                    echo "" >> "$findings_file"
                    break
                fi
            done

            # High-entropy filenames (random strings often used by malware)
            if echo "$exe_name" | grep -qE '^[A-Z0-9]{8,}\.'; then
                ((suspicious_prefetch++))
                echo "[MED] High-entropy prefetch name: $pf_name" >> "$findings_file"
                echo "" >> "$findings_file"
            fi

        done < <(find "$prefetch_dir" -name "*.pf" -type f -print0 2>/dev/null)
    fi

    # Capture python output for stats
    local python_output
    python_output=$(PREFETCH_DIR="$prefetch_dir" FINDINGS_FILE="$findings_file" python3 2>/dev/null << 'PREFETCH_STATS'
import sys, os
prefetch_dir = os.environ.get('PREFETCH_DIR', '')
findings_file = os.environ.get('FINDINGS_FILE', '')
if os.path.isdir(prefetch_dir):
    count = len([f for f in os.listdir(prefetch_dir) if f.upper().endswith('.PF')])
    print(f"Analyzed {count} prefetch files")
PREFETCH_STATS
    ) || true

    # Count suspicious from findings file
    suspicious_prefetch=$(grep -c "^\[MED\]\|^\[HIGH\]" "$findings_file" 2>/dev/null | tail -1 || echo "0")

    print_status "Prefetch analysis complete: $prefetch_count files, $suspicious_prefetch suspicious"
    STATS[execution_prefetch]=$suspicious_prefetch

    return 0
}

scan_amcache_artifacts() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing Amcache (program execution history)..."

    echo "" >> "$findings_file"
    echo "=== AMCACHE ANALYSIS ===" >> "$findings_file"
    echo "Amcache tracks executables that ran on the system (Win8+)" >> "$findings_file"
    echo "" >> "$findings_file"

    local amcache_path="$fs_path/Windows/AppCompat/Programs/Amcache.hve"
    local suspicious_amcache=0

    if [ ! -f "$amcache_path" ]; then
        echo "Amcache.hve not found (pre-Win8 or not available)" >> "$findings_file"
        STATS[execution_amcache]=0
        return 0
    fi

    # Use RegRipper amcache plugin if available
    if [ -n "$REGRIPPER_PATH" ] || command -v rip.pl &> /dev/null; then
        local rip_cmd="${REGRIPPER_PATH:-rip.pl}"
        local amcache_output="$SCAN_OUTPUT_DIR/amcache_analysis.txt"

        perl "$rip_cmd" -r "$amcache_path" -p amcache > "$amcache_output" 2>/dev/null || true

        if [ -f "$amcache_output" ] && [ -s "$amcache_output" ]; then
            # Look for suspicious patterns
            while IFS= read -r line; do
                local is_suspicious=false

                # Executables from suspicious paths
                if echo "$line" | grep -qiE "(\\\\temp\\\\|\\\\public\\\\|\\\\appdata\\\\local\\\\temp|\\\\downloads\\\\|\\\\users\\\\[^\\\\]+\\\\appdata)"; then
                    is_suspicious=true
                fi

                # Known malware tools
                if echo "$line" | grep -qiE "(mimikatz|lazagne|procdump|psexec|cobaltstrike|beacon)"; then
                    is_suspicious=true
                fi

                if [ "$is_suspicious" = true ]; then
                    ((suspicious_amcache++))
                    echo "[HIGH] Suspicious Amcache entry:" >> "$findings_file"
                    echo "  $line" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            done < "$amcache_output"
        fi
    else
        # Python fallback using python-registry
        python3 << AMCACHE_PY 2>/dev/null || echo "  Amcache parsing requires RegRipper or python-registry" >> "$findings_file"
import sys
try:
    from Registry import Registry
except ImportError:
    sys.exit(0)

amcache_path = "$amcache_path"
findings_file = "$findings_file"

suspicious_paths = ["\\\\temp\\\\", "\\\\public\\\\", "\\\\downloads\\\\", "\\\\appdata\\\\local\\\\temp"]
suspicious_names = ["mimikatz", "lazagne", "procdump", "psexec", "beacon"]

suspicious_count = 0

try:
    reg = Registry.Registry(amcache_path)

    # Try to access InventoryApplicationFile key (Win10+)
    try:
        inv_key = reg.open("Root\\InventoryApplicationFile")
        for subkey in inv_key.subkeys():
            try:
                lower_path = ""
                for val in subkey.values():
                    if val.name().lower() == "lowercaselongpath":
                        lower_path = str(val.value()).lower()
                        break

                is_suspicious = False
                for susp_path in suspicious_paths:
                    if susp_path.lower() in lower_path:
                        is_suspicious = True
                        break

                for susp_name in suspicious_names:
                    if susp_name in lower_path:
                        is_suspicious = True
                        break

                if is_suspicious:
                    suspicious_count += 1
                    with open(findings_file, 'a') as f:
                        f.write(f"[HIGH] Suspicious Amcache entry:\\n")
                        f.write(f"  Path: {lower_path}\\n")
                        f.write(f"  Key: {subkey.name()}\\n\\n")

            except Exception:
                pass
    except Registry.RegistryKeyNotFoundException:
        pass

    print(f"AMCACHE_SUSPICIOUS={suspicious_count}")

except Exception as e:
    pass
AMCACHE_PY
    fi

    print_status "Amcache analysis complete: $suspicious_amcache suspicious entries"
    STATS[execution_amcache]=$suspicious_amcache

    return 0
}

scan_shimcache_artifacts() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing Shimcache/AppCompatCache..."

    echo "" >> "$findings_file"
    echo "=== SHIMCACHE ANALYSIS ===" >> "$findings_file"
    echo "Shimcache tracks file existence and may indicate execution" >> "$findings_file"
    echo "" >> "$findings_file"

    local system_hive="$fs_path/Windows/System32/config/SYSTEM"
    local suspicious_shimcache=0

    if [ ! -f "$system_hive" ]; then
        echo "SYSTEM hive not found for Shimcache analysis" >> "$findings_file"
        STATS[execution_shimcache]=0
        return 0
    fi

    # Use RegRipper appcompatcache plugin
    if [ -n "$REGRIPPER_PATH" ] || command -v rip.pl &> /dev/null; then
        local rip_cmd="${REGRIPPER_PATH:-rip.pl}"
        local shim_output="$SCAN_OUTPUT_DIR/shimcache_analysis.txt"

        perl "$rip_cmd" -r "$system_hive" -p appcompatcache > "$shim_output" 2>/dev/null || \
        perl "$rip_cmd" -r "$system_hive" -p shimcache > "$shim_output" 2>/dev/null || true

        if [ -f "$shim_output" ] && [ -s "$shim_output" ]; then
            # Look for suspicious patterns
            while IFS= read -r line; do
                local is_suspicious=false

                # Executables from temp/suspicious paths
                if echo "$line" | grep -qiE "(\\\\temp\\\\|\\\\public\\\\|\\\\appdata\\\\local\\\\temp|\\\\downloads\\\\|\\\\recycle)"; then
                    is_suspicious=true
                fi

                # Common malware names
                if echo "$line" | grep -qiE "(mimikatz|psexec|procdump|lazagne|bloodhound|sharphound|rubeus)"; then
                    is_suspicious=true
                fi

                # Suspicious utilities being executed
                if echo "$line" | grep -qiE "(certutil\.exe|bitsadmin\.exe|mshta\.exe|regsvr32\.exe).*\\\\(temp|public|appdata|downloads)"; then
                    is_suspicious=true
                fi

                if [ "$is_suspicious" = true ]; then
                    ((suspicious_shimcache++))
                    echo "[MED] Suspicious Shimcache entry:" >> "$findings_file"
                    echo "  $line" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            done < "$shim_output"
        fi
    fi

    print_status "Shimcache analysis complete: $suspicious_shimcache suspicious entries"
    STATS[execution_shimcache]=$suspicious_shimcache

    return 0
}

scan_userassist_artifacts() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing UserAssist (GUI program execution)..."

    echo "" >> "$findings_file"
    echo "=== USERASSIST ANALYSIS ===" >> "$findings_file"
    echo "UserAssist tracks GUI programs launched by users" >> "$findings_file"
    echo "" >> "$findings_file"

    local suspicious_userassist=0

    # Find all NTUSER.DAT files
    while IFS= read -r -d '' ntuser; do
        [ -f "$ntuser" ] || continue

        local user_path=$(dirname "$ntuser")
        local username=$(basename "$user_path")

        # Use RegRipper userassist plugin
        if [ -n "$REGRIPPER_PATH" ] || command -v rip.pl &> /dev/null; then
            local rip_cmd="${REGRIPPER_PATH:-rip.pl}"
            local ua_output="$SCAN_OUTPUT_DIR/userassist_${username}.txt"

            perl "$rip_cmd" -r "$ntuser" -p userassist > "$ua_output" 2>/dev/null || true

            if [ -f "$ua_output" ] && [ -s "$ua_output" ]; then
                # Look for suspicious programs
                while IFS= read -r line; do
                    local is_suspicious=false

                    # Programs run from suspicious locations
                    if echo "$line" | grep -qiE "(\\\\temp\\\\|\\\\public\\\\|\\\\downloads\\\\|\\\\appdata\\\\local\\\\temp)"; then
                        is_suspicious=true
                    fi

                    # Known malware or hacking tools
                    if echo "$line" | grep -qiE "(mimikatz|procdump|psexec|bloodhound|lazagne)"; then
                        is_suspicious=true
                    fi

                    if [ "$is_suspicious" = true ]; then
                        ((suspicious_userassist++))
                        echo "[MED] Suspicious UserAssist entry for $username:" >> "$findings_file"
                        echo "  $line" >> "$findings_file"
                        echo "" >> "$findings_file"
                    fi
                done < "$ua_output"
            fi
        fi

    done < <(find "$fs_path" -ipath "*/Users/*/NTUSER.DAT" -type f -print0 2>/dev/null)

    print_status "UserAssist analysis complete: $suspicious_userassist suspicious entries"
    STATS[execution_userassist]=$suspicious_userassist

    return 0
}

scan_srum_artifacts() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing SRUM (System Resource Usage Monitor)..."

    echo "" >> "$findings_file"
    echo "=== SRUM ANALYSIS ===" >> "$findings_file"
    echo "SRUM tracks application resource usage (network, CPU, etc.)" >> "$findings_file"
    echo "" >> "$findings_file"

    local srum_path="$fs_path/Windows/System32/sru/SRUDB.dat"
    local suspicious_srum=0

    if [ ! -f "$srum_path" ]; then
        echo "SRUM database not found (pre-Win8 or not available)" >> "$findings_file"
        STATS[execution_srum]=0
        return 0
    fi

    # SRUM requires ESE database parsing - check for tools
    if python3 -c "import pyesedb" 2>/dev/null; then
        python3 << SRUM_PY 2>/dev/null || echo "  SRUM parsing failed" >> "$findings_file"
import sys
import os

try:
    import pyesedb
except ImportError:
    sys.exit(0)

srum_path = "$srum_path"
findings_file = "$findings_file"

suspicious_apps = [
    "powershell", "cmd.exe", "wscript", "cscript", "mshta",
    "certutil", "bitsadmin", "regsvr32", "rundll32",
    "mimikatz", "psexec", "procdump", "lazagne"
]

suspicious_count = 0

try:
    ese_file = pyesedb.file()
    ese_file.open(srum_path)

    # Look for Application Resource Usage table
    for i in range(ese_file.number_of_tables):
        table = ese_file.get_table(i)
        if "Application" in table.name or "NetworkUsage" in table.name:
            for record_idx in range(table.number_of_records):
                try:
                    record = table.get_record(record_idx)
                    for col_idx in range(record.number_of_values):
                        value = record.get_value_data_as_string(col_idx)
                        if value:
                            value_lower = value.lower()
                            for susp_app in suspicious_apps:
                                if susp_app in value_lower:
                                    suspicious_count += 1
                                    with open(findings_file, 'a') as f:
                                        f.write(f"[INFO] SRUM tracked suspicious app: {value}\\n")
                                    break
                except Exception:
                    pass

    ese_file.close()
    print(f"SRUM_SUSPICIOUS={suspicious_count}")

except Exception as e:
    pass
SRUM_PY
    else
        echo "  SRUM parsing requires pyesedb Python module" >> "$findings_file"
        echo "  Install with: pip3 install pyesedb" >> "$findings_file"
    fi

    print_status "SRUM analysis complete: $suspicious_srum findings"
    STATS[execution_srum]=$suspicious_srum

    return 0
}

scan_bam_artifacts() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing BAM/DAM (Background Activity Monitor)..."

    echo "" >> "$findings_file"
    echo "=== BAM/DAM ANALYSIS ===" >> "$findings_file"
    echo "BAM tracks background application activity (Win10 1709+)" >> "$findings_file"
    echo "" >> "$findings_file"

    local system_hive="$fs_path/Windows/System32/config/SYSTEM"
    local suspicious_bam=0

    if [ ! -f "$system_hive" ]; then
        echo "SYSTEM hive not found for BAM analysis" >> "$findings_file"
        STATS[execution_bam]=0
        return 0
    fi

    # Use RegRipper bam plugin if available
    if [ -n "$REGRIPPER_PATH" ] || command -v rip.pl &> /dev/null; then
        local rip_cmd="${REGRIPPER_PATH:-rip.pl}"
        local bam_output="$SCAN_OUTPUT_DIR/bam_analysis.txt"

        perl "$rip_cmd" -r "$system_hive" -p bam > "$bam_output" 2>/dev/null || true

        if [ -f "$bam_output" ] && [ -s "$bam_output" ]; then
            while IFS= read -r line; do
                local is_suspicious=false

                # Executables from suspicious paths
                if echo "$line" | grep -qiE "(\\\\temp\\\\|\\\\public\\\\|\\\\appdata\\\\local\\\\temp|\\\\downloads\\\\)"; then
                    is_suspicious=true
                fi

                # Known attack tools
                if echo "$line" | grep -qiE "(mimikatz|psexec|procdump|lazagne|bloodhound|rubeus)"; then
                    is_suspicious=true
                fi

                if [ "$is_suspicious" = true ]; then
                    ((suspicious_bam++))
                    echo "[MED] Suspicious BAM entry:" >> "$findings_file"
                    echo "  $line" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            done < "$bam_output"
        fi
    else
        # Python fallback
        if python3 -c "from Registry import Registry" 2>/dev/null; then
            python3 << BAM_PY 2>/dev/null || true
import sys
try:
    from Registry import Registry
except ImportError:
    sys.exit(0)

system_hive = "$system_hive"
findings_file = "$findings_file"

suspicious_paths = ["\\\\temp\\\\", "\\\\public\\\\", "\\\\downloads\\\\", "\\\\appdata\\\\local\\\\temp"]
suspicious_names = ["mimikatz", "psexec", "procdump", "lazagne", "bloodhound"]

suspicious_count = 0

try:
    reg = Registry.Registry(system_hive)

    # BAM key location varies by Windows version
    bam_paths = [
        "ControlSet001\\Services\\bam\\State\\UserSettings",
        "ControlSet001\\Services\\bam\\UserSettings",
    ]

    for bam_path in bam_paths:
        try:
            bam_key = reg.open(bam_path)
            for sid_key in bam_key.subkeys():
                for value in sid_key.values():
                    val_name = value.name().lower()
                    is_suspicious = False

                    for susp_path in suspicious_paths:
                        if susp_path.lower() in val_name:
                            is_suspicious = True
                            break

                    for susp_name in suspicious_names:
                        if susp_name in val_name:
                            is_suspicious = True
                            break

                    if is_suspicious:
                        suspicious_count += 1
                        with open(findings_file, 'a') as f:
                            f.write(f"[MED] Suspicious BAM entry:\\n")
                            f.write(f"  Path: {value.name()}\\n")
                            f.write(f"  SID: {sid_key.name()}\\n\\n")

        except Registry.RegistryKeyNotFoundException:
            pass

    print(f"BAM_SUSPICIOUS={suspicious_count}")

except Exception:
    pass
BAM_PY
        fi
    fi

    print_status "BAM analysis complete: $suspicious_bam suspicious entries"
    STATS[execution_bam]=$suspicious_bam

    return 0
}

detect_execution_anomalies() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Detecting execution anomalies..."

    echo "" >> "$findings_file"
    echo "=== EXECUTION ANOMALY DETECTION ===" >> "$findings_file"
    echo "Looking for suspicious execution patterns and file characteristics" >> "$findings_file"
    echo "" >> "$findings_file"

    local anomaly_count=0

    # 1. High-entropy executable names in common execution locations
    print_status "  Checking for high-entropy filenames..."

    local -a exec_locations=(
        "Windows/Temp"
        "Users/*/AppData/Local/Temp"
        "Users/*/Downloads"
        "ProgramData"
        "Users/Public"
    )

    for loc_pattern in "${exec_locations[@]}"; do
        while IFS= read -r -d '' exec_file; do
            [ -f "$exec_file" ] || continue

            local filename=$(basename "$exec_file")
            local name_part="${filename%.*}"

            # Check for high-entropy names (random alphanumeric >= 8 chars)
            if echo "$name_part" | grep -qE '^[a-zA-Z0-9]{8,}$'; then
                local alpha_count=$(echo "$name_part" | tr -cd 'a-zA-Z' | wc -c)
                local digit_count=$(echo "$name_part" | tr -cd '0-9' | wc -c)

                # High entropy if mixed alpha/numeric
                if [ "$digit_count" -ge 2 ] && [ "$alpha_count" -ge 4 ]; then
                    ((anomaly_count++))
                    echo "[MED] High-entropy executable name:" >> "$findings_file"
                    echo "  File: $exec_file" >> "$findings_file"
                    echo "  Name: $filename" >> "$findings_file"

                    # Get file hash
                    if command -v sha256sum &> /dev/null; then
                        local hash=$(sha256sum "$exec_file" 2>/dev/null | awk '{print $1}')
                        [ -n "$hash" ] && echo "  SHA256: $hash" >> "$findings_file"
                    fi
                    echo "" >> "$findings_file"
                fi
            fi

        done < <(find "$fs_path" -ipath "*$loc_pattern*" \( -name "*.exe" -o -name "*.dll" -o -name "*.scr" \) -type f -print0 2>/dev/null)
    done

    # 2. Double extensions (e.g., document.pdf.exe)
    print_status "  Checking for double extensions..."

    while IFS= read -r -d '' file; do
        local filename=$(basename "$file")
        # Check for patterns like .pdf.exe, .doc.exe, etc.
        if echo "$filename" | grep -qiE '\.(pdf|doc|docx|xls|xlsx|jpg|png|txt|mp3|mp4)\.(exe|scr|bat|cmd|ps1|vbs|js)$'; then
            ((anomaly_count++))
            echo "[HIGH] Double extension detected (potential masquerading):" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "  ATT&CK: T1036.007 (Masquerading: Double File Extension)" >> "$findings_file"
            echo "" >> "$findings_file"
        fi
    done < <(find "$fs_path" -type f -print0 2>/dev/null | head -c 1000000)

    # 3. Executables with spaces before extension (e.g., "file .exe")
    print_status "  Checking for space-before-extension tricks..."

    while IFS= read -r -d '' file; do
        local filename=$(basename "$file")
        if echo "$filename" | grep -qE ' \.(exe|scr|bat|cmd|ps1|vbs|js)$'; then
            ((anomaly_count++))
            echo "[HIGH] Space-before-extension trick detected:" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "  ATT&CK: T1036 (Masquerading)" >> "$findings_file"
            echo "" >> "$findings_file"
        fi
    done < <(find "$fs_path" -type f -name "* .*" -print0 2>/dev/null)

    # 4. PE files with mismatched internal name vs filename (using pefile)
    print_status "  Checking for PE name mismatches..."

    if python3 -c "import pefile" 2>/dev/null; then
        python3 << PE_MISMATCH_PY 2>/dev/null || true
import sys
import os

try:
    import pefile
except ImportError:
    sys.exit(0)

fs_path = "$fs_path"
findings_file = "$findings_file"

suspicious_count = 0
checked = 0

temp_dirs = ["Temp", "Downloads", "Public", "AppData"]

for root, dirs, files in os.walk(fs_path):
    for filename in files:
        if not filename.lower().endswith(('.exe', '.dll')):
            continue

        # Only check files in suspicious locations
        if not any(td.lower() in root.lower() for td in temp_dirs):
            continue

        filepath = os.path.join(root, filename)
        checked += 1

        if checked > 500:  # Limit to prevent slowdown
            break

        try:
            pe = pefile.PE(filepath, fast_load=True)
            pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_RESOURCE']])

            internal_name = None
            original_filename = None

            if hasattr(pe, 'VS_VERSIONINFO'):
                for entry in pe.FileInfo:
                    if hasattr(entry, 'StringTable'):
                        for st in entry.StringTable:
                            for k, v in st.entries.items():
                                k_str = k.decode('utf-8', errors='ignore').lower()
                                v_str = v.decode('utf-8', errors='ignore')
                                if k_str == 'internalname':
                                    internal_name = v_str
                                elif k_str == 'originalfilename':
                                    original_filename = v_str

            # Check for mismatch
            if internal_name and original_filename:
                file_base = os.path.splitext(filename)[0].lower()
                internal_base = os.path.splitext(internal_name)[0].lower()

                # Significant mismatch (not just case or minor variation)
                if internal_base and file_base and internal_base != file_base:
                    if not (internal_base in file_base or file_base in internal_base):
                        suspicious_count += 1
                        with open(findings_file, 'a') as f:
                            f.write(f"[MED] PE internal name mismatch:\\n")
                            f.write(f"  File: {filepath}\\n")
                            f.write(f"  Filename: {filename}\\n")
                            f.write(f"  Internal name: {internal_name}\\n")
                            f.write(f"  Original filename: {original_filename}\\n")
                            f.write(f"  ATT&CK: T1036.005 (Masquerading: Match Name)\\n\\n")

            pe.close()

        except Exception:
            pass

    if checked > 500:
        break

print(f"PE_ANOMALIES={suspicious_count}")
PE_MISMATCH_PY
    fi

    # Store total anomalies
    STATS[execution_anomalies]=$anomaly_count

    print_status "Anomaly detection complete: $anomaly_count anomalies found"

    return 0
}

# ==========================================
# FILE ANOMALY DETECTION
# ==========================================

scan_file_anomalies() {
    print_section "File Anomaly Detection"

    # Check if we have access to filesystem
    local fs_path=""
    if [ -n "$MOUNTED_FS_PATH" ] && [ -d "$MOUNTED_FS_PATH" ]; then
        fs_path="$MOUNTED_FS_PATH"
    elif [ -n "$MOUNT_POINT" ] && [ -d "$MOUNT_POINT" ]; then
        fs_path="$MOUNT_POINT"
    fi

    if [ -z "$fs_path" ]; then
        print_warning "Filesystem not mounted - scanning carved files directory"
        fs_path="$SCAN_OUTPUT_DIR"
    fi

    print_status "Detecting file anomalies and masquerading techniques..."

    local findings_file="$SCAN_OUTPUT_DIR/file_anomalies.txt"
    local total_anomalies=0

    # Initialize findings file
    cat > "$findings_file" << 'EOF'
================================================================================
FILE ANOMALY DETECTION REPORT
================================================================================
Generated: $(date)

This report identifies file-level anomalies that may indicate malware or
anti-forensic techniques.

EOF

    # 1. Magic byte vs extension mismatch
    detect_magic_mismatch "$fs_path" "$findings_file"

    # 2. Alternate Data Streams (NTFS ADS)
    detect_alternate_data_streams "$fs_path" "$findings_file"

    # 3. Suspicious file locations
    detect_suspicious_file_locations "$fs_path" "$findings_file"

    # 4. Packer/crypter detection via section entropy
    detect_packed_executables "$fs_path" "$findings_file"

    # 5. Hidden and system attribute anomalies
    detect_attribute_anomalies "$fs_path" "$findings_file"

    # Calculate total findings
    total_anomalies=$((${STATS[file_extension_mismatch]} + ${STATS[file_ads]} + \
                       ${STATS[file_suspicious_paths]} + ${STATS[file_packed]:-0} + \
                       ${STATS[file_attribute_anomalies]:-0}))

    STATS[file_anomalies]=$total_anomalies
    RESULTS["file_anomalies"]=$total_anomalies

    if [ $total_anomalies -gt 0 ]; then
        print_warning "Found $total_anomalies file anomalies - review recommended"

        GUIDANCE_RECOMMENDATIONS+=("Review file anomalies in $findings_file")

        if [ "$ATTACK_MAPPING" = true ]; then
            print_status "Anomaly types detected:"
            [ "${STATS[file_extension_mismatch]}" -gt 0 ] && echo "  - Magic/extension mismatch: ${STATS[file_extension_mismatch]} (${ATTACK_TECHNIQUES[masquerading]})"
            [ "${STATS[file_ads]}" -gt 0 ] && echo "  - Alternate Data Streams: ${STATS[file_ads]}"
            [ "${STATS[file_packed]:-0}" -gt 0 ] && echo "  - Packed/encrypted executables: ${STATS[file_packed]:-0}"
        fi
    else
        print_success "No significant file anomalies detected"
        GUIDANCE_NO_ACTION+=("File anomaly detection: No suspicious findings")
    fi

    return 0
}

detect_magic_mismatch() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Checking for magic byte vs extension mismatches..."

    echo "" >> "$findings_file"
    echo "=== MAGIC BYTE / EXTENSION MISMATCH ===" >> "$findings_file"
    echo "Files where content type doesn't match extension (potential masquerading)" >> "$findings_file"
    echo "" >> "$findings_file"

    local mismatch_count=0

    # Define expected magic bytes for common extensions
    # Format: extension|expected_magic_pattern
    local -a magic_map=(
        "exe|MZ"
        "dll|MZ"
        "pdf|%PDF"
        "zip|PK"
        "docx|PK"
        "xlsx|PK"
        "pptx|PK"
        "jpg|JFIF|Exif|^\xff\xd8"
        "jpeg|JFIF|Exif|^\xff\xd8"
        "png|PNG"
        "gif|GIF8"
        "rar|Rar!"
        "7z|7z"
    )

    # Find files and check magic bytes
    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        local filename=$(basename "$file")
        local ext="${filename##*.}"
        ext=$(echo "$ext" | tr '[:upper:]' '[:lower:]')

        # Skip if no extension
        [ "$ext" = "$filename" ] && continue

        # Get first 16 bytes as hex
        local magic_hex=$(xxd -l 16 -p "$file" 2>/dev/null || continue)
        local magic_ascii=$(head -c 16 "$file" 2>/dev/null | tr -cd '[:print:]')

        local expected_type=""
        local actual_type=""
        local is_mismatch=false

        case "$ext" in
            exe|dll|scr)
                # Should start with MZ
                if [[ ! "$magic_ascii" =~ ^MZ ]]; then
                    is_mismatch=true
                    expected_type="PE executable (MZ)"
                    actual_type="$magic_ascii"
                fi
                ;;
            pdf)
                if [[ ! "$magic_ascii" =~ ^%PDF ]]; then
                    is_mismatch=true
                    expected_type="PDF (%PDF)"
                    actual_type="$magic_ascii"
                fi
                ;;
            zip|docx|xlsx|pptx|jar)
                if [[ ! "$magic_ascii" =~ ^PK ]]; then
                    is_mismatch=true
                    expected_type="ZIP archive (PK)"
                    actual_type="$magic_ascii"
                fi
                ;;
            jpg|jpeg)
                if [[ ! "$magic_hex" =~ ^ffd8 ]]; then
                    is_mismatch=true
                    expected_type="JPEG image"
                    actual_type="$magic_ascii"
                fi
                ;;
            png)
                if [[ ! "$magic_hex" =~ ^89504e47 ]]; then
                    is_mismatch=true
                    expected_type="PNG image"
                    actual_type="$magic_ascii"
                fi
                ;;
            gif)
                if [[ ! "$magic_ascii" =~ ^GIF8 ]]; then
                    is_mismatch=true
                    expected_type="GIF image"
                    actual_type="$magic_ascii"
                fi
                ;;
        esac

        if [ "$is_mismatch" = true ]; then
            ((mismatch_count++))

            # Check if it's actually an executable masquerading
            local severity="MED"
            if [[ "$magic_ascii" =~ ^MZ ]] && [[ ! "$ext" =~ ^(exe|dll|scr|sys)$ ]]; then
                severity="HIGH"
            fi

            echo "[$severity] Magic/extension mismatch:" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "  Extension: .$ext (expected: $expected_type)" >> "$findings_file"
            echo "  Actual magic: $actual_type" >> "$findings_file"
            echo "  Magic hex: ${magic_hex:0:32}" >> "$findings_file"

            # If it's an executable masquerading as something else
            if [[ "$magic_ascii" =~ ^MZ ]]; then
                echo "  WARNING: Executable masquerading as .$ext file!" >> "$findings_file"
                echo "  ATT&CK: ${ATTACK_TECHNIQUES[masquerading]}" >> "$findings_file"
            fi
            echo "" >> "$findings_file"
        fi

    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.pdf" -o -name "*.doc*" -o -name "*.xls*" -o -name "*.jpg" -o -name "*.jpeg" -o -name "*.png" -o -name "*.gif" -o -name "*.zip" \) -print0 2>/dev/null | head -c 2000000)

    # Also check for executables with document extensions
    print_status "  Checking for executables disguised as documents..."

    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        local magic_ascii=$(head -c 2 "$file" 2>/dev/null)

        if [[ "$magic_ascii" == "MZ" ]]; then
            ((mismatch_count++))
            echo "[HIGH] Executable disguised as document:" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "  This is a PE executable with a document extension!" >> "$findings_file"
            echo "  ATT&CK: ${ATTACK_TECHNIQUES[masquerading]}" >> "$findings_file"

            if command -v sha256sum &> /dev/null; then
                local hash=$(sha256sum "$file" 2>/dev/null | awk '{print $1}')
                [ -n "$hash" ] && echo "  SHA256: $hash" >> "$findings_file"
            fi
            echo "" >> "$findings_file"
        fi

    done < <(find "$fs_path" -type f \( -iname "*.pdf" -o -iname "*.doc" -o -iname "*.docx" -o -iname "*.xls" -o -iname "*.xlsx" -o -iname "*.txt" -o -iname "*.jpg" -o -iname "*.png" -o -iname "*.mp3" -o -iname "*.mp4" \) -print0 2>/dev/null)

    print_status "Magic/extension check complete: $mismatch_count mismatches found"
    STATS[file_extension_mismatch]=$mismatch_count

    return 0
}

detect_alternate_data_streams() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Checking for Alternate Data Streams (NTFS ADS)..."

    echo "" >> "$findings_file"
    echo "=== ALTERNATE DATA STREAMS (ADS) ===" >> "$findings_file"
    echo "Hidden data stored in NTFS alternate streams" >> "$findings_file"
    echo "" >> "$findings_file"

    local ads_count=0

    # ADS detection requires NTFS-3G or mounted NTFS filesystem
    # Check for $DATA stream indicators in file names
    while IFS= read -r -d '' file; do
        local filename=$(basename "$file")

        # Files with : in name indicate ADS (on Linux extraction)
        if [[ "$filename" == *":"* ]]; then
            ((ads_count++))
            echo "[MED] Alternate Data Stream detected:" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"

            # Get size
            local size=$(stat -c %s "$file" 2>/dev/null || echo "Unknown")
            echo "  Size: $size bytes" >> "$findings_file"

            # Check if it's an executable in ADS
            local magic_ascii=$(head -c 2 "$file" 2>/dev/null)
            if [[ "$magic_ascii" == "MZ" ]]; then
                echo "  WARNING: Executable hidden in ADS!" >> "$findings_file"
                echo "  ATT&CK: T1564.004 (Hide Artifacts: NTFS File Attributes)" >> "$findings_file"
            fi
            echo "" >> "$findings_file"
        fi

    done < <(find "$fs_path" -type f -name "*:*" -print0 2>/dev/null)

    # Also use getfattr if available (Linux NTFS-3G)
    if command -v getfattr &> /dev/null; then
        while IFS= read -r -d '' file; do
            local attrs=$(getfattr -d "$file" 2>/dev/null | grep -c "user\." || true)
            if [ "$attrs" -gt 0 ]; then
                # Check for suspicious extended attributes
                local attr_list=$(getfattr -d "$file" 2>/dev/null)
                if echo "$attr_list" | grep -qiE "(stream|data|zone\.identifier)"; then
                    ((ads_count++))
                    echo "[INFO] Extended attributes on file:" >> "$findings_file"
                    echo "  File: $file" >> "$findings_file"
                    echo "  Attributes: $attr_list" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            fi
        done < <(find "$fs_path" -type f -print0 2>/dev/null | head -c 500000)
    fi

    print_status "ADS detection complete: $ads_count streams found"
    STATS[file_ads]=$ads_count

    return 0
}

detect_suspicious_file_locations() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Checking for executables in suspicious locations..."

    echo "" >> "$findings_file"
    echo "=== SUSPICIOUS FILE LOCATIONS ===" >> "$findings_file"
    echo "Executables found in locations commonly abused by malware" >> "$findings_file"
    echo "" >> "$findings_file"

    local suspicious_count=0

    # Suspicious locations for executables
    local -a suspicious_paths=(
        "Windows/Temp"
        "Users/*/AppData/Local/Temp"
        "Users/Public"
        "Users/*/Downloads"
        '$Recycle.Bin'
        "System Volume Information"
        "ProgramData/Temp"
        "Recovery"
        "Windows/debug"
        "Windows/Fonts"  # Not a typical place for non-font files
    )

    for susp_pattern in "${suspicious_paths[@]}"; do
        while IFS= read -r -d '' exec_file; do
            [ -f "$exec_file" ] || continue

            local filename=$(basename "$exec_file")
            local ext="${filename##*.}"
            ext=$(echo "$ext" | tr '[:upper:]' '[:lower:]')

            # Check if it's an executable type
            if echo "$ext" | grep -qiE "^(exe|dll|scr|bat|cmd|ps1|vbs|js|wsf|hta|com|pif)$"; then
                ((suspicious_count++))

                # Determine severity
                local severity="MED"
                if echo "$exec_file" | grep -qiE '(\$Recycle\.Bin|System Volume Information)'; then
                    severity="HIGH"
                fi

                echo "[$severity] Executable in suspicious location:" >> "$findings_file"
                echo "  File: $exec_file" >> "$findings_file"
                echo "  Type: $ext" >> "$findings_file"

                # Get file info
                if command -v stat &> /dev/null; then
                    local mtime=$(stat -c '%y' "$exec_file" 2>/dev/null || echo "Unknown")
                    local size=$(stat -c '%s' "$exec_file" 2>/dev/null || echo "Unknown")
                    echo "  Modified: $mtime" >> "$findings_file"
                    echo "  Size: $size bytes" >> "$findings_file"
                fi

                # Get hash
                if command -v sha256sum &> /dev/null; then
                    local hash=$(sha256sum "$exec_file" 2>/dev/null | awk '{print $1}')
                    [ -n "$hash" ] && echo "  SHA256: $hash" >> "$findings_file"
                fi

                echo "  ATT&CK: ${ATTACK_TECHNIQUES[suspicious_execution_path]:-T1204.002}" >> "$findings_file"
                echo "" >> "$findings_file"
            fi

        done < <(find "$fs_path" -ipath "*$susp_pattern*" -type f -print0 2>/dev/null)
    done

    print_status "Location check complete: $suspicious_count suspicious files"
    STATS[file_suspicious_paths]=$suspicious_count

    return 0
}

detect_packed_executables() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Detecting packed/encrypted executables via entropy analysis..."

    echo "" >> "$findings_file"
    echo "=== PACKED/ENCRYPTED EXECUTABLE DETECTION ===" >> "$findings_file"
    echo "High-entropy sections indicate packing/encryption" >> "$findings_file"
    echo "" >> "$findings_file"

    local packed_count=0

    # Use pefile for PE analysis if available
    if python3 -c "import pefile" 2>/dev/null; then
        python3 << 'PACKER_PY'
import sys
import os
import math

try:
    import pefile
except ImportError:
    sys.exit(0)

fs_path = os.environ.get('FS_PATH', '')
findings_file = os.environ.get('FINDINGS_FILE', '')

if not fs_path or not findings_file:
    sys.exit(0)

def calculate_entropy(data):
    if len(data) == 0:
        return 0.0
    freq = [0] * 256
    for byte in data:
        freq[byte] += 1
    entropy = 0.0
    for f in freq:
        if f > 0:
            p = f / len(data)
            entropy -= p * math.log2(p)
    return entropy

packed_count = 0
checked = 0

# Known packer signatures
packer_signatures = {
    'UPX': [b'UPX0', b'UPX1', b'UPX!'],
    'ASPack': [b'.aspack', b'ASPack'],
    'FSG': [b'FSG!'],
    'PECompact': [b'PEC2'],
    'Themida': [b'.themida'],
    'VMProtect': [b'.vmp0', b'.vmp1'],
    'Enigma': [b'.enigma'],
}

# Walk filesystem looking for PE files
for root, dirs, files in os.walk(fs_path):
    for filename in files:
        if not filename.lower().endswith(('.exe', '.dll', '.scr', '.sys')):
            continue

        filepath = os.path.join(root, filename)
        checked += 1

        if checked > 1000:  # Limit for performance
            break

        try:
            pe = pefile.PE(filepath, fast_load=True)

            # Check for packer signatures in section names
            packer_detected = None
            for section in pe.sections:
                section_name = section.Name.rstrip(b'\x00').decode('utf-8', errors='ignore')
                for packer, sigs in packer_signatures.items():
                    for sig in sigs:
                        if sig in section.Name or sig.decode('utf-8', errors='ignore') in section_name:
                            packer_detected = packer
                            break

            # Calculate section entropies
            high_entropy_sections = []
            for section in pe.sections:
                section_name = section.Name.rstrip(b'\x00').decode('utf-8', errors='ignore')
                section_data = section.get_data()
                entropy = calculate_entropy(section_data)

                # High entropy threshold (>7.0 is very suspicious for code)
                if entropy > 7.0:
                    high_entropy_sections.append({
                        'name': section_name,
                        'entropy': entropy,
                        'size': len(section_data)
                    })

            # Report if packed or high entropy
            if packer_detected or len(high_entropy_sections) > 0:
                packed_count += 1
                with open(findings_file, 'a') as f:
                    if packer_detected:
                        f.write(f"[HIGH] Known packer detected: {packer_detected}\n")
                    else:
                        f.write(f"[MED] High-entropy executable (likely packed):\n")

                    f.write(f"  File: {filepath}\n")

                    for sec in high_entropy_sections:
                        f.write(f"  Section '{sec['name']}': entropy={sec['entropy']:.2f}, size={sec['size']}\n")

                    f.write(f"  ATT&CK: T1027.002 (Obfuscated Files: Software Packing)\n\n")

            pe.close()

        except Exception:
            pass

    if checked > 1000:
        break

print(f"PACKED_COUNT={packed_count}")
PACKER_PY
        local python_result
        python_result=$(FS_PATH="$fs_path" FINDINGS_FILE="$findings_file" python3 2>/dev/null << 'PACKER_STATS'
import sys, os, math

try:
    import pefile
except ImportError:
    print("PACKED_COUNT=0")
    sys.exit(0)

fs_path = os.environ.get('FS_PATH', '')
findings_file = os.environ.get('FINDINGS_FILE', '')

def calculate_entropy(data):
    if len(data) == 0:
        return 0.0
    freq = [0] * 256
    for byte in data:
        freq[byte] += 1
    entropy = 0.0
    for f in freq:
        if f > 0:
            p = f / len(data)
            entropy -= p * math.log2(p)
    return entropy

packed_count = 0
checked = 0

packer_signatures = {
    'UPX': [b'UPX0', b'UPX1', b'UPX!'],
    'ASPack': [b'.aspack'],
    'FSG': [b'FSG!'],
    'VMProtect': [b'.vmp0', b'.vmp1'],
}

for root, dirs, files in os.walk(fs_path):
    for filename in files:
        if not filename.lower().endswith(('.exe', '.dll', '.scr')):
            continue
        filepath = os.path.join(root, filename)
        checked += 1
        if checked > 1000:
            break
        try:
            pe = pefile.PE(filepath, fast_load=True)
            for section in pe.sections:
                section_name = section.Name.rstrip(b'\x00')
                for packer, sigs in packer_signatures.items():
                    for sig in sigs:
                        if sig in section_name:
                            packed_count += 1
                            with open(findings_file, 'a') as f:
                                f.write(f"[HIGH] Packer {packer}: {filepath}\n\n")
                            break
                section_data = section.get_data()
                if len(section_data) > 0 and calculate_entropy(section_data) > 7.2:
                    packed_count += 1
                    with open(findings_file, 'a') as f:
                        f.write(f"[MED] High entropy section in: {filepath}\n\n")
                    break
            pe.close()
        except:
            pass
    if checked > 1000:
        break

print(f"PACKED_COUNT={packed_count}")
PACKER_STATS
        ) || python_result="PACKED_COUNT=0"

        packed_count=$(echo "$python_result" | grep -oP 'PACKED_COUNT=\K\d+' || echo "0")
    else
        echo "  pefile module not available - install with: pip3 install pefile" >> "$findings_file"
    fi

    print_status "Packer detection complete: $packed_count packed files found"
    STATS[file_packed]=$packed_count

    return 0
}

detect_attribute_anomalies() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Checking for attribute anomalies..."

    echo "" >> "$findings_file"
    echo "=== FILE ATTRIBUTE ANOMALIES ===" >> "$findings_file"
    echo "Unusual file attributes that may indicate hiding" >> "$findings_file"
    echo "" >> "$findings_file"

    local anomaly_count=0

    # Files with very deep paths (>10 levels) - often used to hide malware
    print_status "  Checking for excessively deep paths..."

    while IFS= read -r file; do
        local depth=$(echo "$file" | tr '/' '\n' | wc -l)
        if [ "$depth" -gt 15 ]; then
            ((anomaly_count++))
            echo "[MED] Excessively deep path ($depth levels):" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "" >> "$findings_file"
        fi
    done < <(find "$fs_path" -type f 2>/dev/null | head -10000)

    # Files with Unicode tricks (RTL override, zero-width chars)
    print_status "  Checking for Unicode obfuscation..."

    while IFS= read -r -d '' file; do
        local filename=$(basename "$file")

        # Check for RTL override character (U+202E)
        if echo "$filename" | grep -qP '\x{202E}'; then
            ((anomaly_count++))
            echo "[HIGH] RTL Override character in filename:" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "  This can reverse displayed text to hide true extension!" >> "$findings_file"
            echo "  ATT&CK: T1036.002 (Masquerading: Right-to-Left Override)" >> "$findings_file"
            echo "" >> "$findings_file"
        fi

        # Check for zero-width characters
        if echo "$filename" | grep -qP '[\x{200B}\x{200C}\x{200D}\x{FEFF}]'; then
            ((anomaly_count++))
            echo "[MED] Zero-width characters in filename:" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "" >> "$findings_file"
        fi

    done < <(find "$fs_path" -type f -print0 2>/dev/null | head -c 500000)

    print_status "Attribute anomaly check complete: $anomaly_count anomalies"
    STATS[file_attribute_anomalies]=$anomaly_count

    return 0
}

# ==========================================
# REVERSE ENGINEERING TRIAGE
# ==========================================

scan_re_triage() {
    print_section "Reverse Engineering Triage"

    # Check if we have access to filesystem
    local fs_path=""
    if [ -n "$MOUNTED_FS_PATH" ] && [ -d "$MOUNTED_FS_PATH" ]; then
        fs_path="$MOUNTED_FS_PATH"
    elif [ -n "$MOUNT_POINT" ] && [ -d "$MOUNT_POINT" ]; then
        fs_path="$MOUNT_POINT"
    fi

    # Also check carved files
    local carved_dir="$SCAN_OUTPUT_DIR/carved"
    if [ ! -d "$carved_dir" ]; then
        carved_dir="$SCAN_OUTPUT_DIR"
    fi

    if [ -z "$fs_path" ]; then
        fs_path="$carved_dir"
    fi

    print_status "Running automated RE triage on suspicious executables..."

    local findings_file="$SCAN_OUTPUT_DIR/re_triage.txt"
    local total_findings=0

    # Initialize findings file
    cat > "$findings_file" << 'EOF'
================================================================================
REVERSE ENGINEERING TRIAGE REPORT
================================================================================
Generated: $(date)

Automated analysis of suspicious executables for malware indicators.

EOF

    # 1. capa analysis (MITRE ATT&CK capability mapping)
    run_capa_analysis "$fs_path" "$findings_file"

    # 2. Suspicious API import analysis
    analyze_suspicious_imports "$fs_path" "$findings_file"

    # 3. Similarity hashing (ssdeep, imphash)
    compute_similarity_hashes "$fs_path" "$findings_file"

    # 4. Shellcode detection
    detect_shellcode_patterns "$fs_path" "$findings_file"

    # 5. String analysis for IOCs
    extract_suspicious_strings "$fs_path" "$findings_file"

    # Calculate total findings
    total_findings=$((${STATS[re_capa_matches]} + ${STATS[re_suspicious_imports]} + \
                      ${STATS[re_shellcode_detected]} + ${STATS[re_suspicious_strings]:-0}))

    STATS[re_triaged_files]=$total_findings
    RESULTS["re_triage"]=$total_findings

    if [ $total_findings -gt 0 ]; then
        print_warning "Found $total_findings RE triage findings - detailed analysis recommended"

        GUIDANCE_RECOMMENDATIONS+=("Review RE triage results in $findings_file")
        GUIDANCE_RECOMMENDATIONS+=("Consider submitting suspicious files to sandbox for dynamic analysis")

        if [ "$ATTACK_MAPPING" = true ] && [ -n "${STATS[re_attack_techniques]}" ]; then
            print_status "MITRE ATT&CK techniques detected:"
            echo "${STATS[re_attack_techniques]}" | tr ',' '\n' | sort -u | head -20 | while read tech; do
                [ -n "$tech" ] && echo "  - $tech"
            done
        fi
    else
        print_success "No significant RE triage findings"
        GUIDANCE_NO_ACTION+=("RE triage: No suspicious capabilities detected")
    fi

    return 0
}

run_capa_analysis() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Running capa analysis (ATT&CK capability detection)..."

    echo "" >> "$findings_file"
    echo "=== CAPA ANALYSIS ===" >> "$findings_file"
    echo "Automated capability detection mapped to MITRE ATT&CK" >> "$findings_file"
    echo "" >> "$findings_file"

    local capa_matches=0
    local attack_techniques=""

    # Check if capa is available
    local capa_cmd=""
    if [ -n "$CAPA_PATH" ] && [ -x "$CAPA_PATH" ]; then
        capa_cmd="$CAPA_PATH"
    elif command -v capa &> /dev/null; then
        capa_cmd="capa"
    elif [ -x "$PORTABLE_TOOLS_DIR/capa" ]; then
        capa_cmd="$PORTABLE_TOOLS_DIR/capa"
    fi

    if [ -z "$capa_cmd" ]; then
        echo "  capa not available - install with: install_capa_portable" >> "$findings_file"
        echo "  Download from: https://github.com/mandiant/capa/releases" >> "$findings_file"
        STATS[re_capa_matches]=0
        return 0
    fi

    # Find suspicious executables to analyze
    local -a target_files=()

    # Prioritize files from suspicious locations
    while IFS= read -r -d '' file; do
        target_files+=("$file")
        [ ${#target_files[@]} -ge 50 ] && break  # Limit for performance
    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.scr" \) \
             \( -path "*Temp*" -o -path "*Downloads*" -o -path "*Public*" -o -path "*AppData*" \) \
             -print0 2>/dev/null)

    # Also check carved files
    while IFS= read -r -d '' file; do
        target_files+=("$file")
        [ ${#target_files[@]} -ge 100 ] && break
    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" \) -print0 2>/dev/null)

    local analyzed=0
    for target in "${target_files[@]}"; do
        [ -f "$target" ] || continue

        local capa_output
        capa_output=$("$capa_cmd" -q -j "$target" 2>/dev/null) || continue

        ((analyzed++))

        # Parse JSON output for ATT&CK techniques
        if echo "$capa_output" | grep -q "attack"; then
            local techniques=$(echo "$capa_output" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    if 'rules' in data:
        for rule_name, rule_data in data['rules'].items():
            if 'attack' in rule_data.get('meta', {}):
                for attack in rule_data['meta']['attack']:
                    print(f\"{attack.get('technique', '')} - {attack.get('id', '')}\")
except:
    pass
" 2>/dev/null)

            if [ -n "$techniques" ]; then
                ((capa_matches++))
                echo "[HIGH] capa matches for: $(basename "$target")" >> "$findings_file"
                echo "  File: $target" >> "$findings_file"
                echo "  ATT&CK techniques detected:" >> "$findings_file"
                echo "$techniques" | head -10 | sed 's/^/    - /' >> "$findings_file"

                # Collect techniques for summary
                local tech_ids=$(echo "$techniques" | grep -oE 'T[0-9]+(\.[0-9]+)?' | tr '\n' ',' | sed 's/,$//')
                attack_techniques="${attack_techniques}${tech_ids},"

                echo "" >> "$findings_file"
            fi
        fi

    done

    print_status "capa analysis complete: analyzed $analyzed files, $capa_matches with capabilities"
    STATS[re_capa_matches]=$capa_matches
    STATS[re_attack_techniques]="${STATS[re_attack_techniques]}${attack_techniques}"

    return 0
}

analyze_suspicious_imports() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing suspicious API imports..."

    echo "" >> "$findings_file"
    echo "=== SUSPICIOUS API IMPORT ANALYSIS ===" >> "$findings_file"
    echo "Detecting imports commonly used by malware" >> "$findings_file"
    echo "" >> "$findings_file"

    local suspicious_count=0

    # Suspicious API categories
    # Process Injection APIs
    local -a injection_apis=(
        "CreateRemoteThread" "NtCreateThreadEx" "RtlCreateUserThread"
        "WriteProcessMemory" "NtWriteVirtualMemory"
        "VirtualAllocEx" "NtAllocateVirtualMemory"
        "NtMapViewOfSection" "ZwMapViewOfSection"
        "SetThreadContext" "NtSetContextThread"
        "QueueUserAPC" "NtQueueApcThread"
    )

    # Process Hollowing APIs (user emphasized this!)
    local -a hollowing_apis=(
        "NtUnmapViewOfSection" "ZwUnmapViewOfSection"
        "NtResumeThread" "ResumeThread"
        "SetThreadContext" "NtSetContextThread"
        "NtWriteVirtualMemory" "WriteProcessMemory"
        "CreateProcess.*SUSPENDED"
    )

    # Evasion APIs
    local -a evasion_apis=(
        "IsDebuggerPresent" "CheckRemoteDebuggerPresent"
        "NtQueryInformationProcess" "NtSetInformationThread"
        "GetTickCount" "QueryPerformanceCounter"
        "OutputDebugString"
    )

    # Credential Access APIs
    local -a credential_apis=(
        "CredEnumerate" "CredRead"
        "LsaRetrievePrivateData" "LsaStorePrivateData"
        "CryptUnprotectData" "CryptProtectData"
        "SamConnect" "SamEnumerateUsersInDomain"
    )

    # Persistence APIs
    local -a persistence_apis=(
        "RegSetValueEx" "RegCreateKeyEx"
        "CreateService" "StartService"
        "SetWindowsHookEx"
    )

    if python3 -c "import pefile" 2>/dev/null; then
        python3 << 'IMPORT_ANALYSIS_PY'
import sys
import os

try:
    import pefile
except ImportError:
    sys.exit(0)

fs_path = os.environ.get('FS_PATH', '')
findings_file = os.environ.get('FINDINGS_FILE', '')

# Suspicious API categories
api_categories = {
    "Process Injection": [
        "CreateRemoteThread", "NtCreateThreadEx", "RtlCreateUserThread",
        "WriteProcessMemory", "NtWriteVirtualMemory",
        "VirtualAllocEx", "NtAllocateVirtualMemory",
        "NtMapViewOfSection", "ZwMapViewOfSection",
        "QueueUserAPC", "NtQueueApcThread",
    ],
    "Process Hollowing": [
        "NtUnmapViewOfSection", "ZwUnmapViewOfSection",
        "NtResumeThread", "ResumeThread",
        "SetThreadContext", "NtSetContextThread",
    ],
    "Anti-Debug/Evasion": [
        "IsDebuggerPresent", "CheckRemoteDebuggerPresent",
        "NtQueryInformationProcess", "NtSetInformationThread",
        "GetTickCount", "QueryPerformanceCounter",
    ],
    "Credential Access": [
        "CredEnumerate", "CredRead",
        "LsaRetrievePrivateData", "CryptUnprotectData",
        "SamConnect", "SamEnumerateUsersInDomain",
    ],
    "Persistence": [
        "RegSetValueEx", "RegCreateKeyEx",
        "CreateServiceA", "CreateServiceW", "StartService",
        "SetWindowsHookEx",
    ],
}

attack_mapping = {
    "Process Injection": "T1055",
    "Process Hollowing": "T1055.012",
    "Anti-Debug/Evasion": "T1497",
    "Credential Access": "T1003",
    "Persistence": "T1547",
}

suspicious_count = 0
checked = 0

for root, dirs, files in os.walk(fs_path):
    for filename in files:
        if not filename.lower().endswith(('.exe', '.dll', '.scr')):
            continue

        filepath = os.path.join(root, filename)
        checked += 1

        if checked > 500:
            break

        try:
            pe = pefile.PE(filepath, fast_load=True)
            pe.parse_data_directories(directories=[
                pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']
            ])

            if not hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                pe.close()
                continue

            # Collect all imports
            imports = []
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8', errors='ignore')
                for imp in entry.imports:
                    if imp.name:
                        imports.append(imp.name.decode('utf-8', errors='ignore'))

            # Check against suspicious categories
            file_findings = {}
            for category, apis in api_categories.items():
                matched = [api for api in apis if any(api.lower() in imp.lower() for imp in imports)]
                if matched:
                    file_findings[category] = matched

            if file_findings:
                suspicious_count += 1
                with open(findings_file, 'a') as f:
                    # Determine severity
                    severity = "MED"
                    if "Process Hollowing" in file_findings or "Process Injection" in file_findings:
                        severity = "HIGH"

                    f.write(f"[{severity}] Suspicious imports in: {filename}\n")
                    f.write(f"  File: {filepath}\n")

                    for category, apis in file_findings.items():
                        f.write(f"  {category} ({attack_mapping.get(category, 'N/A')}):\n")
                        for api in apis[:5]:  # Limit to first 5
                            f.write(f"    - {api}\n")

                    f.write("\n")

            pe.close()

        except Exception:
            pass

    if checked > 500:
        break

print(f"SUSPICIOUS_IMPORTS={suspicious_count}")
IMPORT_ANALYSIS_PY
        local python_result
        python_result=$(FS_PATH="$fs_path" FINDINGS_FILE="$findings_file" python3 2>/dev/null << 'IMPORT_STATS'
import sys, os
try:
    import pefile
except ImportError:
    print("SUSPICIOUS_IMPORTS=0")
    sys.exit(0)

fs_path = os.environ.get('FS_PATH', '')
findings_file = os.environ.get('FINDINGS_FILE', '')

hollowing_apis = ["NtUnmapViewOfSection", "ZwUnmapViewOfSection", "SetThreadContext"]
injection_apis = ["CreateRemoteThread", "WriteProcessMemory", "VirtualAllocEx", "NtMapViewOfSection"]

suspicious_count = 0
checked = 0

for root, dirs, files in os.walk(fs_path):
    for filename in files:
        if not filename.lower().endswith(('.exe', '.dll')):
            continue
        filepath = os.path.join(root, filename)
        checked += 1
        if checked > 500:
            break
        try:
            pe = pefile.PE(filepath, fast_load=True)
            pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']])
            if not hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                pe.close()
                continue
            imports = []
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                for imp in entry.imports:
                    if imp.name:
                        imports.append(imp.name.decode('utf-8', errors='ignore'))
            all_suspicious = hollowing_apis + injection_apis
            matched = [api for api in all_suspicious if any(api.lower() in imp.lower() for imp in imports)]
            if matched:
                suspicious_count += 1
                with open(findings_file, 'a') as f:
                    f.write(f"[HIGH] Injection/Hollowing APIs in: {filepath}\n")
                    f.write(f"  APIs: {', '.join(matched)}\n\n")
            pe.close()
        except:
            pass
    if checked > 500:
        break

print(f"SUSPICIOUS_IMPORTS={suspicious_count}")
IMPORT_STATS
        ) || python_result="SUSPICIOUS_IMPORTS=0"

        suspicious_count=$(echo "$python_result" | grep -oP 'SUSPICIOUS_IMPORTS=\K\d+' || echo "0")
    else
        echo "  pefile module not available for import analysis" >> "$findings_file"
        suspicious_count=0
    fi

    print_status "Import analysis complete: $suspicious_count files with suspicious imports"
    STATS[re_suspicious_imports]=$suspicious_count

    return 0
}

compute_similarity_hashes() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Computing similarity hashes (imphash, ssdeep)..."

    echo "" >> "$findings_file"
    echo "=== SIMILARITY HASHING ===" >> "$findings_file"
    echo "Fuzzy hashes for malware family correlation" >> "$findings_file"
    echo "" >> "$findings_file"

    local hash_file="$SCAN_OUTPUT_DIR/similarity_hashes.csv"
    echo "filename,sha256,imphash,ssdeep" > "$hash_file"

    local processed=0

    # Compute hashes for executables
    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue
        ((processed++))

        local filename=$(basename "$file")
        local sha256=""
        local imphash=""
        local ssdeep_hash=""

        # SHA256
        if command -v sha256sum &> /dev/null; then
            sha256=$(sha256sum "$file" 2>/dev/null | awk '{print $1}')
        fi

        # imphash (requires pefile)
        if python3 -c "import pefile" 2>/dev/null; then
            imphash=$(python3 -c "
import pefile
import sys
try:
    pe = pefile.PE('$file', fast_load=True)
    pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']])
    print(pe.get_imphash() or '')
    pe.close()
except:
    pass
" 2>/dev/null)
        fi

        # ssdeep
        if command -v ssdeep &> /dev/null; then
            ssdeep_hash=$(ssdeep -b "$file" 2>/dev/null | tail -1 | cut -d',' -f1)
        fi

        # Write to CSV
        echo "\"$filename\",\"$sha256\",\"$imphash\",\"$ssdeep_hash\"" >> "$hash_file"

    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.scr" \) -print0 2>/dev/null | head -c 500000)

    echo "Hashes computed for $processed executables" >> "$findings_file"
    echo "Hash CSV: $hash_file" >> "$findings_file"
    echo "" >> "$findings_file"

    # Check for known bad imphashes (common malware families)
    local -a known_bad_imphashes=(
        "d41d8cd98f00b204e9800998ecf8427e"  # Empty import table
        "81c39c9f04c951a456bf3016ae56c2ac"  # Emotet variant
        "6e0f8c0e8c0c0c8d8e8f8f0f0f8e8c8d"  # Example - replace with real IOCs
    )

    if [ -f "$hash_file" ]; then
        while IFS=',' read -r fn sha imp ssdeep; do
            [ "$fn" = "filename" ] && continue  # Skip header
            imp=$(echo "$imp" | tr -d '"')

            for bad_hash in "${known_bad_imphashes[@]}"; do
                if [ "$imp" = "$bad_hash" ]; then
                    echo "[HIGH] Known malicious imphash match:" >> "$findings_file"
                    echo "  File: $fn" >> "$findings_file"
                    echo "  Imphash: $imp" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            done
        done < "$hash_file"
    fi

    print_status "Similarity hashing complete: $processed files processed"

    return 0
}

detect_shellcode_patterns() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Detecting shellcode patterns..."

    echo "" >> "$findings_file"
    echo "=== SHELLCODE DETECTION ===" >> "$findings_file"
    echo "Common shellcode patterns and position-independent code indicators" >> "$findings_file"
    echo "" >> "$findings_file"

    local shellcode_count=0

    # Common shellcode patterns (hex)
    local -a shellcode_signatures=(
        # GetPC techniques (position-independent code)
        "e8.*00.*00.*00.*00.*58"    # call $+5; pop eax
        "e8.*00.*00.*00.*00.*5b"    # call $+5; pop ebx
        "eb.*5e"                     # jmp short; pop esi
        "d9.*74.*24"                 # fnstenv [esp-c]

        # API hashing (common in shellcode)
        "64.*a1.*30.*00.*00.*00"    # mov eax, fs:[30h] (PEB access)
        "64.*8b.*1d.*30.*00.*00"    # mov ebx, fs:[30h]

        # Metasploit patterns
        "fc.*e8.*.*00.*00.*00"      # cld; call
        "31.*c9.*64.*8b"            # xor ecx,ecx; mov..fs:

        # Cobalt Strike beacon patterns
        "4d.*5a.*41.*52.*55.*48"    # MZ header in shellcode
    )

    # Search for shellcode patterns in files
    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        local filename=$(basename "$file")
        local file_hex=$(xxd -p "$file" 2>/dev/null | tr -d '\n' | head -c 100000)

        for pattern in "${shellcode_signatures[@]}"; do
            if echo "$file_hex" | grep -qiE "$pattern"; then
                ((shellcode_count++))
                echo "[HIGH] Shellcode pattern detected:" >> "$findings_file"
                echo "  File: $file" >> "$findings_file"
                echo "  Pattern: $pattern" >> "$findings_file"
                echo "  ATT&CK: T1059.006 (Command and Scripting Interpreter: Python)" >> "$findings_file"
                echo "" >> "$findings_file"
                break
            fi
        done

    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.bin" -o -name "*.dat" -o -name "*.tmp" \) -size -10M -print0 2>/dev/null | head -c 500000)

    # Also check for raw shellcode files
    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        local file_size=$(stat -c %s "$file" 2>/dev/null || echo "0")

        # Small files with high entropy might be shellcode
        if [ "$file_size" -lt 100000 ] && [ "$file_size" -gt 100 ]; then
            local entropy=$(python3 -c "
import math
import sys
data = open('$file', 'rb').read()
if len(data) == 0:
    print(0)
    sys.exit()
freq = [0]*256
for b in data:
    freq[b] += 1
ent = 0
for f in freq:
    if f > 0:
        p = f/len(data)
        ent -= p * math.log2(p)
print(f'{ent:.2f}')
" 2>/dev/null || echo "0")

            if (( $(echo "$entropy > 7.5" | bc -l 2>/dev/null || echo 0) )); then
                # High entropy small file - check for shellcode indicators
                local magic=$(xxd -l 10 -p "$file" 2>/dev/null)
                # Not a PE file
                if [[ ! "$magic" =~ ^4d5a ]]; then
                    ((shellcode_count++))
                    echo "[MED] Potential shellcode (high entropy small file):" >> "$findings_file"
                    echo "  File: $file" >> "$findings_file"
                    echo "  Size: $file_size bytes" >> "$findings_file"
                    echo "  Entropy: $entropy" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            fi
        fi

    done < <(find "$fs_path" -type f \( -name "*.bin" -o -name "*.dat" -o -name "*.tmp" -o -name "*.raw" \) -print0 2>/dev/null | head -c 200000)

    print_status "Shellcode detection complete: $shellcode_count potential shellcode found"
    STATS[re_shellcode_detected]=$shellcode_count

    return 0
}

extract_suspicious_strings() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Extracting suspicious strings (IOCs, URLs, IPs)..."

    echo "" >> "$findings_file"
    echo "=== SUSPICIOUS STRING EXTRACTION ===" >> "$findings_file"
    echo "URLs, IPs, and potential IOCs found in executables" >> "$findings_file"
    echo "" >> "$findings_file"

    local strings_file="$SCAN_OUTPUT_DIR/extracted_strings.txt"
    local suspicious_strings=0

    # IOC patterns
    local ip_pattern='([0-9]{1,3}\.){3}[0-9]{1,3}'
    local url_pattern='https?://[a-zA-Z0-9\.\-_/\?=&%]+'
    local email_pattern='[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}'

    # Suspicious string patterns
    local -a suspicious_patterns=(
        "powershell"
        "cmd.exe"
        "WScript.Shell"
        "HKEY_"
        "\\\\\\\\.*\\\\.*"  # UNC paths
        "bitcoin"
        "ransom"
        "decrypt"
        "password"
        "mimikatz"
        "sekurlsa"
        "lsadump"
        "hashdump"
        "CobaltStrike"
        "beacon"
        "meterpreter"
        "reverse_tcp"
        "bind_shell"
    )

    echo "# Extracted suspicious strings" > "$strings_file"
    echo "# Generated: $(date)" >> "$strings_file"
    echo "" >> "$strings_file"

    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        local filename=$(basename "$file")

        # Extract strings
        local file_strings=$(strings -n 6 "$file" 2>/dev/null)

        # Check for IPs (excluding common internal/local)
        local ips=$(echo "$file_strings" | grep -oE "$ip_pattern" | grep -vE '^(127\.|10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[01])\.|0\.0\.0\.|255\.255)' | sort -u)

        # Check for URLs
        local urls=$(echo "$file_strings" | grep -oiE "$url_pattern" | sort -u)

        # Check for suspicious patterns
        local found_suspicious=""
        for pattern in "${suspicious_patterns[@]}"; do
            if echo "$file_strings" | grep -qi "$pattern"; then
                found_suspicious="${found_suspicious}${pattern}, "
            fi
        done

        # Report if interesting strings found
        if [ -n "$ips" ] || [ -n "$urls" ] || [ -n "$found_suspicious" ]; then
            ((suspicious_strings++))

            echo "[INFO] Interesting strings in: $filename" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"

            if [ -n "$ips" ]; then
                echo "  External IPs:" >> "$findings_file"
                echo "$ips" | head -5 | sed 's/^/    /' >> "$findings_file"
            fi

            if [ -n "$urls" ]; then
                echo "  URLs:" >> "$findings_file"
                echo "$urls" | head -5 | sed 's/^/    /' >> "$findings_file"
            fi

            if [ -n "$found_suspicious" ]; then
                echo "  Suspicious keywords: ${found_suspicious%, }" >> "$findings_file"
            fi

            echo "" >> "$findings_file"

            # Also save to strings file
            echo "=== $filename ===" >> "$strings_file"
            [ -n "$ips" ] && echo "IPs: $ips" >> "$strings_file"
            [ -n "$urls" ] && echo "URLs: $urls" >> "$strings_file"
            echo "" >> "$strings_file"
        fi

    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.scr" \) -print0 2>/dev/null | head -c 500000)

    print_status "String extraction complete: $suspicious_strings files with interesting strings"
    STATS[re_suspicious_strings]=$suspicious_strings

    return 0
}

# ==========================================
# FILESYSTEM FORENSICS
# ==========================================

scan_filesystem_forensics() {
    print_section "Filesystem Forensics Analysis"

    # Check if we have access to filesystem
    local fs_path=""
    if [ -n "$MOUNTED_FS_PATH" ] && [ -d "$MOUNTED_FS_PATH" ]; then
        fs_path="$MOUNTED_FS_PATH"
    elif [ -n "$MOUNT_POINT" ] && [ -d "$MOUNT_POINT" ]; then
        fs_path="$MOUNT_POINT"
    fi

    # For MFT analysis, we need either:
    # 1. Direct access to $MFT file in mounted NTFS
    # 2. Raw device access
    # 3. Extracted MFT file

    print_status "Running filesystem forensics analysis..."

    local findings_file="$SCAN_OUTPUT_DIR/filesystem_forensics.txt"
    local total_findings=0

    # Initialize findings file
    cat > "$findings_file" << 'EOF'
================================================================================
FILESYSTEM FORENSICS REPORT
================================================================================
Generated: $(date)

Analysis of MFT, USN Journal, and filesystem metadata for forensic artifacts.

EOF

    # 1. MFT Analysis
    analyze_mft "$fs_path" "$findings_file"

    # 2. USN Journal Analysis
    analyze_usn_journal "$fs_path" "$findings_file"

    # 3. Timestomping Detection
    detect_timestomping "$fs_path" "$findings_file"

    # 4. Deleted File Recovery Enumeration
    enumerate_deleted_files "$fs_path" "$findings_file"

    # Calculate total findings
    total_findings=$((${STATS[mft_deleted_recovered]} + ${STATS[mft_timestomping]} + \
                      ${STATS[usn_entries]:-0} + ${STATS[filesystem_anomalies]}))

    RESULTS["filesystem_forensics"]=$total_findings

    if [ $total_findings -gt 0 ]; then
        print_warning "Found $total_findings filesystem forensic findings - review recommended"

        GUIDANCE_RECOMMENDATIONS+=("Review filesystem forensics in $findings_file")

        if [ "$ATTACK_MAPPING" = true ]; then
            print_status "Filesystem forensic summary:"
            [ "${STATS[mft_timestomping]}" -gt 0 ] && echo "  - Timestomping detected: ${STATS[mft_timestomping]} files (${ATTACK_TECHNIQUES[timestomping]})"
            [ "${STATS[mft_deleted_recovered]}" -gt 0 ] && echo "  - Deleted records found: ${STATS[mft_deleted_recovered]}"
        fi
    else
        print_success "No significant filesystem forensic findings"
        GUIDANCE_NO_ACTION+=("Filesystem forensics: No suspicious findings")
    fi

    return 0
}

analyze_mft() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing Master File Table (MFT)..."

    echo "" >> "$findings_file"
    echo "=== MFT ANALYSIS ===" >> "$findings_file"
    echo "Master File Table contains metadata for all NTFS files" >> "$findings_file"
    echo "" >> "$findings_file"

    local mft_file=""
    local mft_analyzed=false

    # Try to find $MFT file
    if [ -f "$fs_path/\$MFT" ]; then
        mft_file="$fs_path/\$MFT"
    elif [ -f "$fs_path/MFT" ]; then
        mft_file="$fs_path/MFT"
    fi

    # Check for extracted/carved MFT
    if [ -z "$mft_file" ]; then
        while IFS= read -r -d '' file; do
            mft_file="$file"
            break
        done < <(find "$SCAN_OUTPUT_DIR" -iname "*mft*" -type f -print0 2>/dev/null)
    fi

    if [ -n "$mft_file" ] && [ -f "$mft_file" ]; then
        print_status "Found MFT file: $mft_file"

        # Use analyzeMFT if available
        if command -v analyzeMFT.py &> /dev/null || python3 -c "from analyzemft import mft" 2>/dev/null; then
            local mft_output="$SCAN_OUTPUT_DIR/mft_analysis.csv"

            python3 << 'MFT_ANALYSIS_PY' 2>/dev/null
import sys
import os
import csv
from datetime import datetime

try:
    from analyzemft import mft
except ImportError:
    sys.exit(1)

mft_file = "$mft_file"
output_file = "$mft_output"
findings_file = "$findings_file"

print(f"Analyzing MFT: {mft_file}")

deleted_count = 0
timestomp_count = 0

try:
    mft_session = mft.MftSession()
    mft_session.open(mft_file)

    with open(output_file, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['Record', 'Filename', 'Path', 'SI_Created', 'FN_Created', 'Deleted', 'Flags'])

        for record in mft_session:
            if record is None:
                continue

            is_deleted = record.flags.deleted if hasattr(record, 'flags') else False
            filename = getattr(record, 'filename', 'Unknown')
            path = getattr(record, 'path', 'Unknown')

            # Check for timestomping ($SI vs $FN time difference)
            si_created = getattr(record, 'si_crtime', None)
            fn_created = getattr(record, 'fn_crtime', None)

            timestomped = False
            if si_created and fn_created:
                try:
                    diff = abs((si_created - fn_created).total_seconds())
                    if diff > 1:  # More than 1 second difference is suspicious
                        timestomped = True
                        timestomp_count += 1
                except:
                    pass

            if is_deleted:
                deleted_count += 1

            writer.writerow([
                getattr(record, 'recordnum', 'N/A'),
                filename,
                path,
                str(si_created) if si_created else 'N/A',
                str(fn_created) if fn_created else 'N/A',
                str(is_deleted),
                'TIMESTOMPED' if timestomped else ''
            ])

    with open(findings_file, 'a') as f:
        f.write(f"MFT records analyzed successfully\n")
        f.write(f"  Deleted records found: {deleted_count}\n")
        f.write(f"  Potential timestomping: {timestomp_count}\n")
        f.write(f"  Full analysis: {output_file}\n\n")

    print(f"MFT_DELETED={deleted_count}")
    print(f"MFT_TIMESTOMP={timestomp_count}")

except Exception as e:
    with open(findings_file, 'a') as f:
        f.write(f"  MFT analysis error: {str(e)}\n\n")
MFT_ANALYSIS_PY
            mft_analyzed=true
        else
            echo "  analyzeMFT not available - basic analysis only" >> "$findings_file"
            echo "  Install with: pip3 install analyzemft" >> "$findings_file"

            # Basic MFT analysis using strings
            if command -v strings &> /dev/null; then
                local mft_strings=$(strings -n 6 "$mft_file" 2>/dev/null)

                # Look for suspicious filenames in MFT
                local suspicious_in_mft=$(echo "$mft_strings" | grep -iE "(mimikatz|psexec|procdump|lazagne|beacon|cobaltstrike)" | wc -l)

                if [ "$suspicious_in_mft" -gt 0 ]; then
                    echo "[HIGH] Suspicious filenames found in MFT:" >> "$findings_file"
                    echo "$mft_strings" | grep -iE "(mimikatz|psexec|procdump|lazagne|beacon|cobaltstrike)" | head -20 | sed 's/^/  /' >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            fi
        fi
    else
        echo "  $MFT file not accessible (normal for mounted NTFS on Linux)" >> "$findings_file"
        echo "  To analyze MFT, extract it using:" >> "$findings_file"
        echo "    - FTK Imager" >> "$findings_file"
        echo "    - icat (from sleuthkit): icat /dev/sdX 0 > mft.bin" >> "$findings_file"
        echo "" >> "$findings_file"
    fi

    return 0
}

analyze_usn_journal() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Analyzing USN Journal (change journal)..."

    echo "" >> "$findings_file"
    echo "=== USN JOURNAL ANALYSIS ===" >> "$findings_file"
    echo "NTFS change journal tracks file system changes" >> "$findings_file"
    echo "" >> "$findings_file"

    local usn_file=""
    local usn_count=0

    # Try to find $UsnJrnl:$J
    if [ -f "$fs_path/\$Extend/\$UsnJrnl:\$J" ]; then
        usn_file="$fs_path/\$Extend/\$UsnJrnl:\$J"
    elif [ -f "$fs_path/\$UsnJrnl" ]; then
        usn_file="$fs_path/\$UsnJrnl"
    fi

    # Check for extracted USN journal
    if [ -z "$usn_file" ]; then
        while IFS= read -r -d '' file; do
            usn_file="$file"
            break
        done < <(find "$SCAN_OUTPUT_DIR" -iname "*usnjrnl*" -o -iname "*usn*journal*" -type f -print0 2>/dev/null)
    fi

    if [ -n "$usn_file" ] && [ -f "$usn_file" ]; then
        print_status "Found USN Journal: $usn_file"

        # Parse USN journal with Python
        python3 << 'USN_ANALYSIS_PY' 2>/dev/null
import sys
import struct
import os
from datetime import datetime, timedelta

usn_file = "$usn_file"
findings_file = "$findings_file"

# USN record structure (simplified)
USN_RECORD_V2 = struct.Struct('<IIQQQQIIIHHH')

suspicious_operations = []
total_records = 0

def filetime_to_datetime(filetime):
    """Convert Windows FILETIME to datetime"""
    try:
        return datetime(1601, 1, 1) + timedelta(microseconds=filetime // 10)
    except:
        return None

def parse_usn_record(data, offset):
    """Parse a USN record at given offset"""
    try:
        if offset + USN_RECORD_V2.size > len(data):
            return None, 0

        record_len, major_version, minor_version, file_ref, parent_ref, usn, \
        timestamp, reason, source_info, security_id, file_attributes, \
        filename_len, filename_offset = USN_RECORD_V2.unpack_from(data, offset)

        if record_len == 0 or record_len > 4096:
            return None, 0

        # Get filename
        filename_start = offset + filename_offset
        filename_end = filename_start + filename_len
        if filename_end > len(data):
            return None, record_len

        filename = data[filename_start:filename_end].decode('utf-16-le', errors='ignore')

        return {
            'filename': filename,
            'timestamp': filetime_to_datetime(timestamp),
            'reason': reason,
            'file_ref': file_ref,
            'parent_ref': parent_ref,
        }, record_len

    except Exception as e:
        return None, 0

# Reason flags
REASON_DATA_OVERWRITE = 0x00000001
REASON_FILE_CREATE = 0x00000100
REASON_FILE_DELETE = 0x00000200
REASON_RENAME_OLD_NAME = 0x00001000
REASON_RENAME_NEW_NAME = 0x00002000
REASON_SECURITY_CHANGE = 0x00000800

suspicious_patterns = ['mimikatz', 'psexec', 'procdump', 'lazagne', 'beacon', 'cobaltstrike',
                       'powershell', 'cmd.exe', '.ps1', '.bat', '.vbs', '.hta']

try:
    with open(usn_file, 'rb') as f:
        data = f.read(50 * 1024 * 1024)  # Read up to 50MB

    offset = 0
    while offset < len(data) - 64:
        record, record_len = parse_usn_record(data, offset)

        if record is None:
            offset += 8  # Skip to next potential record
            continue

        total_records += 1
        offset += record_len

        filename = record.get('filename', '').lower()

        # Check for suspicious filenames
        for pattern in suspicious_patterns:
            if pattern in filename:
                suspicious_operations.append({
                    'filename': record.get('filename'),
                    'timestamp': record.get('timestamp'),
                    'reason': record.get('reason'),
                    'pattern': pattern
                })
                break

    # Write findings
    with open(findings_file, 'a') as f:
        f.write(f"USN Journal records parsed: {total_records}\n")
        f.write(f"Suspicious operations found: {len(suspicious_operations)}\n\n")

        if suspicious_operations:
            f.write("[MED] Suspicious file operations in USN Journal:\n")
            for op in suspicious_operations[:20]:
                f.write(f"  {op['timestamp']}: {op['filename']} (matched: {op['pattern']})\n")
            f.write("\n")

    print(f"USN_ENTRIES={len(suspicious_operations)}")

except Exception as e:
    with open(findings_file, 'a') as f:
        f.write(f"  USN Journal parsing error: {str(e)}\n\n")
USN_ANALYSIS_PY
    else
        echo "  USN Journal not accessible" >> "$findings_file"
        echo "  To extract USN Journal, use:" >> "$findings_file"
        echo "    - FTK Imager" >> "$findings_file"
        echo "    - ExtractUsnJrnl tool" >> "$findings_file"
        echo "" >> "$findings_file"
    fi

    STATS[usn_entries]=$usn_count

    return 0
}

detect_timestomping() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Detecting timestomping (time manipulation)..."

    echo "" >> "$findings_file"
    echo "=== TIMESTOMPING DETECTION ===" >> "$findings_file"
    echo "Looking for signs of timestamp manipulation" >> "$findings_file"
    echo "" >> "$findings_file"

    local timestomp_count=0

    # Method 1: Files with creation time after modification time (impossible normally)
    print_status "  Checking for impossible timestamp combinations..."

    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        # Get timestamps
        local ctime=$(stat -c '%W' "$file" 2>/dev/null)  # Birth time (if available)
        local mtime=$(stat -c '%Y' "$file" 2>/dev/null)  # Modification time
        local atime=$(stat -c '%X' "$file" 2>/dev/null)  # Access time

        # On Linux, birth time might not be available
        if [ "$ctime" != "0" ] && [ -n "$ctime" ] && [ -n "$mtime" ]; then
            if [ "$ctime" -gt "$mtime" ]; then
                ((timestomp_count++))
                echo "[HIGH] Impossible timestamp (creation > modification):" >> "$findings_file"
                echo "  File: $file" >> "$findings_file"
                echo "  Creation: $(date -d @$ctime 2>/dev/null || echo $ctime)" >> "$findings_file"
                echo "  Modified: $(date -d @$mtime 2>/dev/null || echo $mtime)" >> "$findings_file"
                echo "  ATT&CK: ${ATTACK_TECHNIQUES[timestomping]}" >> "$findings_file"
                echo "" >> "$findings_file"
            fi
        fi

    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" -o -name "*.ps1" -o -name "*.bat" \) -print0 2>/dev/null | head -c 500000)

    # Method 2: Files with suspiciously round timestamps (exactly on the hour/minute)
    print_status "  Checking for suspiciously precise timestamps..."

    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        local mtime=$(stat -c '%Y' "$file" 2>/dev/null)
        if [ -n "$mtime" ]; then
            # Check if timestamp is exactly on a minute boundary (seconds = 0)
            local seconds=$((mtime % 60))
            local minutes=$(( (mtime / 60) % 60 ))

            # Suspiciously round: seconds=0 AND minutes=0 (exactly on the hour)
            if [ "$seconds" -eq 0 ] && [ "$minutes" -eq 0 ]; then
                local filename=$(basename "$file")
                # Skip common system files that might legitimately have round timestamps
                if ! echo "$filename" | grep -qiE "^(desktop\.ini|thumbs\.db|ntuser\.dat)$"; then
                    ((timestomp_count++))
                    echo "[LOW] Suspiciously round timestamp (exactly on hour):" >> "$findings_file"
                    echo "  File: $file" >> "$findings_file"
                    echo "  Modified: $(date -d @$mtime 2>/dev/null || echo $mtime)" >> "$findings_file"
                    echo "" >> "$findings_file"
                fi
            fi
        fi

    done < <(find "$fs_path" -type f \( -name "*.exe" -o -name "*.dll" \) -print0 2>/dev/null | head -c 200000)

    # Method 3: Files in temp directories with very old timestamps
    print_status "  Checking for anachronistic files in temp directories..."

    local two_years_ago=$(date -d "2 years ago" +%s 2>/dev/null || echo $(($(date +%s) - 63072000)))

    while IFS= read -r -d '' file; do
        [ -f "$file" ] || continue

        local mtime=$(stat -c '%Y' "$file" 2>/dev/null)
        if [ -n "$mtime" ] && [ "$mtime" -lt "$two_years_ago" ]; then
            ((timestomp_count++))
            echo "[MED] Old file in temp directory (possible timestomping):" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "  Modified: $(date -d @$mtime 2>/dev/null || echo $mtime)" >> "$findings_file"
            echo "  ATT&CK: ${ATTACK_TECHNIQUES[timestomping]}" >> "$findings_file"
            echo "" >> "$findings_file"
        fi

    done < <(find "$fs_path" -type f \( -path "*Temp*" -o -path "*tmp*" \) \( -name "*.exe" -o -name "*.dll" -o -name "*.ps1" \) -print0 2>/dev/null)

    print_status "Timestomping detection complete: $timestomp_count potential cases"
    STATS[mft_timestomping]=$timestomp_count

    return 0
}

enumerate_deleted_files() {
    local fs_path="$1"
    local findings_file="$2"

    print_status "Enumerating potentially recoverable deleted files..."

    echo "" >> "$findings_file"
    echo "=== DELETED FILE ENUMERATION ===" >> "$findings_file"
    echo "Files that may be recoverable from slack space or MFT" >> "$findings_file"
    echo "" >> "$findings_file"

    local deleted_count=0

    # Check Recycle Bin contents
    print_status "  Checking Recycle Bin..."

    local recycle_dirs=(
        "$fs_path/\$Recycle.Bin"
        "$fs_path/RECYCLER"
        "$fs_path/Recycled"
    )

    for recycle_dir in "${recycle_dirs[@]}"; do
        if [ -d "$recycle_dir" ]; then
            local bin_count=$(find "$recycle_dir" -type f 2>/dev/null | wc -l)
            if [ "$bin_count" -gt 0 ]; then
                echo "Recycle Bin contents ($recycle_dir): $bin_count files" >> "$findings_file"

                # List suspicious deleted files
                while IFS= read -r -d '' file; do
                    local filename=$(basename "$file")
                    local ext="${filename##*.}"

                    if echo "$ext" | grep -qiE "^(exe|dll|ps1|bat|vbs|js)$"; then
                        ((deleted_count++))
                        echo "  [INFO] Deleted executable: $file" >> "$findings_file"

                        # Try to get original filename from $I file
                        local info_file="${file/$filename/\$I${filename#\$R}}"
                        if [ -f "$info_file" ]; then
                            # Parse $I file for original path (simplified)
                            local orig_path=$(strings "$info_file" 2>/dev/null | grep -E "^[A-Z]:" | head -1)
                            [ -n "$orig_path" ] && echo "    Original path: $orig_path" >> "$findings_file"
                        fi
                    fi

                done < <(find "$recycle_dir" -type f -name '$R*' -print0 2>/dev/null)

                echo "" >> "$findings_file"
            fi
        fi
    done

    # Check for orphaned files (files with no parent directory entry)
    # This is limited without raw disk access
    print_status "  Checking for file system anomalies..."

    # Look for files with unusual permissions or ownership
    while IFS= read -r -d '' file; do
        local filename=$(basename "$file")

        # Files named with $ prefix (system files)
        if [[ "$filename" == \$* ]] && [[ ! "$filename" =~ ^\$(Recycle|MFT|Extend) ]]; then
            ((deleted_count++))
            echo "[INFO] System/hidden file outside expected location:" >> "$findings_file"
            echo "  File: $file" >> "$findings_file"
            echo "" >> "$findings_file"
        fi

    done < <(find "$fs_path" -maxdepth 5 -type f -name '$*' -print0 2>/dev/null)

    # Summary
    if [ "$deleted_count" -gt 0 ]; then
        echo "Total deleted/suspicious files found: $deleted_count" >> "$findings_file"
        echo "" >> "$findings_file"
        echo "For deeper deleted file recovery, use:" >> "$findings_file"
        echo "  - Autopsy / Sleuth Kit (file carving)" >> "$findings_file"
        echo "  - foremost / scalpel (signature-based carving)" >> "$findings_file"
        echo "  - R-Studio / PhotoRec (data recovery)" >> "$findings_file"
    else
        echo "No deleted executables found in accessible locations" >> "$findings_file"
        echo "Note: Deep deleted file recovery requires raw disk access" >> "$findings_file"
    fi

    print_status "Deleted file enumeration complete: $deleted_count items"
    STATS[mft_deleted_recovered]=$deleted_count

    return 0
}

# ==========================================
# DEEP SCAN FUNCTIONS
# ==========================================

scan_entropy() {
    print_section "Entropy Analysis"

    print_status "Analyzing disk entropy by region (detecting encryption/packing)..."

    local high_entropy_regions=0
    local device_path="$DEVICE"

    python3 << ENTROPY_EOF
import subprocess
import math
import sys
import os

chunk_size_mb = 50
num_chunks = 20
device = os.environ.get('SCAN_DEVICE', '$device_path')

print(f"Scanning {num_chunks} regions of {chunk_size_mb}MB each...")
print("-" * 70)

suspicious = 0
for i in range(num_chunks):
    offset = i * chunk_size_mb
    try:
        proc = subprocess.Popen(
            ['dd', 'if=' + device, 'bs=1M', f'count={chunk_size_mb}', f'skip={offset}'],
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        )
        data, _ = proc.communicate(timeout=60)
    except Exception as e:
        print(f"Error reading region {offset}MB: {e}")
        continue

    if len(data) == 0:
        continue

    freq = [0]*256
    for b in data:
        freq[b] += 1

    entropy = 0
    for f in freq:
        if f > 0:
            p = f / len(data)
            entropy -= p * math.log2(p)

    zero_pct = (freq[0] / len(data)) * 100

    status = ""
    if entropy > 7.5:
        status = "HIGH ENTROPY"
        suspicious += 1
    elif entropy < 0.5:
        status = "Empty"
    elif entropy > 6.0:
        status = "Data present"
    else:
        status = "Low entropy"

    if entropy > 7.5 or (entropy > 5.0 and entropy < 7.5):
        print(f"Region {offset:5d}MB: Entropy={entropy:.2f}/8.0, Zeros={zero_pct:5.1f}% - {status}")

print("-" * 70)
if suspicious > 0:
    print(f"Found {suspicious} high-entropy regions (possible encryption/compression)")
    sys.exit(1)
else:
    print("No suspicious high-entropy regions detected")
    sys.exit(0)
ENTROPY_EOF

    if [ $? -eq 1 ]; then
        RESULTS["entropy"]=1
    else
        RESULTS["entropy"]=0
    fi

    return 0
}

scan_file_carving() {
    print_section "File Carving (Deleted File Recovery)"

    local carve_dir="$SCAN_OUTPUT_DIR/carved"

    # Check disk space before carving
    local estimated_space=$((DEVICE_SIZE_MB / 10))  # Rough estimate
    if ! check_disk_space $estimated_space "/tmp"; then
        print_warning "Skipping file carving due to insufficient disk space"
        RESULTS["carved_files"]=0
        RESULTS["carved_malware"]=0
        return 0
    fi

    mkdir -p "$carve_dir"

    print_status "Running foremost to recover deleted files..."

    foremost -t all -i "$DEVICE" -o "$carve_dir" 2>&1 | tail -10 || true

    # Check results
    local carved_count=$(find "$carve_dir" -type f ! -name "audit.txt" 2>/dev/null | wc -l)

    if [ "$carved_count" -gt 0 ]; then
        print_warning "Recovered $carved_count deleted files"

        # Show file types found
        echo ""
        print_status "Recovered file types:"
        find "$carve_dir" -type f ! -name "audit.txt" -exec file {} \; 2>/dev/null | \
            cut -d: -f2 | sort | uniq -c | sort -rn | head -10

        # Scan recovered files with ClamAV
        echo ""
        print_status "Scanning recovered files with ClamAV..."
        clam_result=$(clamscan --database="$CLAMDB_DIR" -r "$carve_dir" 2>&1) || true
        infected=$(echo "$clam_result" | grep "Infected files:" | awk '{print $3}')

        if [ "$infected" != "0" ] && [ -n "$infected" ]; then
            print_error "MALWARE FOUND in recovered files!"
            echo "$clam_result" | grep -E "FOUND|Infected"
            RESULTS["carved_malware"]=$infected
        else
            print_success "Recovered files: CLEAN"
            RESULTS["carved_malware"]=0
        fi

        RESULTS["carved_files"]=$carved_count
    else
        print_success "No deleted files recovered"
        RESULTS["carved_files"]=0
        RESULTS["carved_malware"]=0
    fi

    return 0
}

scan_bulk_extractor() {
    print_section "Bulk Extractor Analysis"

    if ! command -v bulk_extractor &> /dev/null; then
        print_warning "bulk_extractor not available, skipping..."
        return 0
    fi

    local bulk_dir="$SCAN_OUTPUT_DIR/bulk_output"
    mkdir -p "$bulk_dir"

    print_status "Running bulk_extractor (this may take a while)..."

    # Run with timeout
    timeout 600 bulk_extractor -o "$bulk_dir" "$DEVICE" 2>&1 | tail -20 || true

    # Analyze results
    if [ -d "$bulk_dir" ]; then
        echo ""
        print_status "Bulk extractor findings:"

        # Check for email addresses
        if [ -f "$bulk_dir/email.txt" ] && [ -s "$bulk_dir/email.txt" ]; then
            local email_count=$(wc -l < "$bulk_dir/email.txt")
            print_warning "Found $email_count email addresses"
        fi

        # Check for URLs
        if [ -f "$bulk_dir/url.txt" ] && [ -s "$bulk_dir/url.txt" ]; then
            local url_count=$(wc -l < "$bulk_dir/url.txt")
            print_warning "Found $url_count URLs"
            echo "Sample URLs:"
            head -5 "$bulk_dir/url.txt" | sed 's/^/  /'
        fi

        # Check for credit card numbers
        if [ -f "$bulk_dir/ccn.txt" ] && [ -s "$bulk_dir/ccn.txt" ]; then
            local ccn_count=$(wc -l < "$bulk_dir/ccn.txt")
            print_error "Found $ccn_count potential credit card numbers!"
        fi

        # Check for Windows artifacts
        if [ -f "$bulk_dir/winpe.txt" ] && [ -s "$bulk_dir/winpe.txt" ]; then
            local pe_count=$(wc -l < "$bulk_dir/winpe.txt")
            print_warning "Found $pe_count Windows PE artifacts"
        fi

        # Check for JSON/config data
        if [ -f "$bulk_dir/json.txt" ] && [ -s "$bulk_dir/json.txt" ]; then
            local json_count=$(wc -l < "$bulk_dir/json.txt")
            print_warning "Found $json_count JSON fragments"
        fi

        RESULTS["bulk_extractor"]=1
    else
        print_success "No significant artifacts found"
        RESULTS["bulk_extractor"]=0
    fi

    return 0
}

scan_executables() {
    print_section "Executable Detection"

    print_status "Scanning for PE (Windows) and ELF (Linux) executables..."

    local pe_found=0
    local elf_found=0

    # Scan for PE headers (MZ)
    pe_offsets=$(dd if="$DEVICE" bs=1M 2>/dev/null | grep -boa "MZ" 2>/dev/null | head -20) || true
    if [ -n "$pe_offsets" ]; then
        pe_found=$(echo "$pe_offsets" | wc -l)
        print_warning "Found $pe_found potential PE (Windows) executables"
    fi

    # Scan for ELF headers
    elf_offsets=$(dd if="$DEVICE" bs=1M 2>/dev/null | grep -boa $'\x7fELF' 2>/dev/null | head -20) || true
    if [ -n "$elf_offsets" ]; then
        elf_found=$(echo "$elf_offsets" | wc -l)
        print_warning "Found $elf_found potential ELF (Linux) executables"
    fi

    if [ $pe_found -eq 0 ] && [ $elf_found -eq 0 ]; then
        print_success "No executables detected in raw disk"
    fi

    RESULTS["pe_executables"]=$pe_found
    RESULTS["elf_executables"]=$elf_found
    return 0
}

scan_hashes() {
    print_section "Hash Analysis"

    if ! command -v md5deep &> /dev/null; then
        print_warning "md5deep not available, skipping..."
        return 0
    fi

    if [ -n "$MOUNT_POINT" ] && [ -d "$MOUNT_POINT" ]; then
        print_status "Generating file hashes for mounted filesystem..."

        local hash_file="$SCAN_OUTPUT_DIR/file_hashes.txt"
        md5deep -r "$MOUNT_POINT" > "$hash_file" 2>/dev/null || true

        local hash_count=$(wc -l < "$hash_file" 2>/dev/null || echo 0)
        print_success "Generated $hash_count file hashes"
        print_status "Hashes saved to: $hash_file"

        RESULTS["hashes"]=$hash_count
    else
        print_warning "No mounted filesystem, skipping hash generation"
        RESULTS["hashes"]=0
    fi

    return 0
}

scan_boot_sector() {
    print_section "Boot Sector Analysis"

    print_status "Analyzing MBR/boot sector..."

    local boot_file="$SCAN_OUTPUT_DIR/boot_sector.bin"
    dd if="$DEVICE" of="$boot_file" bs=512 count=1 2>/dev/null

    # Check for known boot sector malware signatures
    local boot_hex=$(xxd -p "$boot_file" | tr -d '\n')

    # Check MBR signature
    local mbr_sig="${boot_hex: -4}"
    if [ "$mbr_sig" = "55aa" ]; then
        print_success "Valid MBR signature (55AA)"
    else
        print_warning "Non-standard MBR signature: $mbr_sig"
    fi

    # Check for suspicious patterns
    if echo "$boot_hex" | grep -qi "4d5a"; then
        print_warning "PE header found in boot sector - possible bootkit!"
        RESULTS["boot_sector"]=1
    else
        print_success "Boot sector appears normal"
        RESULTS["boot_sector"]=0
    fi

    # Show boot sector info
    file "$boot_file" 2>/dev/null
    return 0
}

# ==========================================
# REPORT GENERATION
# ==========================================

generate_report() {
    print_section "Scan Report"

    local report_file="${OUTPUT_FILE:-$SCAN_OUTPUT_DIR/scan_report_$(date +%Y%m%d_%H%M%S).txt}"

    {
        echo "═══════════════════════════════════════════════════════════════"
        echo "              TSURUGI LINUX MALWARE SCAN REPORT"
        echo "              Generated: $(date)"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "DEVICE INFORMATION"
        echo "──────────────────"
        echo "Device:     $DEVICE"
        echo "Size:       ${DEVICE_SIZE_GB} GB"
        echo "Filesystem: $FS_TYPE"
        echo "Scan Type:  $([ "$DEEP_SCAN" = true ] && echo "DEEP SCAN" || echo "STANDARD")"
        echo "Parallel:   $([ "$PARALLEL_MODE" = true ] && echo "YES" || echo "NO")"
        echo ""
        echo "SCAN RESULTS"
        echo "────────────"
        echo ""
        echo "Basic Scans:"
        echo "  ClamAV:              ${RESULTS[clamav]:-N/A} infected"
        echo "  YARA Windows:        ${RESULTS[yara_Windows]:-N/A} matches"
        echo "  YARA Linux:          ${RESULTS[yara_Linux]:-N/A} matches"
        echo "  YARA Android:        ${RESULTS[yara_Android]:-N/A} matches"
        echo "  YARA Documents:      ${RESULTS[yara_Documents]:-N/A} matches"
        echo "  Binwalk:             ${RESULTS[binwalk]:-N/A} findings"
        echo "  String Analysis:     ${RESULTS[strings]:-N/A} patterns"

        if [ "$QUICK_SCAN" = true ]; then
            echo ""
            echo "Quick Scan:"
            echo "  Suspicious regions:  ${RESULTS[quick_scan]:-0}"
        fi

        if [ "$DO_VIRUSTOTAL" = true ]; then
            echo ""
            echo "VirusTotal:"
            echo "  Malicious files:     ${RESULTS[virustotal]:-N/A}"
        fi

        if [ "$DEEP_SCAN" = true ]; then
            echo ""
            echo "Deep Scan Results:"
            echo "  Entropy Analysis:    $([ "${RESULTS[entropy]}" = "1" ] && echo "SUSPICIOUS" || echo "Normal")"
            echo "  Carved Files:        ${RESULTS[carved_files]:-0} recovered"
            echo "  Carved Malware:      ${RESULTS[carved_malware]:-0} infected"
            echo "  PE Executables:      ${RESULTS[pe_executables]:-0} found"
            echo "  ELF Executables:     ${RESULTS[elf_executables]:-0} found"
            echo "  Boot Sector:         $([ "${RESULTS[boot_sector]}" = "1" ] && echo "SUSPICIOUS" || echo "Normal")"
            echo "  Bulk Extractor:      $([ "${RESULTS[bulk_extractor]}" = "1" ] && echo "Artifacts found" || echo "Clean")"
        fi

        if [ "$DO_ROOTKIT" = true ]; then
            echo ""
            echo "Rootkit Detection:"
            echo "  Findings:            ${RESULTS[rootkit]:-0}"
        fi

        if [ "$DO_TIMELINE" = true ]; then
            echo ""
            echo "Timeline:"
            echo "  Generated:           $([ "${RESULTS[timeline]}" = "1" ] && echo "YES" || echo "NO")"
        fi

        echo ""
        echo "SCAN STATUS"
        echo "───────────"
        for scan in "${!SCAN_STATUS[@]}"; do
            echo "  $scan: ${SCAN_STATUS[$scan]}"
        done

        echo ""
        echo "═══════════════════════════════════════════════════════════════"

        # Calculate overall status
        local total_findings=0
        for key in "${!RESULTS[@]}"; do
            local val="${RESULTS[$key]}"
            if [[ "$val" =~ ^[0-9]+$ ]]; then
                total_findings=$((total_findings + val))
            fi
        done

        echo ""
        echo "OVERALL STATUS"
        echo "──────────────"
        if [ $total_findings -eq 0 ]; then
            echo "  STATUS: CLEAN"
            echo "  No malware or suspicious activity detected."
        else
            echo "  STATUS: SUSPICIOUS"
            echo "  Total findings: $total_findings"
            echo "  Manual review recommended."
        fi

        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "Scan output directory: $SCAN_OUTPUT_DIR"

    } | tee "$report_file"

    echo ""
    print_success "Report saved to: $report_file"

    # Also generate statistics report if slack mode or deep scan
    if [ "$SCAN_MODE" = "slack" ] || [ "$DEEP_SCAN" = true ]; then
        generate_statistics_report
    fi
}

generate_guidance() {
    # Generate actionable recommendations based on findings

    # Reset arrays
    GUIDANCE_RECOMMENDATIONS=()
    GUIDANCE_NO_ACTION=()

    # YARA matches - always noteworthy
    if [ "${STATS[yara_matches]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("YARA|High|${STATS[yara_matches]} rule(s) matched specific threat patterns|Extract and analyze data at matched offsets|yara_matches/")
    fi

    # ClamAV detections - critical
    if [ "${STATS[clamav_infected]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("CLAMAV|Critical|${STATS[clamav_infected]} known malware signature(s) detected|Isolate and analyze infected files immediately|clamav_results/")
    else
        GUIDANCE_NO_ACTION+=("ClamAV: No signature matches")
    fi

    # Recovered executables from slack
    if [ "${STATS[carved_executables]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("EXEC|Medium|${STATS[carved_executables]} executable(s) found in unallocated space|Submit to sandbox analysis or VirusTotal|reconstructed/")
    fi

    # High entropy regions
    if [ "${STATS[entropy_high_count]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("ENTROPY|Low-Medium|${STATS[entropy_high_count]} high-entropy region(s) detected|Extract regions and analyze file signatures|entropy_analysis/")
    fi

    # URLs found
    if [ "${STATS[bulk_urls]:-0}" -gt 0 ] || [ "${STATS[strings_urls]:-0}" -gt 0 ]; then
        local url_count=$((${STATS[bulk_urls]:-0} + ${STATS[strings_urls]:-0}))
        GUIDANCE_RECOMMENDATIONS+=("URLS|Low|${url_count} URL(s) found in slack space|Review for known malicious domains|slack_artifacts/urls.txt")
    fi

    # Credit card numbers - sensitive data
    if [ "${STATS[bulk_ccn]:-0}" -gt 0 ]; then
        GUIDANCE_RECOMMENDATIONS+=("PII|Medium|${STATS[bulk_ccn]} potential credit card number(s) found|Review for data breach implications|slack_artifacts/ccn.txt")
    fi

    # Boot sector issues
    if [ "${RESULTS[boot_sector]:-0}" = "1" ]; then
        GUIDANCE_RECOMMENDATIONS+=("BOOTSEC|High|Suspicious patterns in boot sector|Analyze for bootkit/rootkit infection|boot_sector.bin")
    else
        if [ "$SCAN_MODE" = "full" ]; then
            GUIDANCE_NO_ACTION+=("Boot sector: Normal")
        else
            GUIDANCE_NO_ACTION+=("Boot sector: Not analyzed (slack mode)")
        fi
    fi

    # Recovered files
    if [ "${STATS[carved_total]:-0}" -gt 0 ]; then
        local non_exec=$((${STATS[carved_total]:-0} - ${STATS[carved_executables]:-0}))
        if [ $non_exec -gt 0 ]; then
            GUIDANCE_NO_ACTION+=("Recovered files: $non_exec non-executable files (images, docs, etc.)")
        fi
    fi
}

generate_statistics_report() {
    print_section "Statistics Report"

    local stats_file="$SCAN_OUTPUT_DIR/statistics_report_$(date +%Y%m%d_%H%M%S).txt"

    # Calculate scan duration
    local scan_end_time=$(date +%s)
    local scan_duration=$((scan_end_time - ${SCAN_START_TIME:-$scan_end_time}))
    local duration_min=$((scan_duration / 60))
    local duration_sec=$((scan_duration % 60))

    # Generate guidance first
    generate_guidance

    {
        echo "╔══════════════════════════════════════════════════════════════╗"
        echo "║                    SCAN STATISTICS                           ║"
        echo "╠══════════════════════════════════════════════════════════════╣"
        echo ""
        echo "DEVICE INFORMATION"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-14s %s\n" "Input:" "${ORIGINAL_INPUT:-$DEVICE}"

        local input_type_display="Block Device"
        case "$INPUT_TYPE" in
            ewf) input_type_display="EWF Forensic Image" ;;
            raw_image) input_type_display="Raw Disk Image" ;;
        esac
        printf "  %-14s %s\n" "Type:" "$input_type_display"
        printf "  %-14s %s GB\n" "Size:" "${DEVICE_SIZE_GB:-N/A}"
        printf "  %-14s %s\n" "Scan Mode:" "$([ "$SCAN_MODE" = "slack" ] && echo "Slack Space Only" || echo "Full Drive")"

        if [ "$SCAN_MODE" = "slack" ]; then
            local slack_pct=0
            if [ "${DEVICE_SIZE_MB:-0}" -gt 0 ]; then
                slack_pct=$(echo "scale=1; ${STATS[slack_size_mb]:-0} * 100 / ${DEVICE_SIZE_MB}" | bc 2>/dev/null || echo "0")
            fi
            printf "  %-14s %s MB (%s%% of total)\n" "Slack Size:" "${STATS[slack_size_mb]:-0}" "$slack_pct"
        fi
        printf "  %-14s %d minutes %d seconds\n" "Duration:" "$duration_min" "$duration_sec"
        echo ""

        echo "ANTIVIRUS SCAN (ClamAV)"
        echo "──────────────────────────────────────────────────────────────"
        if [ "$SCAN_MODE" = "slack" ]; then
            printf "  %-14s %s MB\n" "Data Scanned:" "${STATS[slack_data_recovered_mb]:-0}"
        else
            printf "  %-14s %s GB\n" "Data Scanned:" "${DEVICE_SIZE_GB:-N/A}"
        fi
        printf "  %-14s %s\n" "Signatures:" "${STATS[clamav_signatures]:-Standard ClamAV DB}"
        printf "  %-14s %s\n" "Detections:" "${STATS[clamav_infected]:-0}"
        echo ""

        echo "YARA RULE MATCHING"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-14s %s\n" "Rules Checked:" "${STATS[yara_rules_checked]:-N/A}"
        printf "  %-14s %s\n" "Matches:" "${STATS[yara_matches]:-0}"

        if [ "${STATS[yara_matches]:-0}" -gt 0 ] && [ -n "${STATS[yara_match_details]}" ]; then
            echo ""
            echo "  Match Details:"
            echo "${STATS[yara_match_details]}" | while IFS='|' read -r rule offset match; do
                printf "    * Rule: %s\n" "$rule"
                printf "      Offset: %s, Match: %s\n" "$offset" "$match"
            done
        fi
        echo ""

        echo "STRING ANALYSIS"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-14s %s\n" "Total Strings:" "${STATS[strings_total]:-N/A}"
        printf "  %-14s %s\n" "URLs Found:" "${STATS[strings_urls]:-${STATS[bulk_urls]:-0}}"
        printf "  %-14s %s\n" "Exec Refs:" "${STATS[strings_executables]:-0}"
        printf "  %-14s %s\n" "Cred Refs:" "${STATS[strings_credentials]:-0}"

        if [ -n "${STATS[strings_samples]}" ]; then
            echo ""
            echo "  Sample URLs (first 5):"
            echo "${STATS[strings_samples]}" | tr '|' '\n' | head -5 | while read -r url; do
                printf "    * %s\n" "$url"
            done
        fi
        echo ""

        echo "ENTROPY ANALYSIS"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-18s %s\n" "Regions Analyzed:" "${STATS[entropy_regions_scanned]:-N/A}"
        printf "  %-18s %s / 8.0\n" "Average Entropy:" "${STATS[entropy_avg]:-N/A}"
        printf "  %-18s %s / 8.0\n" "Max Entropy:" "${STATS[entropy_max]:-N/A}"
        printf "  %-18s %s regions\n" "High Entropy (>7.5):" "${STATS[entropy_high_count]:-0}"

        if [ "${STATS[entropy_high_count]:-0}" -gt 0 ] && [ -n "${STATS[entropy_high_offsets]}" ]; then
            echo ""
            echo "  High Entropy Locations:"
            echo "${STATS[entropy_high_offsets]}" | tr ',' '\n' | while read -r offset; do
                printf "    * %s\n" "$offset"
                echo "      -> May indicate: encrypted data, compressed archive"
            done
        fi
        echo ""

        if [ "$SCAN_MODE" = "slack" ] || [ "$DEEP_SCAN" = true ]; then
            echo "FILE RECOVERY (Slack Space)"
            echo "──────────────────────────────────────────────────────────────"
            printf "  %-18s %s\n" "Files Recovered:" "${STATS[slack_files_recovered]:-${STATS[carved_total]:-0}}"
            printf "  %-18s %s MB\n" "Data Recovered:" "${STATS[slack_data_recovered_mb]:-0}"

            if [ -n "${STATS[carved_by_type]}" ]; then
                echo ""
                echo "  By Type:"
                echo "${STATS[carved_by_type]}" | tr ',' '\n' | while IFS=':' read -r ext count; do
                    printf "    * %-12s %s files\n" "$ext" "$count"
                done
            fi
            echo ""
        fi

        echo "EXECUTABLE HEADERS FOUND"
        echo "──────────────────────────────────────────────────────────────"
        printf "  %-18s %s\n" "PE Headers (Win):" "${STATS[pe_headers]:-${RESULTS[pe_executables]:-0}}"
        printf "  %-18s %s\n" "ELF Headers (Linux):" "${STATS[elf_headers]:-${RESULTS[elf_executables]:-0}}"

        if [ -n "${STATS[pe_offsets]}" ]; then
            echo ""
            echo "  PE Locations (first 5):"
            printf "    %s\n" "${STATS[pe_offsets]}"
        fi
        echo ""

        echo "╠══════════════════════════════════════════════════════════════╣"
        echo "║                    ANALYSIS GUIDANCE                          ║"
        echo "╠══════════════════════════════════════════════════════════════╣"
        echo ""

        if [ ${#GUIDANCE_RECOMMENDATIONS[@]} -gt 0 ]; then
            echo "RECOMMENDED INSPECTIONS:"
            echo "──────────────────────────────────────────────────────────────"
            echo ""

            local rec_num=1
            for rec in "${GUIDANCE_RECOMMENDATIONS[@]}"; do
                IFS='|' read -r category priority reason action location <<< "$rec"
                echo "$rec_num. $category ($priority priority)"
                echo "   Reason: $reason"
                echo "   Action: $action"
                echo "   Files:  \$OUTPUT_DIR/$location"
                echo ""
                rec_num=$((rec_num + 1))
            done
        else
            echo "RECOMMENDED INSPECTIONS:"
            echo "──────────────────────────────────────────────────────────────"
            echo "  No high-priority items requiring immediate attention."
            echo ""
        fi

        if [ ${#GUIDANCE_NO_ACTION[@]} -gt 0 ]; then
            echo "NO ACTION REQUIRED:"
            echo "──────────────────────────────────────────────────────────────"
            for item in "${GUIDANCE_NO_ACTION[@]}"; do
                echo "  * $item"
            done
            echo ""
        fi

        echo "╚══════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Output directory: $SCAN_OUTPUT_DIR"

    } | tee "$stats_file"

    echo ""
    print_success "Statistics report saved to: $stats_file"
}

generate_html_report() {
    local html_file="$SCAN_OUTPUT_DIR/scan_report_$(date +%Y%m%d_%H%M%S).html"

    print_status "Generating HTML report..."

    # Calculate total findings
    local total_findings=0
    for key in "${!RESULTS[@]}"; do
        local val="${RESULTS[$key]}"
        if [[ "$val" =~ ^[0-9]+$ ]]; then
            total_findings=$((total_findings + val))
        fi
    done

    # Build findings summary
    local findings_summary=""
    local clamav_count="${RESULTS[clamav]:-0}"
    local yara_count=$((${RESULTS[yara_Windows]:-0} + ${RESULTS[yara_Linux]:-0}))
    [ "$clamav_count" != "0" ] && [ "$clamav_count" != "N/A" ] && findings_summary+="$clamav_count AV detection(s), "
    [ "$yara_count" -gt 0 ] && findings_summary+="$yara_count YARA match(es), "
    [ "${STATS[carved_executables]:-0}" -gt 0 ] && findings_summary+="${STATS[carved_executables]} recovered exe(s), "
    findings_summary="${findings_summary%, }"
    [ -z "$findings_summary" ] && findings_summary="No notable findings"

    cat > "$html_file" << HTMLEOF
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DMS Scan Statistics - $(date +%Y-%m-%d)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 0; padding: 20px; background: #f5f5f5; }
        .container { max-width: 900px; margin: 0 auto; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 30px; }
        h1 { color: #333; border-bottom: 3px solid #007bff; padding-bottom: 10px; }
        h2 { color: #555; margin-top: 30px; }
        .summary-banner { padding: 20px; border-radius: 8px; text-align: center; margin: 20px 0; background: #e7f3ff; border: 1px solid #b8daff; }
        table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background: #f8f9fa; font-weight: 600; }
        .info-box { background: #f8f9fa; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #007bff; }
        .guidance-box { background: #fff3cd; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #ffc107; }
        .timestamp { color: #666; font-size: 0.9em; }
        .stat-value { font-weight: bold; color: #333; }
        .forensic-box { background: #f0f8ff; padding: 15px; border-radius: 5px; margin: 15px 0; border-left: 4px solid #6c5ce7; }
        .forensic-finding { background: #fff5f5; padding: 10px; border-radius: 4px; margin: 8px 0; border-left: 3px solid #e74c3c; }
        .attack-badge { display: inline-block; background: #d63031; color: white; padding: 2px 8px; border-radius: 3px; font-size: 0.85em; margin: 2px; }
        .finding-category { font-weight: bold; color: #6c5ce7; margin-bottom: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>DMS - Drive Malware Scan Statistics</h1>
        <p class="timestamp">Generated: $(date)</p>

        <div class="summary-banner">
            <h2 style="margin:0;">Scan Statistics Summary</h2>
            <p style="margin:10px 0 0 0;"><strong>Findings:</strong> $findings_summary</p>
            <p><strong>Items to review:</strong> $total_findings</p>
        </div>

        <h2>Device Information</h2>
        <div class="info-box">
            <strong>Device:</strong> $DEVICE<br>
            <strong>Size:</strong> ${DEVICE_SIZE_GB} GB<br>
            <strong>Filesystem:</strong> $FS_TYPE<br>
            <strong>Scan Mode:</strong> $([ "$SCAN_MODE" = "slack" ] && echo "Slack Space Only" || echo "Full Drive")<br>
            <strong>Scan Type:</strong> $([ "$DEEP_SCAN" = true ] && echo "Deep Scan" || echo "Standard")
        </div>

        <h2>Scan Statistics</h2>
        <table>
            <tr><th>Scanner</th><th>Count</th><th>Description</th></tr>
            <tr><td>ClamAV</td><td class="stat-value">${RESULTS[clamav]:-0}</td><td>Signature detections</td></tr>
            <tr><td>YARA Windows</td><td class="stat-value">${RESULTS[yara_Windows]:-0}</td><td>Rule matches</td></tr>
            <tr><td>YARA Linux</td><td class="stat-value">${RESULTS[yara_Linux]:-0}</td><td>Rule matches</td></tr>
            <tr><td>YARA Android</td><td class="stat-value">${RESULTS[yara_Android]:-0}</td><td>Rule matches</td></tr>
            <tr><td>Binwalk</td><td class="stat-value">${RESULTS[binwalk]:-0}</td><td>Embedded files found</td></tr>
            <tr><td>String Patterns</td><td class="stat-value">${RESULTS[strings]:-0}</td><td>Notable strings</td></tr>
HTMLEOF

    if [ "$SCAN_MODE" = "slack" ]; then
        cat >> "$html_file" << HTMLEOF
            <tr><td>Slack Space</td><td class="stat-value">${STATS[slack_size_mb]:-0} MB</td><td>Unallocated data extracted</td></tr>
            <tr><td>Files Recovered</td><td class="stat-value">${STATS[slack_files_recovered]:-0}</td><td>Carved from slack space</td></tr>
            <tr><td>Executables Recovered</td><td class="stat-value">${STATS[carved_executables]:-0}</td><td>EXE/DLL files</td></tr>
HTMLEOF
    fi

    if [ "$DEEP_SCAN" = true ] || [ "$SCAN_MODE" = "slack" ]; then
        cat >> "$html_file" << HTMLEOF
            <tr><td>High Entropy Regions</td><td class="stat-value">${STATS[entropy_high_count]:-0}</td><td>Possible encrypted/packed data</td></tr>
            <tr><td>Carved Files</td><td class="stat-value">${RESULTS[carved_files]:-0}</td><td>Files recovered</td></tr>
HTMLEOF
    fi

    if [ "$SCAN_MODE" = "full" ] && [ "$DEEP_SCAN" = true ]; then
        cat >> "$html_file" << HTMLEOF
            <tr><td>Boot Sector</td><td class="stat-value">$([ "${RESULTS[boot_sector]:-0}" = "0" ] && echo "Normal" || echo "Review needed")</td><td>MBR analysis</td></tr>
HTMLEOF
    fi

    cat >> "$html_file" << HTMLEOF
        </table>
HTMLEOF

    # Add forensic findings section if forensic analysis was enabled
    if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_PERSISTENCE_SCAN" = true ] || \
       [ "$DO_EXECUTION_SCAN" = true ] || [ "$DO_FILE_ANOMALIES" = true ] || \
       [ "$DO_RE_TRIAGE" = true ] || [ "$DO_MFT_ANALYSIS" = true ]; then

        cat >> "$html_file" << HTMLEOF
        <h2>Behavioral & Forensic Analysis</h2>
        <div class="forensic-box">
            <p><strong>Forensic modules executed:</strong>
            $([ "$DO_PERSISTENCE_SCAN" = true ] || [ "$FORENSIC_ANALYSIS" = true ] && echo "Persistence, ")
            $([ "$DO_EXECUTION_SCAN" = true ] || [ "$FORENSIC_ANALYSIS" = true ] && echo "Execution, ")
            $([ "$DO_FILE_ANOMALIES" = true ] || [ "$FORENSIC_ANALYSIS" = true ] && echo "File Anomalies, ")
            $([ "$DO_RE_TRIAGE" = true ] || [ "$FORENSIC_ANALYSIS" = true ] && echo "RE Triage, ")
            $([ "$DO_MFT_ANALYSIS" = true ] || [ "$FORENSIC_ANALYSIS" = true ] && echo "MFT/Filesystem")
            </p>
        </div>

        <table>
            <tr><th>Category</th><th>Count</th><th>Description</th></tr>
HTMLEOF

        # Persistence findings
        if [ "$DO_PERSISTENCE_SCAN" = true ] || [ "$FORENSIC_ANALYSIS" = true ]; then
            cat >> "$html_file" << HTMLEOF
            <tr><td colspan="3"><strong>Persistence Artifacts</strong></td></tr>
            <tr><td>&nbsp;&nbsp;Registry Run Keys</td><td class="stat-value">${STATS[persistence_run_keys]:-0}</td><td>T1547.001</td></tr>
            <tr><td>&nbsp;&nbsp;Services</td><td class="stat-value">${STATS[persistence_services]:-0}</td><td>T1543.003</td></tr>
            <tr><td>&nbsp;&nbsp;Scheduled Tasks</td><td class="stat-value">${STATS[persistence_tasks]:-0}</td><td>T1053.005</td></tr>
            <tr><td>&nbsp;&nbsp;Startup Folders</td><td class="stat-value">${STATS[persistence_startup]:-0}</td><td>T1547.001</td></tr>
            <tr><td>&nbsp;&nbsp;WMI Subscriptions</td><td class="stat-value">${STATS[persistence_wmi]:-0}</td><td>T1546.003</td></tr>
HTMLEOF
        fi

        # Execution findings
        if [ "$DO_EXECUTION_SCAN" = true ] || [ "$FORENSIC_ANALYSIS" = true ]; then
            cat >> "$html_file" << HTMLEOF
            <tr><td colspan="3"><strong>Execution Artifacts</strong></td></tr>
            <tr><td>&nbsp;&nbsp;Prefetch Files</td><td class="stat-value">${STATS[execution_prefetch]:-0}</td><td>Execution evidence</td></tr>
            <tr><td>&nbsp;&nbsp;Amcache Entries</td><td class="stat-value">${STATS[execution_amcache]:-0}</td><td>SHA1 hashes available</td></tr>
            <tr><td>&nbsp;&nbsp;Shimcache Entries</td><td class="stat-value">${STATS[execution_shimcache]:-0}</td><td>Application compatibility</td></tr>
            <tr><td>&nbsp;&nbsp;UserAssist Records</td><td class="stat-value">${STATS[execution_userassist]:-0}</td><td>GUI execution</td></tr>
            <tr><td>&nbsp;&nbsp;Execution Anomalies</td><td class="stat-value">${STATS[execution_anomalies]:-0}</td><td>Suspicious paths/names</td></tr>
HTMLEOF
        fi

        # File anomalies findings
        if [ "$DO_FILE_ANOMALIES" = true ] || [ "$FORENSIC_ANALYSIS" = true ]; then
            cat >> "$html_file" << HTMLEOF
            <tr><td colspan="3"><strong>File Anomalies</strong></td></tr>
            <tr><td>&nbsp;&nbsp;Magic/Extension Mismatch</td><td class="stat-value">${STATS[file_magic_mismatch]:-0}</td><td>T1036.005</td></tr>
            <tr><td>&nbsp;&nbsp;Alternate Data Streams</td><td class="stat-value">${STATS[file_ads]:-0}</td><td>Hidden data (NTFS)</td></tr>
            <tr><td>&nbsp;&nbsp;Suspicious Locations</td><td class="stat-value">${STATS[file_suspicious_location]:-0}</td><td>Executables in temp/etc</td></tr>
            <tr><td>&nbsp;&nbsp;Packed Executables</td><td class="stat-value">${STATS[file_packed]:-0}</td><td>Possible obfuscation</td></tr>
            <tr><td>&nbsp;&nbsp;Timestomping Detected</td><td class="stat-value">${STATS[timestomping_detected]:-0}</td><td>T1070.006</td></tr>
HTMLEOF
        fi

        # RE triage findings
        if [ "$DO_RE_TRIAGE" = true ] || [ "$FORENSIC_ANALYSIS" = true ]; then
            cat >> "$html_file" << HTMLEOF
            <tr><td colspan="3"><strong>RE Triage</strong></td></tr>
            <tr><td>&nbsp;&nbsp;Files Analyzed</td><td class="stat-value">${STATS[re_triaged_files]:-0}</td><td>capa/pefile analysis</td></tr>
            <tr><td>&nbsp;&nbsp;Suspicious Imports</td><td class="stat-value">${STATS[re_suspicious_imports]:-0}</td><td>Process injection/hollowing APIs</td></tr>
            <tr><td>&nbsp;&nbsp;Suspicious Strings</td><td class="stat-value">${STATS[re_suspicious_strings]:-0}</td><td>URLs, IPs, commands</td></tr>
            <tr><td>&nbsp;&nbsp;ATT&CK Techniques</td><td class="stat-value">${STATS[attack_techniques_mapped]:-0}</td><td>MITRE mappings found</td></tr>
HTMLEOF
        fi

        # MFT findings
        if [ "$DO_MFT_ANALYSIS" = true ] || [ "$FORENSIC_ANALYSIS" = true ]; then
            cat >> "$html_file" << HTMLEOF
            <tr><td colspan="3"><strong>Filesystem Forensics</strong></td></tr>
            <tr><td>&nbsp;&nbsp;MFT Records Parsed</td><td class="stat-value">${STATS[mft_records_parsed]:-0}</td><td>\$MFT analysis</td></tr>
            <tr><td>&nbsp;&nbsp;Deleted Files Found</td><td class="stat-value">${STATS[mft_deleted_recovered]:-0}</td><td>Recoverable entries</td></tr>
            <tr><td>&nbsp;&nbsp;USN Journal Entries</td><td class="stat-value">${STATS[usn_entries_parsed]:-0}</td><td>\$UsnJrnl analysis</td></tr>
HTMLEOF
        fi

        cat >> "$html_file" << HTMLEOF
        </table>
HTMLEOF

        # Show MITRE ATT&CK summary if any techniques mapped
        local total_attack_mapped=${STATS[attack_techniques_mapped]:-0}
        if [ "$total_attack_mapped" -gt 0 ]; then
            cat >> "$html_file" << HTMLEOF
        <h3>MITRE ATT&CK Techniques Detected</h3>
        <div class="forensic-box">
            <p>The following techniques were identified during forensic analysis:</p>
            <p>
HTMLEOF
            # Add badges for detected techniques
            [ "${STATS[persistence_run_keys]:-0}" -gt 0 ] && echo '<span class="attack-badge">T1547.001 Registry Run Keys</span>' >> "$html_file"
            [ "${STATS[persistence_services]:-0}" -gt 0 ] && echo '<span class="attack-badge">T1543.003 Windows Service</span>' >> "$html_file"
            [ "${STATS[persistence_tasks]:-0}" -gt 0 ] && echo '<span class="attack-badge">T1053.005 Scheduled Task</span>' >> "$html_file"
            [ "${STATS[persistence_wmi]:-0}" -gt 0 ] && echo '<span class="attack-badge">T1546.003 WMI Event Sub</span>' >> "$html_file"
            [ "${STATS[file_magic_mismatch]:-0}" -gt 0 ] && echo '<span class="attack-badge">T1036.005 Masquerading</span>' >> "$html_file"
            [ "${STATS[timestomping_detected]:-0}" -gt 0 ] && echo '<span class="attack-badge">T1070.006 Timestomping</span>' >> "$html_file"
            [ "${STATS[re_suspicious_imports]:-0}" -gt 0 ] && echo '<span class="attack-badge">T1055 Process Injection</span>' >> "$html_file"

            cat >> "$html_file" << HTMLEOF
            </p>
        </div>
HTMLEOF
        fi
    fi

    cat >> "$html_file" << HTMLEOF

        <h2>Output Location</h2>
        <div class="info-box">
            <strong>Scan output directory:</strong> $SCAN_OUTPUT_DIR<br>
            <strong>Statistics report:</strong> statistics_report_*.txt
        </div>

        <p class="timestamp" style="text-align:center; margin-top:30px;">
            DMS - Drive Malware Scanner v2.1
        </p>
    </div>
</body>
</html>
HTMLEOF

    print_success "HTML report saved to: $html_file"
}

generate_json_report() {
    local json_file="$SCAN_OUTPUT_DIR/scan_report_$(date +%Y%m%d_%H%M%S).json"

    print_status "Generating JSON report..."

    # Calculate total findings
    local total_findings=0
    for key in "${!RESULTS[@]}"; do
        local val="${RESULTS[$key]}"
        if [[ "$val" =~ ^[0-9]+$ ]]; then
            total_findings=$((total_findings + val))
        fi
    done

    cat > "$json_file" << JSONEOF
{
    "report": {
        "version": "2.1",
        "generated": "$(date -Iseconds)",
        "tool": "DMS - Drive Malware Scanner"
    },
    "device": {
        "path": "$DEVICE",
        "size_gb": ${DEVICE_SIZE_GB:-0},
        "filesystem": "$FS_TYPE"
    },
    "scan_config": {
        "mode": "$SCAN_MODE",
        "type": "$([ "$DEEP_SCAN" = true ] && echo "deep" || echo "standard")",
        "parallel": $([ "$PARALLEL_MODE" = true ] && echo "true" || echo "false"),
        "quick": $([ "$QUICK_SCAN" = true ] && echo "true" || echo "false"),
        "chunk_size_mb": $CHUNK_SIZE
    },
    "results": {
        "clamav": ${RESULTS[clamav]:-0},
        "yara_windows": ${RESULTS[yara_Windows]:-0},
        "yara_linux": ${RESULTS[yara_Linux]:-0},
        "yara_android": ${RESULTS[yara_Android]:-0},
        "yara_documents": ${RESULTS[yara_Documents]:-0},
        "binwalk": ${RESULTS[binwalk]:-0},
        "strings": ${RESULTS[strings]:-0},
        "entropy": ${RESULTS[entropy]:-0},
        "carved_files": ${RESULTS[carved_files]:-0},
        "carved_malware": ${RESULTS[carved_malware]:-0},
        "pe_executables": ${RESULTS[pe_executables]:-0},
        "elf_executables": ${RESULTS[elf_executables]:-0},
        "boot_sector": ${RESULTS[boot_sector]:-0},
        "virustotal": ${RESULTS[virustotal]:-0},
        "rootkit": ${RESULTS[rootkit]:-0}
    },
    "statistics": {
        "clamav_scanned": ${STATS[clamav_scanned]:-0},
        "clamav_infected": ${STATS[clamav_infected]:-0},
        "yara_rules_checked": ${STATS[yara_rules_checked]:-0},
        "yara_matches": ${STATS[yara_matches]:-0},
        "strings_total": ${STATS[strings_total]:-0},
        "strings_urls": ${STATS[strings_urls]:-0},
        "entropy_regions_scanned": ${STATS[entropy_regions_scanned]:-0},
        "entropy_high_count": ${STATS[entropy_high_count]:-0},
        "carved_total": ${STATS[carved_total]:-0},
        "carved_executables": ${STATS[carved_executables]:-0},
        "slack_size_mb": ${STATS[slack_size_mb]:-0},
        "slack_files_recovered": ${STATS[slack_files_recovered]:-0},
        "slack_data_recovered_mb": ${STATS[slack_data_recovered_mb]:-0},
        "pe_headers": ${STATS[pe_headers]:-0},
        "elf_headers": ${STATS[elf_headers]:-0},
        "bulk_emails": ${STATS[bulk_emails]:-0},
        "bulk_urls": ${STATS[bulk_urls]:-0}
    },
    "summary": {
        "total_findings": $total_findings,
        "items_to_review": $total_findings
    },
    "output_directory": "$SCAN_OUTPUT_DIR",
    "behavioral_findings": {
        "enabled": $([ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_PERSISTENCE_SCAN" = true ] || [ "$DO_EXECUTION_SCAN" = true ] || [ "$DO_FILE_ANOMALIES" = true ] || [ "$DO_RE_TRIAGE" = true ] || [ "$DO_MFT_ANALYSIS" = true ] && echo "true" || echo "false"),
        "persistence": {
            "run_keys": ${STATS[persistence_run_keys]:-0},
            "services": ${STATS[persistence_services]:-0},
            "scheduled_tasks": ${STATS[persistence_tasks]:-0},
            "startup_folders": ${STATS[persistence_startup]:-0},
            "wmi_subscriptions": ${STATS[persistence_wmi]:-0},
            "dll_hijack_paths": ${STATS[persistence_dll_hijack]:-0}
        },
        "execution_evidence": {
            "prefetch_files": ${STATS[execution_prefetch]:-0},
            "amcache_entries": ${STATS[execution_amcache]:-0},
            "shimcache_entries": ${STATS[execution_shimcache]:-0},
            "userassist_records": ${STATS[execution_userassist]:-0},
            "srum_entries": ${STATS[execution_srum]:-0},
            "bam_entries": ${STATS[execution_bam]:-0},
            "execution_anomalies": ${STATS[execution_anomalies]:-0}
        },
        "file_anomalies": {
            "magic_mismatch": ${STATS[file_magic_mismatch]:-0},
            "alternate_data_streams": ${STATS[file_ads]:-0},
            "suspicious_locations": ${STATS[file_suspicious_location]:-0},
            "packed_executables": ${STATS[file_packed]:-0},
            "attribute_anomalies": ${STATS[file_attribute_anomalies]:-0},
            "timestomping_detected": ${STATS[timestomping_detected]:-0}
        },
        "re_triage": {
            "files_analyzed": ${STATS[re_triaged_files]:-0},
            "suspicious_imports": ${STATS[re_suspicious_imports]:-0},
            "suspicious_strings": ${STATS[re_suspicious_strings]:-0},
            "capa_capabilities": ${STATS[capa_capabilities]:-0}
        },
        "filesystem_forensics": {
            "mft_records_parsed": ${STATS[mft_records_parsed]:-0},
            "deleted_files_recovered": ${STATS[mft_deleted_recovered]:-0},
            "usn_entries_parsed": ${STATS[usn_entries_parsed]:-0}
        },
        "attack_techniques": {
            "total_mapped": ${STATS[attack_techniques_mapped]:-0},
            "techniques": [
                $([ "${STATS[persistence_run_keys]:-0}" -gt 0 ] && echo '"T1547.001",' || echo "")
                $([ "${STATS[persistence_services]:-0}" -gt 0 ] && echo '"T1543.003",' || echo "")
                $([ "${STATS[persistence_tasks]:-0}" -gt 0 ] && echo '"T1053.005",' || echo "")
                $([ "${STATS[persistence_wmi]:-0}" -gt 0 ] && echo '"T1546.003",' || echo "")
                $([ "${STATS[file_magic_mismatch]:-0}" -gt 0 ] && echo '"T1036.005",' || echo "")
                $([ "${STATS[timestomping_detected]:-0}" -gt 0 ] && echo '"T1070.006",' || echo "")
                $([ "${STATS[re_suspicious_imports]:-0}" -gt 0 ] && echo '"T1055"' || echo '"NONE"')
            ]
        }
    }
}
JSONEOF

    print_success "JSON report saved to: $json_file"
}

# ==========================================
# INTERACTIVE MODE - Full TUI with Navigation
# ==========================================

# TUI State variables
declare -g TUI_SELECTED=0
declare -g TUI_INPUT_PATH=""
declare -g TUI_SCAN_TYPE="standard"  # quick, standard, deep
declare -g TUI_SCAN_SCOPE="full"     # full, slack
declare -g TUI_OPT_MOUNT=false
declare -g TUI_OPT_UPDATE=false
declare -g TUI_OPT_PARALLEL=false
declare -g TUI_OPT_AUTOCHUNK=false
declare -g TUI_OPT_VIRUSTOTAL=false
declare -g TUI_OPT_ROOTKIT=false
declare -g TUI_OPT_TIMELINE=false
declare -g TUI_OPT_HTML=false
declare -g TUI_OPT_JSON=false
declare -g TUI_OPT_VERIFY_HASH=false
declare -g TUI_OPT_KEEP_OUTPUT=false
# Forensic analysis options
declare -g TUI_OPT_FORENSIC_ALL=false
declare -g TUI_OPT_PERSISTENCE=false
declare -g TUI_OPT_EXECUTION=false
declare -g TUI_OPT_FILE_ANOMALIES=false
declare -g TUI_OPT_RE_TRIAGE=false
declare -g TUI_OPT_MFT_ANALYSIS=false
declare -g TUI_DETECTED_TYPE=""

# Menu items count (added 2 for scan scope: full, slack)
TUI_MENU_ITEMS=23

# Track if TUI has been rendered before (for in-place updates)
declare -g TUI_RENDERED=false

# Clear to end of line escape sequence
CLR_EOL="\033[K"

# TUI box drawing constants
TUI_TOP="${HEADER_COLOR}╔══════════════════════════════════════════════════════════════════════╗${NC}"
TUI_SEP="${HEADER_COLOR}╠══════════════════════════════════════════════════════════════════════╣${NC}"
TUI_DIV="${HEADER_COLOR}╟──────────────────────────────────────────────────────────────────────╢${NC}"
TUI_BOT="${HEADER_COLOR}╚══════════════════════════════════════════════════════════════════════╝${NC}"

# Print a TUI line directly
tui_line() {
    echo -e "$1"
}

# Print a section header
# Usage: tui_section "TITLE"
tui_section() {
    local title="$1"
    local title_len=${#title}
    local padding=$((68 - title_len))  # 70 - 2 (prefix "  ")
    [ $padding -lt 0 ] && padding=0
    local pad_str=$(printf '%*s' "$padding" '')
    tui_line "$TUI_DIV"
    tui_line "${HEADER_COLOR}║${NC}  ${BOLD}${title}${NC}${pad_str}${HEADER_COLOR}║${NC}"
    tui_line "$TUI_DIV"
}

# Print a menu item line
# Usage: tui_item <index> "content_with_trailing_spaces_to_fill_width"
tui_item() {
    local idx="$1"
    local content="$2"
    local prefix="  "
    [ $TUI_SELECTED -eq $idx ] && prefix="${CYAN}▶ ${NC}"
    tui_line "${HEADER_COLOR}║${NC}${prefix}${content}${HEADER_COLOR}║${NC}"
}

# Read a single keypress (including arrow keys)
tui_read_key() {
    local key
    IFS= read -rsn1 key 2>/dev/null

    if [[ $key == $'\x1b' ]]; then
        read -rsn2 -t 0.05 key 2>/dev/null
        # Drain any remaining escape sequence bytes (mouse events, etc)
        while read -rsn1 -t 0.001 _ 2>/dev/null; do :; done
        case "$key" in
            '[A') echo "UP" ;;
            '[B') echo "DOWN" ;;
            '[C') echo "RIGHT" ;;
            '[D') echo "LEFT" ;;
            *) echo "IGNORED" ;;
        esac
    elif [[ $key == "" ]]; then
        echo "ENTER"
    elif [[ $key == " " ]]; then
        echo "SPACE"
    elif [[ $key == "q" || $key == "Q" ]]; then
        echo "QUIT"
    elif [[ $key == "s" || $key == "S" ]]; then
        echo "START"
    elif [[ $key == "i" || $key == "I" ]]; then
        echo "INPUT"
    elif [[ $key == "1" ]]; then
        echo "1"
    elif [[ $key == "2" ]]; then
        echo "2"
    elif [[ $key == "3" ]]; then
        echo "3"
    else
        echo "IGNORED"
    fi
}

# Get checkbox display (cleaner characters)
tui_checkbox() {
    if [ "$1" = true ]; then
        printf "${GREEN}[✓]${NC}"
    else
        printf "${MUTED_COLOR}[ ]${NC}"
    fi
}

# Get radio button display (cleaner characters)
tui_radio() {
    if [ "$1" = "$2" ]; then
        printf "${GREEN}(●)${NC}"
    else
        printf "${MUTED_COLOR}( )${NC}"
    fi
}

# Render the TUI
tui_render() {
    # Clear screen and hide cursor
    printf "\033[2J\033[H\033[?25l"

    # Header
    tui_line "$TUI_TOP"
    tui_line "${HEADER_COLOR}║${NC}               ${BOLD}DMS - DRIVE MALWARE SCAN${NC}                               ${HEADER_COLOR}║${NC}"
    tui_line "${HEADER_COLOR}║${NC}        ${MUTED_COLOR}Use ↑↓ to navigate, Space/Enter to toggle, S to start${NC}        ${HEADER_COLOR}║${NC}"
    tui_line "$TUI_SEP"

    # INPUT SOURCE
    tui_section "INPUT SOURCE"
    local path_display="${TUI_INPUT_PATH:-${MUTED_COLOR}(press Enter/I to set path)${NC}}"
    local type_display="" && [ -n "$TUI_DETECTED_TYPE" ] && type_display=" ${MUTED_COLOR}[${TUI_DETECTED_TYPE}]${NC}"
    tui_item 0 "Path: ${path_display}${type_display}                                        "

    # SCAN TYPE
    tui_section "SCAN TYPE"
    tui_item 1 "$(tui_radio "$TUI_SCAN_TYPE" "quick") Quick Scan       ${MUTED_COLOR}Fast sample-based analysis${NC}              "
    tui_item 2 "$(tui_radio "$TUI_SCAN_TYPE" "standard") Standard Scan    ${MUTED_COLOR}ClamAV + YARA + Strings + Binwalk${NC}       "
    tui_item 3 "$(tui_radio "$TUI_SCAN_TYPE" "deep") Deep Scan        ${MUTED_COLOR}All scanners + entropy + carving${NC}        "

    # SCAN SCOPE
    tui_section "SCAN SCOPE"
    tui_item 4 "$(tui_radio "$TUI_SCAN_SCOPE" "full") Full Drive       ${MUTED_COLOR}Scan entire device including all data${NC}   "
    tui_item 5 "$(tui_radio "$TUI_SCAN_SCOPE" "slack") Slack Space      ${MUTED_COLOR}Scan only unallocated/deleted areas${NC}     "

    # OPTIONS
    tui_section "OPTIONS"
    tui_item 6  "$(tui_checkbox $TUI_OPT_MOUNT) Mount device before scanning                              "
    tui_item 7  "$(tui_checkbox $TUI_OPT_UPDATE) Update ClamAV databases                                   "
    tui_item 8  "$(tui_checkbox $TUI_OPT_PARALLEL) Parallel scanning mode                                    "
    tui_item 9  "$(tui_checkbox $TUI_OPT_AUTOCHUNK) Auto-calculate chunk size                                 "
    tui_item 10 "$(tui_checkbox $TUI_OPT_VERIFY_HASH) Verify EWF hash before scan ${MUTED_COLOR}(forensic integrity)${NC}       "

    # ADDITIONAL FEATURES
    tui_section "ADDITIONAL FEATURES"
    tui_item 11 "$(tui_checkbox $TUI_OPT_VIRUSTOTAL) VirusTotal hash lookup ${MUTED_COLOR}(requires API key)${NC}              "
    tui_item 12 "$(tui_checkbox $TUI_OPT_ROOTKIT) Rootkit detection ${MUTED_COLOR}(requires mount)${NC}                     "
    tui_item 13 "$(tui_checkbox $TUI_OPT_TIMELINE) Generate file timeline                                    "

    # FORENSIC ANALYSIS
    tui_line "$TUI_DIV"
    tui_line "${HEADER_COLOR}║${NC}  ${BOLD}FORENSIC ANALYSIS${NC} ${MUTED_COLOR}(Windows artifacts)${NC}                              ${HEADER_COLOR}║${NC}"
    tui_line "$TUI_DIV"
    tui_item 14 "$(tui_checkbox $TUI_OPT_FORENSIC_ALL) ${BOLD}Full forensic analysis${NC} ${MUTED_COLOR}(enables all below)${NC}              "
    tui_item 15 "$(tui_checkbox $TUI_OPT_PERSISTENCE) Persistence artifacts ${MUTED_COLOR}(registry, tasks, services)${NC}        "
    tui_item 16 "$(tui_checkbox $TUI_OPT_EXECUTION) Execution artifacts ${MUTED_COLOR}(prefetch, amcache, shimcache)${NC}      "
    tui_item 17 "$(tui_checkbox $TUI_OPT_FILE_ANOMALIES) File anomalies ${MUTED_COLOR}(magic mismatch, ADS, timestomping)${NC}   "
    tui_item 18 "$(tui_checkbox $TUI_OPT_RE_TRIAGE) RE triage ${MUTED_COLOR}(capa, suspicious imports, shellcode)${NC}       "
    tui_item 19 "$(tui_checkbox $TUI_OPT_MFT_ANALYSIS) MFT/filesystem forensics ${MUTED_COLOR}(deleted files, USN)${NC}         "

    # OUTPUT
    tui_section "OUTPUT"
    tui_item 20 "$(tui_checkbox $TUI_OPT_HTML) Generate HTML report                                     "
    tui_item 21 "$(tui_checkbox $TUI_OPT_JSON) Generate JSON report                                     "
    tui_item 22 "$(tui_checkbox $TUI_OPT_KEEP_OUTPUT) Keep output directory after scan                          "

    # Actions footer
    tui_line "$TUI_SEP"
    tui_line "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    tui_line "${HEADER_COLOR}║${NC}      ${GREEN}[S]${NC} Start Scan    ${YELLOW}[I]${NC} Set Input Path    ${RED}[Q]${NC} Quit              ${HEADER_COLOR}║${NC}"
    tui_line "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    tui_line "$TUI_BOT"

    # Status line
    tui_line ""
    if [ -z "$TUI_INPUT_PATH" ]; then
        tui_line "  ${YELLOW}⚠${NC}  Please set an input path before starting the scan"
    elif [ -n "$TUI_DETECTED_TYPE" ]; then
        tui_line "  ${GREEN}✓${NC}  Ready to scan: ${BOLD}$TUI_INPUT_PATH${NC} (${TUI_DETECTED_TYPE})"
    else
        tui_line ""
    fi
}

# Toggle the currently selected option
tui_toggle() {
    case $TUI_SELECTED in
        0)  # Input path - prompt for input
            tui_input_path
            ;;
        1) TUI_SCAN_TYPE="quick" ;;
        2) TUI_SCAN_TYPE="standard" ;;
        3) TUI_SCAN_TYPE="deep" ;;
        4) TUI_SCAN_SCOPE="full" ;;
        5) TUI_SCAN_SCOPE="slack" ;;
        6) TUI_OPT_MOUNT=$([ "$TUI_OPT_MOUNT" = true ] && echo false || echo true) ;;
        7) TUI_OPT_UPDATE=$([ "$TUI_OPT_UPDATE" = true ] && echo false || echo true) ;;
        8) TUI_OPT_PARALLEL=$([ "$TUI_OPT_PARALLEL" = true ] && echo false || echo true) ;;
        9) TUI_OPT_AUTOCHUNK=$([ "$TUI_OPT_AUTOCHUNK" = true ] && echo false || echo true) ;;
        10) TUI_OPT_VERIFY_HASH=$([ "$TUI_OPT_VERIFY_HASH" = true ] && echo false || echo true) ;;
        11) TUI_OPT_VIRUSTOTAL=$([ "$TUI_OPT_VIRUSTOTAL" = true ] && echo false || echo true) ;;
        12) TUI_OPT_ROOTKIT=$([ "$TUI_OPT_ROOTKIT" = true ] && echo false || echo true) ;;
        13) TUI_OPT_TIMELINE=$([ "$TUI_OPT_TIMELINE" = true ] && echo false || echo true) ;;
        # Forensic analysis options
        14) # Full forensic - enables all forensic options
            TUI_OPT_FORENSIC_ALL=$([ "$TUI_OPT_FORENSIC_ALL" = true ] && echo false || echo true)
            if [ "$TUI_OPT_FORENSIC_ALL" = true ]; then
                TUI_OPT_PERSISTENCE=true
                TUI_OPT_EXECUTION=true
                TUI_OPT_FILE_ANOMALIES=true
                TUI_OPT_RE_TRIAGE=true
                TUI_OPT_MFT_ANALYSIS=true
            fi
            ;;
        15) TUI_OPT_PERSISTENCE=$([ "$TUI_OPT_PERSISTENCE" = true ] && echo false || echo true) ;;
        16) TUI_OPT_EXECUTION=$([ "$TUI_OPT_EXECUTION" = true ] && echo false || echo true) ;;
        17) TUI_OPT_FILE_ANOMALIES=$([ "$TUI_OPT_FILE_ANOMALIES" = true ] && echo false || echo true) ;;
        18) TUI_OPT_RE_TRIAGE=$([ "$TUI_OPT_RE_TRIAGE" = true ] && echo false || echo true) ;;
        19) TUI_OPT_MFT_ANALYSIS=$([ "$TUI_OPT_MFT_ANALYSIS" = true ] && echo false || echo true) ;;
        # Output options
        20) TUI_OPT_HTML=$([ "$TUI_OPT_HTML" = true ] && echo false || echo true) ;;
        21) TUI_OPT_JSON=$([ "$TUI_OPT_JSON" = true ] && echo false || echo true) ;;
        22) TUI_OPT_KEEP_OUTPUT=$([ "$TUI_OPT_KEEP_OUTPUT" = true ] && echo false || echo true) ;;
    esac
}

# Input path dialog
tui_input_path() {
    # Show cursor for input, clear screen
    printf "\033[?25h\033[2J\033[H"

    echo -e "${HEADER_COLOR}╔══════════════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${HEADER_COLOR}║${NC}                       ${BOLD}SET INPUT PATH${NC}                                 ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╠══════════════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}  Enter the path to a device or forensic image:                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}  ${MUTED_COLOR}Examples:${NC}                                                          ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}    • /dev/sdb1              ${MUTED_COLOR}(block device)${NC}                        ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}    • /evidence/disk.E01     ${MUTED_COLOR}(EWF forensic image)${NC}                  ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}    • /images/disk.raw       ${MUTED_COLOR}(raw disk image)${NC}                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}║${NC}                                                                      ${HEADER_COLOR}║${NC}"
    echo -e "${HEADER_COLOR}╚══════════════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # Show available block devices
    echo -e "  ${BOLD}Available block devices:${NC}"
    lsblk -d -o NAME,SIZE,TYPE,MOUNTPOINT 2>/dev/null | head -10 | while read line; do
        echo -e "    ${MUTED_COLOR}$line${NC}"
    done
    echo ""

    # Read input with line editing
    read -e -p "  Path: " -i "$TUI_INPUT_PATH" new_path

    if [ -n "$new_path" ]; then
        TUI_INPUT_PATH="$new_path"
        # Detect type
        TUI_DETECTED_TYPE=$(detect_input_type "$TUI_INPUT_PATH")

        # Auto-enable verify hash for EWF
        if [ "$TUI_DETECTED_TYPE" = "ewf" ]; then
            echo ""
            echo -e "  ${GREEN}✓${NC} Detected EWF forensic image"
            echo -e "  ${MUTED_COLOR}Tip: Enable 'Verify EWF hash' for forensic integrity${NC}"
            sleep 1
        fi
    fi

    # Hide cursor again for TUI
    printf "\033[?25l"
}

# Apply TUI selections to actual variables
tui_apply_selections() {
    DEVICE="$TUI_INPUT_PATH"

    case "$TUI_SCAN_TYPE" in
        quick) QUICK_SCAN=true ;;
        deep) DEEP_SCAN=true ;;
        standard) ;; # defaults
    esac

    # Apply scan scope
    SCAN_MODE="$TUI_SCAN_SCOPE"

    DO_MOUNT="$TUI_OPT_MOUNT"
    DO_UPDATE="$TUI_OPT_UPDATE"
    PARALLEL_MODE="$TUI_OPT_PARALLEL"
    AUTO_CHUNK="$TUI_OPT_AUTOCHUNK"
    VERIFY_EWF_HASH="$TUI_OPT_VERIFY_HASH"
    DO_VIRUSTOTAL="$TUI_OPT_VIRUSTOTAL"
    DO_ROOTKIT="$TUI_OPT_ROOTKIT"
    DO_TIMELINE="$TUI_OPT_TIMELINE"
    HTML_REPORT="$TUI_OPT_HTML"
    JSON_REPORT="$TUI_OPT_JSON"
    KEEP_OUTPUT="$TUI_OPT_KEEP_OUTPUT"

    # Forensic analysis options
    if [ "$TUI_OPT_FORENSIC_ALL" = true ]; then
        FORENSIC_ANALYSIS=true
    fi
    DO_PERSISTENCE_SCAN="$TUI_OPT_PERSISTENCE"
    DO_EXECUTION_SCAN="$TUI_OPT_EXECUTION"
    DO_FILE_ANOMALIES="$TUI_OPT_FILE_ANOMALIES"
    DO_RE_TRIAGE="$TUI_OPT_RE_TRIAGE"
    DO_MFT_ANALYSIS="$TUI_OPT_MFT_ANALYSIS"
}

# Main interactive mode loop
run_interactive_mode() {
    # Disable mouse tracking, hide cursor, clear screen
    printf "\033[?1000l\033[?1002l\033[?1003l\033[?25l\033[2J\033[H"

    # On exit: show cursor, reset terminal
    trap 'printf "\033[?25h\033[0m"' EXIT INT TERM

    # Initialize
    TUI_SELECTED=0

    while true; do
        tui_render

        local key=$(tui_read_key)

        case "$key" in
            UP)
                TUI_SELECTED=$((TUI_SELECTED - 1))
                [ $TUI_SELECTED -lt 0 ] && TUI_SELECTED=$((TUI_MENU_ITEMS - 1))
                ;;
            DOWN)
                TUI_SELECTED=$((TUI_SELECTED + 1))
                [ $TUI_SELECTED -ge $TUI_MENU_ITEMS ] && TUI_SELECTED=0
                ;;
            SPACE|ENTER)
                tui_toggle
                ;;
            INPUT|i|I)
                tui_input_path
                ;;
            START|s|S)
                if [ -z "$TUI_INPUT_PATH" ]; then
                    echo -e "\n  ${RED}Error:${NC} Please set an input path first"
                    sleep 1
                else
                    # Apply selections and start scan
                    tui_apply_selections
                    printf "\033[?25h\033[2J\033[H"  # Show cursor, clear, home

                    # Show what was selected
                    echo ""
                    echo -e "${GREEN}${BOLD}Starting scan with selected options:${NC}"
                    echo -e "  Input:      ${BOLD}$DEVICE${NC}"
                    echo -e "  Scan type:  ${BOLD}$TUI_SCAN_TYPE${NC}"
                    [ "$DO_MOUNT" = true ] && echo -e "  ${SYMBOL_CHECK} Mount device"
                    [ "$DO_UPDATE" = true ] && echo -e "  ${SYMBOL_CHECK} Update ClamAV"
                    [ "$PARALLEL_MODE" = true ] && echo -e "  ${SYMBOL_CHECK} Parallel mode"
                    [ "$VERIFY_EWF_HASH" = true ] && echo -e "  ${SYMBOL_CHECK} Verify EWF hash"
                    [ "$HTML_REPORT" = true ] && echo -e "  ${SYMBOL_CHECK} HTML report"
                    [ "$JSON_REPORT" = true ] && echo -e "  ${SYMBOL_CHECK} JSON report"
                    # Forensic analysis status
                    if [ "$FORENSIC_ANALYSIS" = true ]; then
                        echo -e "  ${SYMBOL_CHECK} Full forensic analysis"
                    else
                        [ "$DO_PERSISTENCE_SCAN" = true ] && echo -e "  ${SYMBOL_CHECK} Persistence artifacts"
                        [ "$DO_EXECUTION_SCAN" = true ] && echo -e "  ${SYMBOL_CHECK} Execution artifacts"
                        [ "$DO_FILE_ANOMALIES" = true ] && echo -e "  ${SYMBOL_CHECK} File anomalies"
                        [ "$DO_RE_TRIAGE" = true ] && echo -e "  ${SYMBOL_CHECK} RE triage"
                        [ "$DO_MFT_ANALYSIS" = true ] && echo -e "  ${SYMBOL_CHECK} MFT/filesystem forensics"
                    fi
                    echo ""
                    sleep 1
                    return 0
                fi
                ;;
            QUIT|q|Q)
                printf "\033[?25h\033[2J\033[H"  # Show cursor, clear, home
                echo "Exiting..."
                exit 0
                ;;
            1)
                TUI_SCAN_TYPE="quick"
                ;;
            2)
                TUI_SCAN_TYPE="standard"
                ;;
            3)
                TUI_SCAN_TYPE="deep"
                ;;
            *)
                # Ignore unknown keys (including mouse events)
                ;;
        esac
    done
}

# ==========================================
# MAIN EXECUTION
# ==========================================

main() {
    # Parse arguments first to set modes
    DEVICE=""
    DO_MOUNT=false
    DO_UPDATE=false
    DEEP_SCAN=false
    OUTPUT_FILE=""
    PARALLEL_MODE=false
    AUTO_CHUNK=false
    QUICK_SCAN=false
    DO_VIRUSTOTAL=false
    DO_ROOTKIT=false
    DO_TIMELINE=false
    RESUME_FILE=""
    HTML_REPORT=false
    JSON_REPORT=false
    QUIET_MODE=false
    VERBOSE_MODE=false
    DRY_RUN=false
    CUSTOM_CONFIG=""
    KEEP_OUTPUT=false
    SAVE_CHECKPOINT=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            -m|--mount)
                DO_MOUNT=true
                shift
                ;;
            -u|--update)
                DO_UPDATE=true
                shift
                ;;
            -d|--deep)
                DEEP_SCAN=true
                shift
                ;;
            -o|--output)
                OUTPUT_FILE="$2"
                shift 2
                ;;
            -p|--parallel)
                PARALLEL_MODE=true
                shift
                ;;
            --auto-chunk)
                AUTO_CHUNK=true
                shift
                ;;
            --quick)
                QUICK_SCAN=true
                shift
                ;;
            --virustotal)
                DO_VIRUSTOTAL=true
                shift
                ;;
            --rootkit)
                DO_ROOTKIT=true
                shift
                ;;
            --timeline)
                DO_TIMELINE=true
                shift
                ;;
            --resume)
                RESUME_FILE="$2"
                shift 2
                ;;
            --html)
                HTML_REPORT=true
                shift
                ;;
            --json)
                JSON_REPORT=true
                shift
                ;;
            -q|--quiet)
                QUIET_MODE=true
                LOG_LEVEL="ERROR"
                shift
                ;;
            -v|--verbose)
                VERBOSE_MODE=true
                LOG_LEVEL="DEBUG"
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            --config)
                CUSTOM_CONFIG="$2"
                shift 2
                ;;
            --log-file)
                LOG_FILE="$2"
                shift 2
                ;;
            --keep-output)
                KEEP_OUTPUT=true
                shift
                ;;
            --portable)
                PORTABLE_MODE=true
                shift
                ;;
            --portable-keep)
                PORTABLE_KEEP=true
                shift
                ;;
            --portable-dir)
                PORTABLE_TOOLS_DIR="$2"
                shift 2
                ;;
            --verify-hash)
                VERIFY_EWF_HASH=true
                shift
                ;;
            --input-format)
                FORCE_INPUT_FORMAT="$2"
                shift 2
                ;;
            --scan-mode)
                if [ "$2" = "full" ] || [ "$2" = "slack" ]; then
                    SCAN_MODE="$2"
                else
                    print_error "Invalid scan mode: $2 (use 'full' or 'slack')"
                    exit 1
                fi
                shift 2
                ;;
            --slack)
                SCAN_MODE="slack"
                shift
                ;;
            --forensic-analysis)
                FORENSIC_ANALYSIS=true
                DO_PERSISTENCE_SCAN=true
                DO_EXECUTION_SCAN=true
                DO_FILE_ANOMALIES=true
                DO_RE_TRIAGE=true
                shift
                ;;
            --persistence-scan)
                DO_PERSISTENCE_SCAN=true
                shift
                ;;
            --execution-scan)
                DO_EXECUTION_SCAN=true
                shift
                ;;
            --file-anomalies)
                DO_FILE_ANOMALIES=true
                shift
                ;;
            --re-triage)
                DO_RE_TRIAGE=true
                shift
                ;;
            --mft-analysis)
                DO_MFT_ANALYSIS=true
                shift
                ;;
            --attack-mapping)
                ATTACK_MAPPING=true
                shift
                ;;
            --no-attack-mapping)
                ATTACK_MAPPING=false
                shift
                ;;
            --no-color)
                NO_COLOR=true
                shift
                ;;
            --high-contrast)
                HIGH_CONTRAST=true
                shift
                ;;
            -i|--interactive)
                INTERACTIVE_MODE=true
                shift
                ;;
            # USB/Kit mode options
            --update-kit)
                DO_UPDATE_KIT=true
                shift
                ;;
            --build-full-kit)
                DO_BUILD_KIT=true
                shift
                ;;
            --build-minimal-kit)
                DO_BUILD_MINIMAL_KIT=true
                shift
                ;;
            --kit-target)
                KIT_TARGET="$2"
                shift 2
                ;;
            --usb-mode)
                USB_MODE=true
                shift
                ;;
            # ISO building options
            --build-iso)
                DO_BUILD_ISO=true
                shift
                ;;
            --iso-output)
                ISO_OUTPUT="$2"
                shift 2
                ;;
            --flash-iso)
                DO_FLASH_ISO=true
                FLASH_DEVICE="$2"
                shift 2
                ;;
            --create-persistence)
                CREATE_PERSISTENCE=true
                shift
                ;;
            --force)
                FORCE_FLASH=true
                shift
                ;;
            # Output storage options
            --output-device)
                OUTPUT_DEVICE="$2"
                shift 2
                ;;
            --output-path)
                OUTPUT_PATH="$2"
                shift 2
                ;;
            --output-tmpfs)
                USE_TMPFS_OUTPUT=true
                shift
                ;;
            --case-name)
                CASE_NAME="$2"
                shift 2
                ;;
            -h|--help)
                usage
                ;;
            -*)
                print_error "Unknown option: $1"
                usage
                ;;
            *)
                DEVICE="$1"
                shift
                ;;
        esac
    done

    # Load configuration file
    load_config

    # ============================================
    # USB/KIT MODE DETECTION AND SETUP
    # ============================================
    # Detect and setup USB kit environment if running from portable kit
    if type detect_usb_environment &>/dev/null; then
        if detect_usb_environment; then
            setup_usb_environment
            log "INFO" "Running in USB kit mode: $KIT_MODE"
        fi
    fi

    # ============================================
    # HANDLE SPECIAL OPERATIONS (exit after)
    # ============================================

    # Handle kit update
    if [ "$DO_UPDATE_KIT" = true ]; then
        if type update_usb_kit &>/dev/null; then
            print_banner
            update_usb_kit
            exit $?
        else
            print_error "Update manager module not available"
            exit 1
        fi
    fi

    # Handle full kit building
    if [ "$DO_BUILD_KIT" = true ]; then
        if type build_full_kit &>/dev/null; then
            print_banner
            local target="${KIT_TARGET:-./dms-kit}"
            build_full_kit "$target"
            exit $?
        else
            print_error "Kit builder module not available"
            exit 1
        fi
    fi

    # Handle minimal kit building
    if [ "$DO_BUILD_MINIMAL_KIT" = true ]; then
        if type build_minimal_kit &>/dev/null; then
            print_banner
            local target="${KIT_TARGET:-./dms-kit-minimal}"
            build_minimal_kit "$target"
            exit $?
        else
            print_error "Kit builder module not available"
            exit 1
        fi
    fi

    # Handle ISO building
    if [ "$DO_BUILD_ISO" = true ]; then
        if type build_dms_iso &>/dev/null; then
            print_banner
            build_dms_iso "$ISO_OUTPUT"
            exit $?
        else
            print_error "ISO builder module not available"
            exit 1
        fi
    fi

    # Handle ISO flashing
    if [ "$DO_FLASH_ISO" = true ]; then
        if type flash_iso_to_usb &>/dev/null; then
            print_banner
            if [ -z "$ISO_OUTPUT" ]; then
                print_error "ISO file required. Use --iso-output <path>"
                exit 1
            fi
            flash_iso_to_usb "$ISO_OUTPUT" "$FLASH_DEVICE"
            local result=$?
            # Optionally create persistence partition
            if [ "$CREATE_PERSISTENCE" = true ] && [ $result -eq 0 ]; then
                create_persistence_partition "$FLASH_DEVICE"
            fi
            exit $result
        else
            print_error "ISO builder module not available"
            exit 1
        fi
    fi

    # ============================================
    # NORMAL SCAN MODE CONTINUES BELOW
    # ============================================

    # Apply color settings based on flags
    apply_color_settings

    # Print banner
    print_banner

    # Run interactive mode if requested
    if [ "$INTERACTIVE_MODE" = true ]; then
        run_interactive_mode
        # If interactive mode exited (user quit), the script would have exited
        # If we get here, user pressed Start, so continue with scan
    fi

    # Handle resume mode
    if [ -n "$RESUME_FILE" ]; then
        if ! load_checkpoint "$RESUME_FILE"; then
            exit 1
        fi
    fi

    # Validate device
    if [ -z "$DEVICE" ]; then
        print_error "No device specified"
        usage
    fi

    # Export device for subprocesses
    export DEVICE
    export SCAN_DEVICE="$DEVICE"

    # Store evidence device info for output storage module
    EVIDENCE_DEVICE="$DEVICE"

    # Check privileges
    check_privileges

    # ============================================
    # OUTPUT STORAGE SETUP
    # ============================================
    # Setup output storage (especially important in live ISO mode)
    if type setup_output_storage &>/dev/null; then
        if ! setup_output_storage; then
            print_warning "Could not setup dedicated output storage"
            print_warning "Using default output directory"
        else
            # Create case directory for this scan
            if [ -n "$OUTPUT_MOUNT_POINT" ] && [ -d "$OUTPUT_MOUNT_POINT" ]; then
                local case_dir
                case_dir=$(create_case_directory)
                if [ -n "$case_dir" ]; then
                    # Override scan output directory with case directory
                    SCAN_OUTPUT_DIR="$case_dir"
                    print_status "Case directory: $case_dir"

                    # Create evidence info file
                    create_evidence_info "$case_dir"
                fi
            fi
        fi
    fi

    # Create output directory (if not already created by case directory)
    mkdir -p "$SCAN_OUTPUT_DIR"
    print_status "Scan output directory: $SCAN_OUTPUT_DIR"

    # Enable checkpoint saving
    SAVE_CHECKPOINT=true
    CHECKPOINT_FILE="$SCAN_OUTPUT_DIR/.checkpoint"

    # Initialize results array
    declare -gA RESULTS
    declare -gA SCAN_STATUS

    # Record scan start time for duration calculation
    SCAN_START_TIME=$(date +%s)

    # Run checks
    if ! run_scan "check_tools" check_tools; then
        print_error "Tool check failed"
        exit 1
    fi

    if ! run_scan "get_device_info" get_device_info; then
        print_error "Could not get device info"
        exit 1
    fi

    # Auto chunk size calculation
    if [ "$AUTO_CHUNK" = true ]; then
        calculate_optimal_chunk_size
        print_status "Using auto-calculated chunk size: ${CHUNK_SIZE}MB"
    fi

    # Mount if requested
    if [ "$DO_MOUNT" = true ]; then
        run_scan "mount_device" mount_device
    fi

    # Update ClamAV if requested
    if [ "$DO_UPDATE" = true ]; then
        run_scan "update_clamav" update_clamav
    fi

    # Slack space scan mode
    if [ "$SCAN_MODE" = "slack" ]; then
        print_section "Slack Space Scan Mode"
        print_status "Extracting and analyzing unallocated disk space..."

        # Run slack space extraction and analysis
        run_scan "slack_space" scan_slack_space

        # If slack extraction succeeded, scan the extracted data
        if [ -n "$SLACK_DEVICE" ] && [ -f "$SLACK_DEVICE" ]; then
            print_status "Scanning extracted slack space data..."

            # Store original device path
            local original_device="$DEVICE"

            # Point scans at the extracted slack data
            DEVICE="$SLACK_DEVICE"
            export SCAN_DEVICE="$SLACK_DEVICE"

            # Run scans on slack data
            if [ "$PARALLEL_MODE" = true ]; then
                run_scan "parallel_scans" run_parallel_scans
            else
                run_scan "clamav" scan_clamav
                run_scan "yara" scan_yara
                run_scan "strings" scan_strings
            fi

            # Restore original device path for reporting
            DEVICE="$original_device"
            export SCAN_DEVICE="$original_device"
        else
            print_warning "Slack space extraction failed or no data to scan"
        fi
    else
        # Full drive scan mode

        # Quick scan mode
        if [ "$QUICK_SCAN" = true ]; then
            run_scan "quick_scan" scan_quick

            # If quick scan found issues, suggest full scan
            if [ "${RESULTS[quick_scan]:-0}" -gt 0 ]; then
                print_warning "Quick scan found issues. Running full scan..."
            else
                print_success "Quick scan complete."
                generate_report
                [ "$HTML_REPORT" = true ] && generate_html_report
                [ "$JSON_REPORT" = true ] && generate_json_report
                exit 0
            fi
        fi

        # Run scans (parallel or sequential)
        if [ "$PARALLEL_MODE" = true ]; then
            run_scan "parallel_scans" run_parallel_scans
        else
            # Sequential scans with graceful error handling
            run_scan "clamav" scan_clamav
            run_scan "yara" scan_yara
            run_scan "binwalk" scan_binwalk
            run_scan "strings" scan_strings
        fi

        # VirusTotal scan
        if [ "$DO_VIRUSTOTAL" = true ]; then
            run_scan "virustotal" scan_virustotal
        fi

        # Rootkit scan
        if [ "$DO_ROOTKIT" = true ]; then
            run_scan "rootkit" scan_rootkit
        fi

        # Timeline generation
        if [ "$DO_TIMELINE" = true ]; then
            run_scan "timeline" generate_timeline
        fi

        # Deep scans
        if [ "$DEEP_SCAN" = true ]; then
            print_section "Starting Deep Scan"
            run_scan "entropy" scan_entropy
            run_scan "file_carving" scan_file_carving
            run_scan "executables" scan_executables
            run_scan "boot_sector" scan_boot_sector
            run_scan "bulk_extractor" scan_bulk_extractor
            run_scan "hashes" scan_hashes
        fi

        # Forensic Analysis scans
        if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_PERSISTENCE_SCAN" = true ] || \
           [ "$DO_EXECUTION_SCAN" = true ] || [ "$DO_FILE_ANOMALIES" = true ] || \
           [ "$DO_RE_TRIAGE" = true ] || [ "$DO_MFT_ANALYSIS" = true ]; then

            print_section "Starting Forensic Analysis"

            # Setup forensic tools if needed
            setup_forensic_tools

            # Persistence artifact analysis
            if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_PERSISTENCE_SCAN" = true ]; then
                run_scan "persistence" scan_persistence_artifacts
            fi

            # Execution artifact analysis (Phase 2 - to be implemented)
            if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_EXECUTION_SCAN" = true ]; then
                if type scan_execution_artifacts &>/dev/null; then
                    run_scan "execution" scan_execution_artifacts
                else
                    log "DEBUG" "Execution artifact scanning not yet implemented"
                fi
            fi

            # File anomaly detection (Phase 3 - to be implemented)
            if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_FILE_ANOMALIES" = true ]; then
                if type scan_file_anomalies &>/dev/null; then
                    run_scan "file_anomalies" scan_file_anomalies
                else
                    log "DEBUG" "File anomaly detection not yet implemented"
                fi
            fi

            # RE triage (Phase 3 - to be implemented)
            if [ "$FORENSIC_ANALYSIS" = true ] || [ "$DO_RE_TRIAGE" = true ]; then
                if type scan_re_triage &>/dev/null; then
                    run_scan "re_triage" scan_re_triage
                else
                    log "DEBUG" "RE triage not yet implemented"
                fi
            fi

            # MFT/filesystem analysis (Phase 4 - to be implemented)
            if [ "$DO_MFT_ANALYSIS" = true ]; then
                if type scan_filesystem_forensics &>/dev/null; then
                    run_scan "filesystem_forensics" scan_filesystem_forensics
                else
                    log "DEBUG" "Filesystem forensics not yet implemented"
                fi
            fi
        fi
    fi

    # Generate reports
    generate_report

    if [ "$HTML_REPORT" = true ]; then
        generate_html_report
    fi

    if [ "$JSON_REPORT" = true ]; then
        generate_json_report
    fi

    # Calculate total findings and duration
    local total_findings=0
    for key in "${!RESULTS[@]}"; do
        local val="${RESULTS[$key]}"
        if [[ "$val" =~ ^[0-9]+$ ]]; then
            total_findings=$((total_findings + val))
        fi
    done

    # Calculate scan duration
    local scan_end_time=$(date +%s)
    local scan_duration=$((scan_end_time - SCAN_START_TIME))
    local duration_min=$((scan_duration / 60))
    local duration_sec=$((scan_duration % 60))
    local duration_str=$(printf "%d minutes %d seconds" "$duration_min" "$duration_sec")

    # Show summary dashboard
    draw_summary_dashboard "$total_findings" "$duration_str"

    # Summary of scan status
    local failed_scans=0
    for scan in "${!SCAN_STATUS[@]}"; do
        if [ "${SCAN_STATUS[$scan]}" = "failed" ]; then
            failed_scans=$((failed_scans + 1))
        fi
    done

    if [ $failed_scans -gt 0 ]; then
        echo ""
        print_warning "$failed_scans scan(s) encountered errors but scan completed"
    fi

    # ============================================
    # OUTPUT STORAGE CLEANUP
    # ============================================
    # Show output storage summary and handle cleanup
    if type cleanup_output_storage &>/dev/null; then
        cleanup_output_storage
    fi

    # Display case directory location if created
    if [ -n "$CURRENT_CASE_DIR" ] && [ -d "$CURRENT_CASE_DIR" ]; then
        echo ""
        print_success "Case files saved to: $CURRENT_CASE_DIR"
    fi
}

# Run main function
main "$@"
